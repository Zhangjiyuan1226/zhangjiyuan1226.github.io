<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/10/27/hello-world/"/>
    <url>/2024/10/27/hello-world/</url>
    
    <content type="html"><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo n <span class="hljs-string">&quot;Chapter1&quot;</span><br></code></pre></td></tr></table></figure><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean// before server it<br>--------------------------------------<br>$ hexo s<br></code></pre></td></tr></table></figure><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Quant</title>
    <link href="/2024/10/26/Quant/"/>
    <url>/2024/10/26/Quant/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>OperatingSystem:JYY</title>
    <link href="/2024/10/21/OperatingSystem-JYY/"/>
    <url>/2024/10/21/OperatingSystem-JYY/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h1><ul><li><p>why <del>为什么要学os？</del> 为什么会有os？  </p></li><li><p>what 什么是os？</p></li><li><p>how 怎么学os？</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Fixed Income</title>
    <link href="/2024/08/26/Fixed-Income/"/>
    <url>/2024/08/26/Fixed-Income/</url>
    
    <content type="html"><![CDATA[<h4 id="贴现-折现"><a href="#贴现-折现" class="headerlink" title="贴现 &amp; 折现"></a>贴现 &amp; 折现</h4><p>现金流是什么？</p><h2 id="固定收益证券概述"><a href="#固定收益证券概述" class="headerlink" title="固定收益证券概述"></a>固定收益证券概述</h2><h3 id="固定收益证券的类型"><a href="#固定收益证券的类型" class="headerlink" title="固定收益证券的类型"></a>固定收益证券的类型</h3><p>债券现金流稳定</p><p>资本市场&#x2F;货币市场</p><p>我国的债券交易场所是割裂的，按交易市场划分有</p><p>交易所 银行间 柜台市场</p><p>国债（资本政策）&#x2F;央票（货币政策）</p><p>信用债&#x2F;利率债&#x2F;准利率债</p><p>金融债&#x2F;非金融债   </p><p>隐形债务</p><p>地方政府的收入：税收 and 卖地</p><p>化债方式：招商引资</p><p>次级债</p><h4 id="货币市场"><a href="#货币市场" class="headerlink" title="货币市场"></a>货币市场</h4><p>调节流动性</p><p>央票 灵活性、可操作度</p><p>货币政策：存款准备金 利率 </p><p>同业拆借 主体是金融机构 </p><p>银根的放松收紧一定是先在同业市场体现，同业市场利率较低 </p><blockquote><p>大于一年的无风险利率 国债利率</p><p>小于一年的无风险利率 同业拆借利率</p></blockquote><p>利率衍生品</p><p>利率期货、利率期权 底层标的是债券</p><p>利率远期（FRA）、利率互换 底层标的是利率</p><p>信用衍生品</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>System-Paper Reading</title>
    <link href="/2024/06/27/System-Paper-Reading/"/>
    <url>/2024/06/27/System-Paper-Reading/</url>
    
    <content type="html"><![CDATA[<h2 id="Machine-Learning-System"><a href="#Machine-Learning-System" class="headerlink" title="Machine Learning System"></a>Machine Learning System</h2><h3 id="Intro-to-DL"><a href="#Intro-to-DL" class="headerlink" title="Intro to DL"></a>Intro to DL</h3><p>Inputs <em>x</em> to outputs <em>y</em></p><h3 id="Tensorflow"><a href="#Tensorflow" class="headerlink" title="Tensorflow"></a>Tensorflow</h3><h3 id="TVM"><a href="#TVM" class="headerlink" title="TVM"></a>TVM</h3><h3 id="Learned-Index"><a href="#Learned-Index" class="headerlink" title="Learned Index"></a>Learned Index</h3>]]></content>
    
    
    
    <tags>
      
      <tag>Paper Reading</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Machine Learning in Pratice</title>
    <link href="/2024/06/21/Machine-Learning-in-Pratice/"/>
    <url>/2024/06/21/Machine-Learning-in-Pratice/</url>
    
    <content type="html"><![CDATA[<h2 id="Pipeline-in-ML-question"><a href="#Pipeline-in-ML-question" class="headerlink" title="Pipeline in ML question"></a>Pipeline in ML question</h2><p>Youtube广告推荐问题：</p><ul><li>Youtube视频中包含广告，每隔十分钟出现一次</li><li>广告播放越多 从广告商中获取的收益越多</li></ul><ol><li><p>Define a ML problem</p><ul><li>将实际问题转化为用ML解决的问题</li></ul><p>目标：收益越多越好 ——&gt;如何增加收益？——&gt;用户看的广告越多——&gt;用户看的视频越多</p><p>细化：如何判断用户看的视频多？——&gt; 点击率（Click Through Rate）&#x2F; 有效观看时长</p><p>方法：根据指标排序，并为用户推荐相应视频</p><ul><li>数据中是否存在相似的pattern？</li><li>能否获取到数据集？数据集是否带标签？任务是supervised还是un supervised？</li></ul></li><li><p>Construct DataSet</p></li><li><p>Transform data &amp; Feature Engineering</p><ul><li>数据中有效的特征？</li></ul><p>可以从ML任务中的所有参与者中寻找有效的特征</p><p>视频本身的属性：视屏的种类&#x2F;视频的时长</p><p>周围环境：当前环境的热点</p><p>个人因素：个人的喜好&#x2F;年龄&#x2F;性别&#x2F;工作</p></li><li><p>Design and train models</p></li><li><p>Use Model to predict</p><ul><li>Testing</li></ul></li></ol><h2 id="Metrics"><a href="#Metrics" class="headerlink" title="Metrics"></a>Metrics</h2><p>True&#x2F;False: means predicet result 预测结果</p><p>Postive&#x2F;Negitive: the actual result is true or false 实际结果</p><p><strong>TP</strong>(True Postive) 正确分类的阳性样本，实际为正确的</p><p><strong>TN</strong>(True Negative) 正确分类的阴性样本，实际为正确的</p><p><strong>FP</strong>(Flase Postive) 错误分类到阳性的样本，实际为阴性，预测为阳性</p><p><strong>FN</strong>(Flase Negative) 错误分类到阴性的样本，实际为阳性，预测为阴性</p><p>Accuracy: all true predict result in data N<br>$$<br>Accuracy&#x3D;\frac{\sum_{i&#x3D;1}^{n}(y_i \neq f(x, \theta_i))}{N}<br>$$<br> Precision<strong>查准度</strong> 在所有预测为阳性的结果中，正确的结果有多少<br>$$<br>Precision&#x3D;\frac{TP}{TP+FP}<br>$$<br>Recall<strong>查全度</strong> 在所有实际为阳性的样本中，预测出为阳性的结果有多少<br>$$<br>Recall&#x3D;\frac{TP}{TP+FN}<br>$$</p>]]></content>
    
    
    
    <tags>
      
      <tag>Machine Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MHRD build your own cpu</title>
    <link href="/2024/06/10/MHRD-build-your-own-cpu/"/>
    <url>/2024/06/10/MHRD-build-your-own-cpu/</url>
    
    <content type="html"><![CDATA[<p><img src="/2024/06/10/MHRD-build-your-own-cpu/image-20240614162614807.png" alt="image-20240614162614807"></p><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><h4 id="welcome-translate"><a href="#welcome-translate" class="headerlink" title="welcome translate"></a>welcome translate</h4><p>Giants are not what we think they are. <strong>The same qualities that appear to give them strength are often the sources of great weakness.</strong> </p><p>We at Microhard firmly believe that the modern CPUs available in the market place are far more complex that what is good for them.</p><p>By having complex instruction sets and downward compatibility the giants of the tech industry trade legacy for efficiency.</p><p>three tips:</p><ul><li>if you don’t konw what to do: read the manual and specifications!</li><li>When creating your design: Draw it out on a piece of paper! No one ever created something great just by looking at his screen</li><li>if something is wrong with your design: Inspect the error messages and failed tests closely to find out where the problem is.</li></ul><p>appear to 看起来；出现；呈现</p><h4 id="design"><a href="#design" class="headerlink" title="design"></a>design</h4><p>MHRD中所有的元器件都是由NAND组成，因此我们要基于NAND实现例如非门 异或等基础功能，并在此之上实现加法器等工具</p><ul><li><p>NAND  not and <em>有0就是1，两个1才是0</em></p></li><li><p>NOT  </p><p>input1 output: negate input1by nand </p><pre><code class=" mermaid">graph LRA[input] --&gt;C[NAND]1 --&gt;C[NAND]C --&gt; output</code></pre></li><li><p>AND</p><pre><code class=" mermaid">   graph LR   A[input1] --&gt;C[NAND]   input2 --&gt;C[NAND]   C[NAND]--&gt; D[NOT]   D[NOT]--&gt;output</code></pre></li><li><p>OR</p><p>if inputs have 1, the outputs will be one unless the inputs are 0</p><pre><code class=" mermaid">   graph LR   A[NOT in1] --&gt;C[NAND]   B[NOT in2] --&gt;C[NAND]C[NAND] --&gt; output</code></pre></li><li><p>XOR</p><p>if the two inputs are same, the output will be 0.</p><pre><code class=" mermaid">   graph LR   A[in1] --&gt;C[NAND]   B[in2] --&gt;C[NAND]C[NAND] --&gt; ANDD[NOT in1] --&gt;E[NAND]   F[NOT in2] --&gt;E[NAND]E[NAND] --&gt; ANDAND --&gt; output</code></pre></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs shell">Instruction Decoder Specification<br>=================================<br><br>Description:<br>------------<br>The DECODER is used in the Microhard CPU for decoding instructions. There are two different kinds of instructions.<br><br>First, if instr[16] equals &quot;1&quot;, then instr[1:15] have to be interpreted as a constant which has to be loadedinto the memory register. In this case the &quot;cToM&quot; and &quot;loadM&quot; output has to be set to &quot;1&quot;, while the &quot;loadD&quot;, &quot;loadA&quot; and &quot;jmpIfZ&quot; outputs have to be &quot;0&quot;. In addition the lower 15 bit of the instruction have to be written into &quot;constant&quot;.<br><br>Second, if instr[16] equals &quot;0&quot;, then the decoder has to interpret the rest of the instruction in a more elaborate way:<br><br>bit:                         16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1<br>instr[1:16]:                  0  d  d  a  b  b  o  o  o  o  j  c  c  c  c  c<br>                                 \__/  |  \__/  \________/  |  \___________/<br>instr[14:15] destination    ------/    |   |        |       |        |<br>instr[13]    operand1       -----------/   |        |       |        |<br>instr[11:12] operand2       ---------------/        |       |        |<br>instr[7:10]  operation code ------------------------/       |        |<br>instr[6]     jump if zero   --------------------------------/        |<br>instr[1:5]   constant       -----------------------------------------/<br><br>In this case the CPU has to perform the operation specified by &quot;operation code&quot; with the operands decoded by &quot;operand1&quot; and &quot;operand2&quot;.<br><br>The &quot;operation code&quot;, the &quot;operand1&quot;, the &quot;operand2&quot; and the &quot;jump if zero&quot; bits of the instruction can be directly transfered to the &quot;opCode&quot;, &quot;op1&quot;, &quot;op2&quot;, &quot;jmpIfZ&quot; outputs of the decoder respectively.<br><br>As in the other case the lower 15 bit of the instruction have to be written into &quot;constant&quot;. Note however, that in this case the CPU has to feed only the 5 lowest &quot;constant&quot; bits to the ALU when using the constant as an operand.<br><br>If &quot;operand1&quot; is &quot;0&quot; then the value of the address register is fed to the ALU as operand. Otherwise the &quot;constant&quot; represented by the bits instr[1:5] is fed as first operand.<br><br>The destination specifies where the result of the ALU operation has to be saved. While &quot;op1&quot; and &quot;op2&quot; are decoded by the CPU, the &quot;destination&quot; bits of the instruction have to be decoded by the DECODER in regards to the following decoding rules:<br><br>destination = 00 -&gt; set loadA, loadM and loadD to 0<br>destination = 01 -&gt; set loadA to 1 ; set loadM  and loadD to 0<br>destination = 10 -&gt; set loadM to 1 ; set loadA  and loadD to 0<br>destination = 11 -&gt; set loadD to 1 ; set loadA  and loadM to 0<br><br>Interface Specification:<br>------------------------<br>Inputs: instr[16];<br>Outputs: cToM, loadA, loadD, loadM, op1, op2[2], opCode[4], jmpIfZ, constant[15];<br><br><br>Graphical Representation:<br>-------------------------<br>             _________<br>            |         |--cToM---------<br>            |         |--loadA----------<br>            |         |--loadD----------<br>            |         |--loadM----------<br>-instr[16]--| Decoder |--op1----------<br>            |         |--op2[2]-------<br>            |         |--opCode[4]----<br>            |         |--jmpIfZ-------<br>            |_________|--constant[15]-<br><br><br>Examples:<br>---------<br> instr  || cToM | jmpIfZ | loadA | loadD | loadM | op1 | constant | op2 | opCode<br> -------------------------------------------------------------------------------<br> 0x0000 || 0    | 0      | 0     | 0     | 0     | 0   | 0x0000   | 00  | 0000<br> 0x8000 || 1    | 0      | 0     | 0     | 1     | 0   | 0x0000   | 00  | 0000<br> 0xFFFF || 1    | 0      | 0     | 0     | 1     | 1   | 0x7FFF   | 11  | 1111<br> 0x7FFF || 0    | 1      | 0     | 1     | 0     | 1   | 0x7FFF   | 11  | 1111<br> 0x7C1F || 0    | 0      | 0     | 1     | 0     | 1   | 0x7C1F   | 11  | 0000<br> 0x7C0F || 0    | 0      | 0     | 1     | 0     | 1   | 0x7C0F   | 11  | 0000<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs shell">Microhard Central Processing Unit Specification<br>===============================================<br><br>Description:<br>------------<br>On a high level the Microhard CPU is able to perform a wide variety of instructions similar to the Microhard ALU. However while the ALU is only capable of executing single arithmetic instructions, the CPU is able to execute complex programs composed of many instructions by managing the program execution flow.<br><br><br>Interface Specification:<br>------------------------<br>Inputs: instr[16], data[16], reset;<br>Outputs: write, dataAddr[16], instrAddr[16], result[16];<br><br><br>Graphical Representation:<br>-------------------------<br>             _____<br>-instr[16]--|     |--instrAddr[16]-<br>            |     |<br>--data[16]--| CPU |--dataAddr[16]--<br>            |     |--result[16]----<br>            |_____|--write---------<br>               |<br>-------reset---/<br><br><br>User Instructions:<br>------------------<br>To execute a program the CPU needs to be connected to a RAM element containing the instructions of the program and a second RAM element containing all data which should be processed.<br><br>The program RAM element has to be connected to the CPU via the &quot;instr&quot; and &quot;instrAddr&quot; busses. The &quot;in&quot; bus and the &quot;load&quot; input of the RAM is supposed to be disconnected.<br><br>The data RAM element has to be connected to the CPU via the &quot;data&quot; and &quot;dataAddr&quot; busses. The &quot;in&quot; bus of the RAM has to be connected to the &quot;result&quot; output of the CPU and the &quot;load&quot; input of the RAM has to be connected to the &quot;write&quot; output of the CPU.<br><br>To start the program, the reset pin has to be supplied with the value &quot;1&quot; for a single clock cycle to make sure the program is executed from the beginning.<br><br><br>Implementation Details:<br>-----------------------<br>The CPU contains (among other elements) two registers, one counter and one ALU:<br>- the Arithmetic-Register (AR) is used to temporarily store computation results<br>- the Memory-Register (MR) is used to reference addresses in the connected data<br>  RAM<br>- the Program-Counter (PC) is used to reference addresses in the connected<br>  instruction RAM<br>- the ALU is used to perform arithmetic operations<br><br>This specification will refer to the elements as AR, MR, PC and ALU.<br><br><br>Behavioral Specification:<br>-------------------------<br>After the instruction has been decoded by the DECODER (see the DECODER specification for details), the CPU uses the DECODER outputs to ensure following behavior:<br><br>- If the &quot;cToM&quot; and &quot;loadM&quot; output of the decoder is &quot;1&quot;, the &quot;constant&quot; output<br>  has to be loaded into the MR.<br>- If &quot;loadM&quot; is &quot;1&quot; and &quot;cToM&quot; is &quot;0&quot;, the result of the ALU operation has to be<br>  loaded into the MR.<br>- If &quot;loadA&quot; is &quot;1&quot;, the result of the ALU operation has to be loaded into the<br>  AR.<br>- The &quot;write&quot; output of the CPU has to have the same value as the &quot;loadD&quot; output<br>  of the DECODER.<br>- The &quot;opCode&quot; output of the DECODER has to be directly fed into the ALU.<br>- If the &quot;op1&quot; output of the DECODER is &quot;1&quot;, the &quot;constant&quot; has to be fed in to<br>  the ALU as the first operand. Otherwise the AR has to be fed into the ALU.<br>- For the &quot;op2&quot; output of the DECODER:<br>  &quot;00&quot; -&gt; feed &quot;constant&quot; as second operator into the ALU<br>  &quot;01&quot; -&gt; feed AR as second operator into the ALU<br>  &quot;10&quot; -&gt; feed MR as second operator into the ALU<br>  &quot;11&quot; -&gt; feed data bus as second operator into the ALU<br>- When feeding &quot;constant&quot; as an operand to the ALU, only the lowest 5 bits of &quot;constant&quot; are used. This 5 bit value is padded to 16 bit in accordance to the sign of the value.<br>- If &quot;jmpIfZ&quot; and the &quot;zero&quot; flag of the ALU is &quot;1&quot;, load the value of the MR<br>  into the PC.<br>- Write the ALU output on the &quot;result&quot; bus.<br>- Write the MR value on the &quot;dataAddr&quot; bus.<br>- Write the PC value on the &quot;instrAddr&quot; bus.<br>- Set the PC to &quot;0&quot; if the &quot;reset&quot; input is set.<br><br><br>Examples:<br>---------<br> instr  | data   | reset || instrAddr | dataAddr | result  | write<br> -----------------------------------------------------------------<br> // result = const + AR = ? (unknown register states):<br> 0x0000 | 0x0000 | 0     || x         | x        | x       | 0<br> // reset program counter:<br> 0x0000 | 0x0000 | 1     || x         | x        | x       | 0<br> // load 0x00FF into MR:<br> 0x80FF | 0x0000 | 0     || 0x0000    | x        | x       | 0<br> // AR = const + data = 1 + 0 = 1:<br> 0x3C01 | 0x0000 | 0     || 0x0001    | 0x00FF   | 0x0001  | 0<br> // result = AR + const = 1:<br> 0x0000 | 0x0000 | 0     || 0x0002    | 0x00FF   | 0x0001  | 0<br> // MR = AR + const = 1:<br> 0x4000 | 0x0000 | 0     || 0x0003    | 0x00FF   | 0x0001  | 0<br> // data = const + MR = 1:<br> 0x7800 | 0x0000 | 0     || 0x0004    | 0x0001   | 0x0001  | 1<br> // load MR into PC:<br> 0x1020 | 0x0001 | 0     || 0x0005    | 0x0001   | 0x0000  | 0<br> // no operation:<br> 0x1000 | 0x0001 | 0     || 0x0001    | 0x0001   | 0x0000  | 0<br> // no operation:<br> 0x1000 | 0x0001 | 0     || 0x0002    | 0x0001   | 0x0000  | 0<br><br></code></pre></td></tr></table></figure><p><img src="/2024/06/10/MHRD-build-your-own-cpu/image-20240614151915654.png" alt="image-20240614151915654"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Games</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Basic Concept</title>
    <link href="/2024/05/28/Basic-Concept/"/>
    <url>/2024/05/28/Basic-Concept/</url>
    
    <content type="html"><![CDATA[<h2 id="存储系统入门"><a href="#存储系统入门" class="headerlink" title="存储系统入门"></a>存储系统入门</h2><h3 id="总线系统"><a href="#总线系统" class="headerlink" title="总线系统"></a>总线系统</h3><p>计算机中各部件通信的通道，总线承载能力为带宽；</p><ul><li>SATA总线<strong>是一种串行总线（或 串行ATA），是用于连接SSD、HDD 和光盘驱动器的存储协议 。</strong></li><li>PCIe总线</li></ul><p>区别：</p><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>存储系统中协议定义了数据如何封装，传输，解封</p><ul><li>SATA</li><li>NVMe</li><li>SCSI</li></ul><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>外设与计算机连接的物理接口</p><ul><li>SATA </li><li>PCIe 直连主板和固态驱动器，主要用于高性能NVMe SSD</li><li>M.2 小型内部接口，主要用于笔记本和紧凑型接口</li></ul><p>基于SATA接口的 SSD：通过SATA总线与计算机系统连接，遵循SATA协议。虽然其数据传输速度不如基于PCIe的SSD，但对于日常使用和成本敏感型用户来说，是一个选择</p><p>基于M.2接口的高速 SSD：采用M.2接口，直接插入主板上的M.2插槽。它通过PCIe总线进行通信，支持NVMe协议，它能够利用PCIe总线的高带宽和低延迟特性，提供远超传统SATA SSD的性能。这款SSD尤其适合需要快速数据访问的应用，如高速游戏加载、视频编辑一般是家用电脑和笔记本使用。</p><p>基于PCIe接口的高性能 SSD：通过PCIe接口直接连接到主板，使用PCIe总线和NVMe协议，为追求极致性能的用户提供了强大的存储解决方案。非常适合数据中心、服务器以及对性能有极高要求的专业工作环境，一般分布式存储就是使用基于 PCIe 接口的 NVMe SSD。</p><h3 id="SSD"><a href="#SSD" class="headerlink" title="SSD"></a>SSD</h3><p>SSD中一般有多个NAND Flash，每个NAND Flash包含多个Block，每个Block包含多个Page。由于NAND的特性，其存取都必须以page为单位，即每次读写至少是一个page，通常地，每个page的大小为4k或者8k。另外，NAND还有一个特性是，其只能是读或写单个page，但不能覆盖写如某个page，必须先要清空里面的内容，再写入。<strong>由于清空内容的电压较高，必须是以block为单位。</strong>因此，没有空闲的page时，必须要找到没有有效内容的block，先擦写，然后再选择空闲的page写入。</p><p>在SSD中，一般会维护一个mapping table，维护逻辑地址到物理地址的映射。每次读写时，可以通过逻辑地址直接查表计算出物理地址，与传统的机械磁盘相比，省去了寻道时间和旋转时间。</p><p>对于SSD的写操作，针对不同的情况，有不同的处理流程，主要是受到NAND Flash的如下特性限制</p><ul><li>NAND Flash每次写必须以page为单位，且只能写入空闲的page，不能覆盖写原先有内容的page</li><li>擦除数据时，由于电压较高，只能以block为单位擦除</li></ul><p><strong>MB&#x2F;s和IOPS都是可以用来表示固态硬盘速度的单位，只是它们各自的表现形式不同而已。MB&#x2F;s用于关注顺序读写性能的场合，侧重数据吞吐量；IOPS用于关注随机读写性能的场合，注重每秒对SSD的操作数。</strong></p><h3 id="SSD写放大"><a href="#SSD写放大" class="headerlink" title="SSD写放大"></a>SSD写放大</h3><p>SSD的写放大问题，一般由如下三个方面引起：</p><ul><li>SSD读写是以page为单位的，如果更新page中的部分数据，也需要写整个page</li><li>SSD的garbage collection中，会在block间移动数据</li><li>SSD的wear leveing中，可能也会在block间交换数据，导致写放大</li></ul><p>通常的，需要在其他方面和SSD的写放大之间做权衡，例如，可以减少garbage collection的频率来减少写放大问题；可以把SSD分成多个zone，每个zone使用不同的wear leveling方法等等。</p><h3 id="数据库中的SSD"><a href="#数据库中的SSD" class="headerlink" title="数据库中的SSD"></a>数据库中的SSD</h3><h3 id="NVMe"><a href="#NVMe" class="headerlink" title="NVMe"></a>NVMe</h3><h3 id="NUMA"><a href="#NUMA" class="headerlink" title="NUMA"></a>NUMA</h3><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h3><h3 id="RDMA"><a href="#RDMA" class="headerlink" title="RDMA"></a>RDMA</h3><h3 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Web</title>
    <link href="/2024/05/28/Web/"/>
    <url>/2024/05/28/Web/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DeFi</title>
    <link href="/2024/04/03/DeFi/"/>
    <url>/2024/04/03/DeFi/</url>
    
    <content type="html"><![CDATA[<h2 id="DeFi"><a href="#DeFi" class="headerlink" title="DeFi"></a>DeFi</h2><h2 id="CEX-Intro"><a href="#CEX-Intro" class="headerlink" title="CEX Intro"></a>CEX Intro</h2><h2 id="DEX-Intro"><a href="#DEX-Intro" class="headerlink" title="DEX Intro"></a>DEX Intro</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Architecture of a Database System</title>
    <link href="/2024/03/26/Architecture-of-a-Database-System/"/>
    <url>/2024/03/26/Architecture-of-a-Database-System/</url>
    
    <content type="html"><![CDATA[<h1 id="Architecture-of-a-Database-System"><a href="#Architecture-of-a-Database-System" class="headerlink" title="Architecture of a Database System"></a>Architecture of a Database System</h1><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p><img src="/2024/03/26/Architecture-of-a-Database-System/image-20240326132813618.png" alt="image-20240326132813618"></p><h2 id="Parallel-Architecture"><a href="#Parallel-Architecture" class="headerlink" title="Parallel Architecture"></a>Parallel Architecture</h2><h3 id="Shared-Memory"><a href="#Shared-Memory" class="headerlink" title="Shared-Memory"></a>Shared-Memory</h3><ul><li>UMA</li></ul><p>统一内存访问，所有处理器共享同一片内存空间，因此内存总线带宽成为新的瓶颈、访问同一块地址出现冲突</p><ul><li>NUMA</li></ul><h3 id="Shared-Disk"><a href="#Shared-Disk" class="headerlink" title="Shared-Disk"></a>Shared-Disk</h3><h2 id="Relational-Query-Processor"><a href="#Relational-Query-Processor" class="headerlink" title="Relational Query Processor"></a>Relational Query Processor</h2><blockquote><p><a href="http://db.cs.berkeley.edu/papers/fntdb07-architecture.pdf">paper地址</a></p><p><a href="https://www.bilibili.com/video/BV1tE411B7Q2/?spm_id_from=333.999.0.0&vd_source=15c0ba00ac46ed4fee287167e287e497">tidb 视频分享</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>DB Paper Reading</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hylee_ml</title>
    <link href="/2024/03/23/hylee-ml/"/>
    <url>/2024/03/23/hylee-ml/</url>
    
    <content type="html"><![CDATA[<p>Model Pre-trained Fine-tune testing</p><p>自督导式学习  基石模型 GPT</p><p>督导式学习</p><p><img src="/2024/03/23/hylee-ml/image-20240324143839193.png" alt="image-20240324143839193"></p><ul><li><p>预训练的作用</p><p>Three Step of Deep learning</p><ol><li>define a set of function </li><li>goodness of function</li><li>pick the best function</li></ol><p>This function input is an vector, output is another vector</p></li></ul><h2 id="CNN"><a href="#CNN" class="headerlink" title="CNN"></a>CNN</h2><h3 id="Spatial-Transformer"><a href="#Spatial-Transformer" class="headerlink" title="Spatial Transformer"></a>Spatial Transformer</h3><ul><li>CNN is not invariant to scaling and rotation. 当图片放大或旋转之后，CNN无法识别对应内容</li></ul><p>How to transformer an image&#x2F;feature map?<br>$$<br>a_{n m}^{l}&#x3D;\sum_{i&#x3D;1}^{3} \sum_{j&#x3D;1}^{3} w_{\substack{l \}} a_{i j}^{l-1}<br>$$</p><p>$$<br>\begin{equation}<br>\begin{bmatrix}<br>cos\theta &amp; -si n\theta \<br>sin\theta &amp; cos\theta<br>\end{bmatrix}<br>\end{equation}<br>$$</p><pre><code class=" mermaid">graph LRA[Data] --&gt;|Pre-train|B(圆角)B --&gt; C&#123;条件a&#125;C --&gt;|a=1| D[结果1]C --&gt;|a=2| E[结果2]</code></pre><h2 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h2><h3 id="slot-filling"><a href="#slot-filling" class="headerlink" title="slot filling"></a>slot filling</h3><p>There is a memory  for remember the context</p><p><img src="/2024/03/23/hylee-ml/image-20240527234940890.png" alt="image-20240527234940890"></p><h2 id="13-Semi-supervised-learning"><a href="#13-Semi-supervised-learning" class="headerlink" title="13. Semi-supervised learning"></a>13. Semi-supervised learning</h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>instructive learning</p><ul><li>Why semi-supervised learning?</li></ul><p>e.g. 小时候我们可能会通过父母对动物有一个认识，知道什么是猫什么是狗，但长大后我们自己还会见识到很多猫猫狗狗，但这些信息是没有标签的，需要我们自己根据以前的信息识别</p><ul><li>Why semi-supervised learning helps?</li></ul><p><strong>The, distrubtion of unlabed-data can tell us something, but semi-supervised learning usually with some assumptions and its performance depend on assumptions</strong></p><h2 id="14-unsupervised-learning"><a href="#14-unsupervised-learning" class="headerlink" title="14. unsupervised learning"></a>14. unsupervised learning</h2><h3 id="Word-Embedding"><a href="#Word-Embedding" class="headerlink" title="Word Embedding"></a>Word Embedding</h3><h4 id="count-based"><a href="#count-based" class="headerlink" title="? count based"></a>? count based</h4><ul><li>if two words wi and wj frequently co-occur, V(wi) and V(wj) would be close to each other</li></ul><p>Glove Vector</p><h4 id="Prediction-based"><a href="#Prediction-based" class="headerlink" title="Prediction based"></a>Prediction based</h4><p>Sharing Parameter</p>]]></content>
    
    
    
    <tags>
      
      <tag>Deep Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>db meeting</title>
    <link href="/2024/02/16/db-meeting/"/>
    <url>/2024/02/16/db-meeting/</url>
    
    <content type="html"><![CDATA[<h1 id="The-Boston-Report-on-DB-research"><a href="#The-Boston-Report-on-DB-research" class="headerlink" title="The Boston Report on DB research"></a>The Boston Report on DB research</h1><p>两天的会议主要讨论了四个topic，分别是Cloud Native, llm, </p><h2 id="Cloud-Native"><a href="#Cloud-Native" class="headerlink" title="Cloud Native"></a>Cloud Native</h2><ul><li><p>Multi-master 当前数据都在内存，如何把数据打通？</p></li><li><p>Serverless data Analytics</p></li><li><p>Price-performance trade-off </p></li><li><p>Energy-efficient, green computing</p></li><li><p>Human-centered interactive data analysis</p></li><li><p>In-DB ML</p></li><li><p>Data Federation (同一个公司不同业务部门间不同数据库内zero-ETL )</p></li><li><p>Data Marketing, Data Sharing</p><ul><li>数据胶囊</li></ul></li><li><p>Data econsystem</p></li><li><p>Data compiler</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>paper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fabric</title>
    <link href="/2024/02/11/fabric/"/>
    <url>/2024/02/11/fabric/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/m0_65287626/article/details/134251862?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-134251862-blog-115708344.235%5Ev43%5Epc_blog_bottom_relevance_base9&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-134251862-blog-115708344.235%5Ev43%5Epc_blog_bottom_relevance_base9&utm_relevant_index=5">fabric caliper测试</a></p><p><a href="https://fisco-doc.readthedocs.io/zh/release-2.8.0/docs/tutorial/stress_testing.html">fisco bicos 压力测试</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>bustub</title>
    <link href="/2024/02/01/bustub/"/>
    <url>/2024/02/01/bustub/</url>
    
    <content type="html"><![CDATA[<h1 id="15445性能优化"><a href="#15445性能优化" class="headerlink" title="15445性能优化"></a>15445性能优化</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>鉴于mac上安装perf不方便，我在centos的docker容器中使用perf对bmp-benchmark进行分析</p><ul><li>在docker中使用perf首先需要开启privilege模式；生成火焰图，并在speedscope中打开</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker pull centos</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -it --privileged -v /yourpath:/root/bustub --name bustub_centos centos bash</span> <br><span class="hljs-meta prompt_">$ </span><span class="language-bash">yum update -y</span> <br><span class="hljs-meta prompt_">$ </span><span class="language-bash">yum install -y perf</span> <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo perf record -g ./bin/bustub-bpm-bench --duration 5000 --latency 1</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo perf script -i perf.data &gt; profile.linux-perf.txt</span><br></code></pre></td></tr></table></figure><ul><li>除此之外还可能遇到docker优先级不够的问题，可以修改<strong>kptr_restrict</strong>和<strong>perf_event_paranoid</strong>的优先级</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">WARNING: Kernel address maps (/proc/&#123;kallsyms,modules&#125;) are restricted,</span><br>check /proc/sys/kernel/kptr_restrict and /proc/sys/kernel/perf_event_paranoid.<br><br>Samples in kernel functions may not be resolved if a suitable vmlinux<br>file is not found in the buildid cache or in the vmlinux path.<br><br>Samples in kernel modules won&#x27;t be resolved at all.<br><br>If some relocation was applied (e.g. kexec) symbols may be misresolved<br>even with a suitable vmlinux or kallsyms file.<br><br>Couldn&#x27;t record kernel reference relocation symbol<br>Symbol resolution may be skewed if relocation was used (e.g. kexec).<br>Check /proc/kallsyms permission or run as root.<br>Couldn&#x27;t synthesize bpf events.<br></code></pre></td></tr></table></figure><blockquote><p> <a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E5%AE%B9%E5%99%A8%E5%AE%9E%E6%88%98%E9%AB%98%E6%89%8B%E8%AF%BE/%E5%8A%A0%E9%A4%9002%20%E7%90%86%E8%A7%A3perf%EF%BC%9A%E6%80%8E%E4%B9%88%E7%94%A8perf%E8%81%9A%E7%84%A6%E7%83%AD%E7%82%B9%E5%87%BD%E6%95%B0%EF%BC%9F.md">perf介绍</a></p></blockquote><h2 id="p1-buffer-pool-manager"><a href="#p1-buffer-pool-manager" class="headerlink" title="p1 buffer pool manager"></a>p1 buffer pool manager</h2><h3 id="workload"><a href="#workload" class="headerlink" title="workload"></a>workload</h3><p>benchmark中包含scan顺序读写和get随机读写两种线程，scan线程会存在污染lruk的情况（缓存命中率低）</p><p>测试会跑三次benchmark，前两次是in-mermory的，最后一次scan加了0.1ms的延迟模拟disk io ，get加了1ms模拟disk io</p><ol><li>Better replacer algorithm. Given that get workload is skewed (i.e., some pages are more frequently accessed than others), you can design your LRU-k replacer to take page access type into consideration, so as to reduce page miss.</li><li>Parallel I&#x2F;O operations. Instead of processing one request at a time in your disk scheduler, <strong>you can issue multiple requests to the disk manager at the same time</strong>. This optimization will be very useful in modern storage devices, where concurrent access to the disk can make better use of the disk bandwidth. You should handle the case that multiple operations to the same page are in the queue and the end result of these requests should be as if they are processed in order. In a single thread, they should have read-after-write consistency.</li><li>To achieve true parallelism in disk scheduler, you will also need to allow your buffer pool manager can handle multiple <code>FetchPage</code> requests and evicting multiple pages at the same time. You might need to bring in a conditional variable in your buffer pool manager to manage free pages.</li><li>You can use our provided lock-free queue implementation in <code>third_party/readerwriterqueue</code> and create your own <code>promise</code> implementation that is compatible with <code>std::promise</code> so as to lower the overhead of inter-thread communication. Note that in this project, all requests must go through the <code>DiskScheduler</code>‘s background thread.</li></ol><hr><ol><li><p>可以通过采样看看在workload下那个函数被调用的频率更高？对高频函数采用o(1)的时间复杂 【个人感觉时recordaccess调用频率大于evict，在】</p></li><li><p>模仿xv6中buffer cache提升并发的优化思路，维护N个history_ 和 cache_，并通过page_id % N将page分散到不同的history中，减小锁的粒度</p></li><li><p>总感觉disk_scheduler下使用promise和future的异步io还有调整的空间，因为在recordaccess时可能会出现先evict dirty page刷脏，再读新page，future.get()是同步等待还是异步等待仍需要学习</p></li></ol><p>在实现lru-k时我选择使用两个list分别维护history_ (低于k次访问的frame) 和 cache_ （高于k次访问的frame）,并且在cache_中in backward k-distance order，这样在recordaccess的耗时自然是大于evict；</p><p><img src="/2024/02/01/bustub/image-20240201182611525.png" alt="image-20240201182611525"></p><p><img src="/2024/02/01/bustub/image-20240201175833584.png" alt="image-20240201175833584"></p><p><img src="/2024/02/01/bustub/image-20240201175916056.png" alt="image-20240201175916056"></p><p><img src="/2024/02/01/bustub/image-20240201175658755.png" alt="image-20240201175658755"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-Learning</title>
    <link href="/2024/01/06/MySQL-Learning/"/>
    <url>/2024/01/06/MySQL-Learning/</url>
    
    <content type="html"><![CDATA[<h2 id="存储引擎相关"><a href="#存储引擎相关" class="headerlink" title="存储引擎相关"></a>存储引擎相关</h2><h3 id="O-DIRECT-和-page-cache"><a href="#O-DIRECT-和-page-cache" class="headerlink" title="O_DIRECT 和 page cache"></a>O_DIRECT 和 page cache</h3><h3 id="Buffer-pool结构问题"><a href="#Buffer-pool结构问题" class="headerlink" title="Buffer pool结构问题"></a>Buffer pool结构问题</h3><h3 id="B-树的写放大问题"><a href="#B-树的写放大问题" class="headerlink" title="B+树的写放大问题"></a>B+树的写放大问题</h3><ul><li>什么是B+树的写放大？</li></ul><p>B+树都是向叶子结点进行插入，而叶子结点满后需要分裂出一个新页，假设插入一个128b的数据，但一个page是4k，那么这个过程中带来的放大就是4096 &#x2F; 128 &#x3D; 32倍</p><ul><li>如何解决这种写放大？</li></ul><ol><li><p>既然是因为一行数据带来的写放大，最简单的思路就是将多行数据都是写入，避免一次性分裂带来的高成本问题</p></li><li><p>内存缓存：增加内存缓存可以减少对磁盘的频繁访问。使用缓存可以将部分写操作暂时保存在内存中，然后定期将其刷写到磁盘，减少了写入磁盘的频率，降低了写放大。</p></li><li><p>Write-Ahead Logging (WAL)：使用WAL技术可以减少对磁盘的直接写入。在WAL中，首先将写操作追加到一个日志文件中，然后将数据写入内存。只有在某个时刻或条件下，才将日志中的操作应用到磁盘上的数据，这样可以降低直接磁盘写入的频率。</p></li><li><p>数据压缩：使用数据压缩算法可以减少要写入磁盘的数据量。如果能够在内存中对数据进行压缩，然后再写入磁盘，可以降低磁盘IO的成本。</p></li></ol><h3 id="B-树的并发控制"><a href="#B-树的并发控制" class="headerlink" title="B+树的并发控制"></a>B+树的并发控制</h3><h3 id="innodb中的日志"><a href="#innodb中的日志" class="headerlink" title="innodb中的日志"></a>innodb中的日志</h3><ul><li>undolog</li><li>redolog</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="MySQL中有哪些锁"><a href="#MySQL中有哪些锁" class="headerlink" title="MySQL中有哪些锁"></a>MySQL中有哪些锁</h3><h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><h3 id="write-ahead-log"><a href="#write-ahead-log" class="headerlink" title="write ahead log"></a>write ahead log</h3><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><h3 id="如何实现的MVCC"><a href="#如何实现的MVCC" class="headerlink" title="如何实现的MVCC"></a>如何实现的MVCC</h3><h3 id="online-ddl的实现"><a href="#online-ddl的实现" class="headerlink" title="online ddl的实现"></a>online ddl的实现</h3>]]></content>
    
    
    
    <tags>
      
      <tag>数据库内核</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024</title>
    <link href="/2024/01/05/2024/"/>
    <url>/2024/01/05/2024/</url>
    
    <content type="html"><![CDATA[<h1 id="2024规划"><a href="#2024规划" class="headerlink" title="2024规划"></a>2024规划</h1><h2 id="毕业"><a href="#毕业" class="headerlink" title="毕业"></a>毕业</h2><p>恍惚间研究生涯已经接近尾声，六个月后我也要告别学生身份转变为打工人。本人的主要研究方向是商业区块链，但浑浑噩噩的研究生生涯让我在科研领域毫无建树，哪怕是毕业设计方向是区块链，我仍然对于Defi和以太坊中的概念不是很熟悉。希望能借着做毕设的机会让我更完整的学习一下区块链以及web3</p><h2 id="coding"><a href="#coding" class="headerlink" title="coding"></a>coding</h2><p>自从互联网秋招结束后我已经有两三个月没有敲过代码了，虽然未来的工作更偏向管理以及设计，但我仍希望在未来能保持稳定的算法能力以及工程能力。算法能力可能还是会通过leetcode来维持，并且希望自己能在未来参加一些周赛或者算法竞赛，通过这些比赛保持自己的思维活跃度。除此之外，今年下半年工作后希望有空可以重新写一下国外的课程lab，并多参与 一些开源项目。这次不再是以填空和通过测试为目的，要着重看一下框架代码的搭建学习一下优质的设计思路（去学习一下迟先生新一年的MVCC）</p><h2 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h2><p>一直以来我都没有一个好的阅读习惯，总感觉自己对于论文和书籍的阅读都缺乏思考缺乏深度。学习同样的内容，我可能图一乐，但总能在知乎看到大佬们提出很有意思的问题，这让我感到我与大佬之间隔了一层厚厚的屏障。希望能在新的一年静下心来阅读，深入的思考。</p><p>除此之外，希望自己每天能阅读一篇技术博客或者技术文章，日积月累总没有坏处。正好最近在看45讲MySQL，争取在一月份看完并做好笔记！</p><ul><li>DDIA</li><li>System Design Interview</li><li>6.824和445中的论文</li><li>史铁生 我与地坛（寥寥几页就让我感受到史铁生细腻的情感和出色的文笔，必须要看完）</li><li>找机会看一些鲁迅先生的作品</li></ul><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>我没有写日记的习惯，大多数周记也是一时兴起，希望在未来一年能够做到稳定输出内容，以周为单位对工作、日常、学习做复盘，总结经验。周记并不是单纯的记流水账，还是需要加入一些思考，无论是业务还是知识，相当于对代码做review，找到不足或者用文字缕清思路。</p><h2 id="英文"><a href="#英文" class="headerlink" title="英文"></a>英文</h2><p>我的英文一直不是很好，口语勉强，听力高考水平，阅读理解更是稀烂。希望2024能保持英文阅读的习惯，提高理解能力。除此之外多听一些英文博客锻炼一下耳朵，英文听力水平对比高中真的下降了蛮多 &gt; &lt;</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>加油！</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>日记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>job</title>
    <link href="/2023/12/24/job/"/>
    <url>/2023/12/24/job/</url>
    
    <content type="html"><![CDATA[<h2 id="失败的秋招实录"><a href="#失败的秋招实录" class="headerlink" title="失败的秋招实录"></a>失败的秋招实录</h2><p>主要用于记录本人失败的秋招</p><h3 id="互联网公司"><a href="#互联网公司" class="headerlink" title="互联网公司"></a>互联网公司</h3><ul><li><p>微信支付（二面挂简单lc位操作没写出来！寄！）一面讨论了很多system design与raft的corner case结果直接被爆杀，还好面试官觉得我debug习惯很好给我过了一面 &gt; &lt;</p></li><li><p>百度（莫名其妙终面挂！寄！）一面实现的读写锁还是蛮有意思的，百度面试官很关注raft的优化方法并向我安利了braft。百度的优点是面试流程快，三面一共只用了四天，但池子大hc还不确定</p></li><li><p>快手（社科搜推架构 大sp）秋招为数不多关注数据库优化器的面试官，有意思的问题包括分布式join，基于index的ce，如何计算查询语句cost</p></li><li><p>字节（财务中台，二面寄！）二面是秋招唯一一场被问了纯八股的面试 （明明一面面试官说他们懒得考察这种八股 &gt; &lt;）中断的必要条件只知道关中断还有中断优先级；输入url到浏览器，只能回答个大概；字节确实很做题厂，两场面试都是十五分钟两道题，不过都是比较常见的mid或hard</p></li><li><p>美团（基础平台 搜推架构 大白菜）秋招面试体验最佳，算法题全是常见mid，不问八股只讨论项目，最重要的是一周多就能走完三面+hr面流程！</p></li><li><p>作业帮（不知道是sp还是白菜，也没关注是什么部门）一面体验极佳，聊了很多LSM-Tree优化方面的trade off，比如怎么更新vvalue? bitcask论文和leveldb设计上的区别</p></li><li><p>蔚来（sp？，同样没关注部门）周末上午一面下午二面，但offer拖到快十二月才给。全程八股+简单算法，面试官只会java，我是一点java不会hh</p></li><li><p>云和恩墨（薪资真的蛮高，似乎是基于gaussdb的产品）面试官是师姐，直接拷打…算了一个小时时间复杂度和空间复杂度，然后聊了一些优化器cbo的问题（innodb tidb的采样；cost model如何计算开销）</p></li><li><p>中小厂的面试，主要就是围绕项目和简单的cpp八股，没遇到过有意思的问题也没有推荐的中小公司。至于为什么没有阿里系的分享，因为我嫌阿里拆分后投递太麻烦就直接没投  &gt; &lt;</p><p>本人的互联网秋招极其失败，前期盲目自信 中期沉默不语 后期疯狂后悔。可惜的是wxg的两场面试表现都太差了，感觉面试官还是很想让我过的 &gt; &lt;</p><p>互联网公司面试重点还是项目和算法。算法只要能秒杀hot100和这些题的魔改版本基本就够了，项目一定要熟悉再熟悉，以最简单的mapreduce为例 要清楚mapreduce能做什么；要清楚824实现的版本存在什么问题，如何优化改进；工业mapreduce和玩具的区别（怎么实现shuffle？）</p></li></ul><h3 id="国企公司"><a href="#国企公司" class="headerlink" title="国企公司"></a>国企公司</h3><p>主要记录一些有趣的面试形式和公司</p><ul><li><p>联通某子公司（算上总裁聊天，一共面了五六次吧，各种人才计划。不过最后薪资总包40+，用白菜的base开出接近互联网sp的总包，实在不喜欢他们的薪资构成）四面时要求做个简单的ppt，没有限制内容。我根据张焕晨老师之前的演讲做了一个关于cloud-native的pre，假模假样的聊了一下snowflake架构，最后讨论了一些cloud-native的瓶颈与优化思路</p></li><li><p>交行金融储备 ：三面是个评估工作坊，给个五六十页的案例，根据案例中的身份完成一个商业报告，报告要介绍案例中的公司现状、困境和解决方案（限时一个小时左右，汇报时间严格卡在8分钟）很新奇的面试体验，囫囵吞枣的看了一下案例，除了必要的报告内容我还挑了个能和数字化转型相关的内容说了几句，最后又把重点强调金融科技复合型人才的重要性（doge）</p></li><li><p>农行软开：半结构化面试，面试官随机提问。先在a4纸上写个算法和sql，然后举着纸给面试官讲。我在面试时被cue了很多次，问我其他面试者的回答内容是否正确（真的是一身冷汗，如果没听其他人回答只能靠谈话技巧重新套一下问题了…）面试官问了不少数据库运维和测试的问题，还有怎么应对CPU打满的情况，分布式数据库的长事务，数据库宕机或者磁盘写不进去都有可能是什么问题</p></li><li><p>国寿：一面后要求先实习再答辩，再终面。实习过程主要做了一下规则引擎的选型，主要针对urule和drools。试着用async-prof火焰图分析一下两个java框架（时间紧测试思路还是有很多问题）国企的产品选型思路确实和互联网不太一样，其对于国产化或者信创产品的偏好dddd，选型产品时可以打电话咨询（白嫖）</p></li><li><p>其余国企都是大差不差的半结构化或者无领导讨论，没什么特别的</p></li></ul><p>大国企的面试官一般都是架构师或者高级工程师之类的，他们比较关注简历中项目或者实习里有实际应用的部分。以我为例，我会在面试前大概关注一下公司用的数据库产品，然后在面试时引导面试官往数据库产品上聊，最后无非就是tidb gaussdb和tdsql三款国产数据库了，做点准备能聊一下架构和落地使用就基本没问题了</p><p>秋招到后期我才逐渐感受到管培岗位的优势（算一下职业生涯总薪资的期望，再平衡一下工作强度），一开始希望在国企也能保持一点技术能力以应对市场变化，这导致求职意向主要是开发类。然而国企软开既是成本部门，又是偏向内包的存在，技术人员在国企的地位并不高。除此之外，普遍降薪的大趋势下国企的稳定性显得没什么意思（听说中行和邮储软开都降薪了，大厂一年薪资真够银行两三年的薪资），对比之下与其在国企熬工龄真不如去大厂搞业务（钱）或追求技术hh</p><h3 id="RocksDB-LSM-Tree"><a href="#RocksDB-LSM-Tree" class="headerlink" title="RocksDB&#x2F;LSM-Tree"></a>RocksDB&#x2F;LSM-Tree</h3><ol><li>说一下 Wisckey 中 <a href="https://www.zhihu.com/search?q=GC&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22659168257%22%7D">GC</a> 的方法，存在哪些问题</li><li>RocksDB 有哪些组件</li><li>如果要向 RocksDB 中写一亿条数据，怎么优化才能做到更快的写入？对于<a href="https://www.zhihu.com/search?q=%E5%8D%95%E6%9C%BA%E5%8D%95%E7%BA%BF%E7%A8%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22659168257%22%7D">单机单线程</a>、单机多线程、分布式场景下的写入又该怎么优化？如何对这一亿条数据做排序？</li><li>说一下 RocksDB 中的 [block cache](<a href="https://www.zhihu.com/search?q=block">https://www.zhihu.com/search?q=block</a> cache&amp;search_source&#x3D;Entity&amp;hybrid_search_source&#x3D;Entity&amp;hybrid_search_extra&#x3D;{“sourceType”%3A”article”%2C”sourceId”%3A”659168257”}) 的大小，说一下 block 大小，为什么是这个大小？block 和 block cache 的大小会怎么影响 RocksDB 的读写性能？</li><li>RocksDB 有哪些优化写的手段？</li><li>为啥现在SSD的随机读写和顺序读写性能差别不怎么样了，还要用你这个<a href="https://www.zhihu.com/search?q=lsm-tree&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22659168257%22%7D">lsm-tree</a>？</li><li>rocksdb 和 <a href="https://www.zhihu.com/search?q=leveldb&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22659168257%22%7D">leveldb</a> 有什么区别？</li><li>说一下compaction吧，比如有哪些类型等等的？</li><li>知道 <a href="https://www.zhihu.com/search?q=OceanBase&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22659168257%22%7D">OceanBase</a> 里怎么实现 LSM-Tree的吗？</li></ol><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><ol><li>说说多态？</li><li>怎么在编译期实现判断类里是否有某个成员？</li><li><a href="https://www.zhihu.com/search?q=stl&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22659168257%22%7D">stl</a>相关，map插入十个数字，<a href="https://www.zhihu.com/search?q=%E7%BA%A2%E9%BB%91%E6%A0%91&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22659168257%22%7D">红黑树</a>上数据怎么排布的？vector 怎么扩容的？stl里的map和<a href="https://www.zhihu.com/search?q=unordered_map&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22659168257%22%7D">unordered_map</a>的区别？他们插入的<a href="https://www.zhihu.com/search?q=%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22659168257%22%7D">时间复杂度</a>？</li><li>C++编译流程？<a href="https://www.zhihu.com/search?q=%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22659168257%22%7D">静态链接</a>和动态链接什么区别？什么时候用动态链接，什么时候用静态链接？</li><li>如何设计一个内存分配器，对于小的空间应该怎么去进行压缩回收？你知道<a href="https://www.zhihu.com/search?q=mutex&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22659168257%22%7D">mutex</a>是怎么实现的吗？你知道编译的时候O1、O2、O3是干啥的吗？</li></ol><h3 id="场景设计题"><a href="#场景设计题" class="headerlink" title="场景设计题"></a>场景设计题</h3><ol><li>假如有个程序中的某一部分占据了非常大的IO，应该怎么办？</li><li>现在的场景是应用有好几个线程，过程中有大量IO，有多块磁盘，希望尽可能把磁盘用满，你应该设计怎样的<a href="https://www.zhihu.com/search?q=%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22659168257%22%7D">线程模型</a>来做这件事情。</li><li>让你设计一个面向对象存储的rocksdb系统应该怎么做？尽可能的降本增效</li><li>假如说我现在有一个时序的场景，我需要大范围删除某个数据，应该怎么做？还是针对 RocksDB 的</li><li>因为我们的业务其实也有用rocksdb，但是我们更多的可能是用rocksdb作为一个append only log，这种应该怎么做？</li><li>怎样实现一个持久型<a href="https://www.zhihu.com/search?q=B+%E6%A0%91&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22659168257%22%7D">B+树</a>？假如你要保证这个<a href="https://www.zhihu.com/search?q=%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22659168257%22%7D">存储引擎</a>的故障恢复，只用[undo log](<a href="https://www.zhihu.com/search?q=undo">https://www.zhihu.com/search?q=undo</a> log&amp;search_source&#x3D;Entity&amp;hybrid_search_source&#x3D;Entity&amp;hybrid_search_extra&#x3D;{“sourceType”%3A”article”%2C”sourceId”%3A”659168257”})能做吗？</li><li>你怎么设计一个支持高并发更新删除写入的<a href="https://www.zhihu.com/search?q=%E5%86%85%E5%AD%98%E6%90%9C%E7%B4%A2%E6%A0%91&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22659168257%22%7D">内存搜索树</a>的结构？</li><li>你实现过支持高并发的<a href="https://www.zhihu.com/search?q=%E5%93%88%E5%B8%8C%E6%A1%B6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22659168257%22%7D">哈希桶</a>吗？</li></ol><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ol><li>Linux 下怎么执行一个可执行文件的？</li><li>系统调用过程？</li><li>用户态到<a href="https://www.zhihu.com/search?q=%E5%86%85%E6%A0%B8%E6%80%81&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22659168257%22%7D">内核态</a>怎么转换的？</li><li>说一下<a href="https://www.zhihu.com/search?q=%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22659168257%22%7D">虚拟内存</a>是干啥的？虚拟内存怎么转换的？假如我现在的这个地址没有在内存里会怎么样？</li><li>文件系统怎么查找一个文件？</li><li><a href="https://www.zhihu.com/search?q=shell&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22659168257%22%7D">shell</a> 怎么执行某一条命令的？</li><li>说一下中断的流程？</li><li>进程、线程、<a href="https://www.zhihu.com/search?q=%E5%8D%8F%E7%A8%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22659168257%22%7D">协程</a>？</li><li>fork 怎么实现的？</li><li>yield 和 <a href="https://www.zhihu.com/search?q=sleep&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22659168257%22%7D">sleep</a> 的区别？</li></ol><h3 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h3><ol><li>为什么 <a href="https://www.zhihu.com/search?q=DRAM&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22659168257%22%7D">DRAM</a> 的读比写快？</li><li>知道读内存，正常指令执行的时间吗？</li><li>说说 CPU 里面的相关和冲突？有什么解决冲突的办法？</li><li>知道CPU cache吗？一般cache有几级？具体都是什么cache？为什么要设计成这样的cache，多几级不行吗？CPU怎么保持cache一致性的？知道哪些内存模型？知道简单的原子指令怎么实现吗？</li><li>说一下你对<a href="https://www.zhihu.com/search?q=%E6%80%BB%E7%BA%BF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22659168257%22%7D">总线</a>的认识？</li></ol><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a><strong>数据库</strong></h3><ol><li>说一下 [B+ 树](<a href="https://www.zhihu.com/search?q=B+">https://www.zhihu.com/search?q=B%2B</a> 树&amp;search_source&#x3D;Entity&amp;hybrid_search_source&#x3D;Entity&amp;hybrid_search_extra&#x3D;{“sourceType”%3A”article”%2C”sourceId”%3A”659168257”})的特点。</li></ol><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><ol><li>说一下 Raft 中的 PreVote 优化是干啥的</li><li>你这里的 <a href="https://www.zhihu.com/search?q=multi-raft&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22659168257%22%7D">multi-raft</a> 中每个节点数据怎么分配的？</li><li>说说 raft 领导人选举的流程？</li><li>假设三个节点，一个 leader 两个 follower，leader 被网络分区了，会发生什么？</li><li>假设三个节点，一个 leader 两个 follower，其中一个 follower 和 leader 之间网络分区了，但是两个 follower 之间正常连接，会发生什么？</li></ol><h3 id="调试相关"><a href="#调试相关" class="headerlink" title="调试相关"></a>调试相关</h3><ol><li><a href="https://www.zhihu.com/search?q=gdb&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22659168257%22%7D">gdb</a> 用过吗？程序 crash 掉如何排查？<a href="https://www.zhihu.com/search?q=%E6%95%B0%E6%8D%AE%E6%96%AD%E7%82%B9&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22659168257%22%7D">数据断点</a>用过吗？如何排查不能稳定复现的 bug ？</li><li>你都是怎么调试的？比如segment fault怎么调试？怎么打印堆栈？gdb怎么就能做到让某个程序说停就停说走就走呢？你怎么去实现gdb里面的<a href="https://www.zhihu.com/search?q=backtrace&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22659168257%22%7D">backtrace</a>？</li><li>最难忘的调试经历？假如是有个<a href="https://www.zhihu.com/search?q=%E5%A4%9A%E7%BA%BF%E7%A8%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22659168257%22%7D">多线程</a>的程序，怎么调试？</li><li>对于一个O3优化，gdb调试的时候找不到<a href="https://www.zhihu.com/search?q=%E7%AC%A6%E5%8F%B7%E8%A1%A8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22659168257%22%7D">符号表</a>应该怎么做？</li></ol><h3 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h3><ol><li><a href="https://www.zhihu.com/search?q=socket&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22659168257%22%7D">socket</a> 怎么分配的？</li><li>TCP 和 <a href="https://www.zhihu.com/search?q=UDP&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22659168257%22%7D">UDP</a> 区别？一次发多少数据？TCP <a href="https://www.zhihu.com/search?q=%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22659168257%22%7D">拥塞控制</a>？TCP 粘包？</li></ol><h3 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h3><ol><li>内存文件系统</li><li><a href="https://www.zhihu.com/search?q=%E6%B3%A2%E6%B5%AA%E6%8E%92%E5%BA%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22659168257%22%7D">波浪排序</a></li><li>近似有序数组的查找</li><li>带<a href="https://www.zhihu.com/search?q=ttl&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22659168257%22%7D">ttl</a>的cache</li><li>二叉树的路经总和</li><li>有序链表转二叉平衡搜索树</li><li>二叉树非递归<a href="https://www.zhihu.com/search?q=%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22659168257%22%7D">后序遍历</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>秋招</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Alpha</title>
    <link href="/2023/12/11/Alpha/"/>
    <url>/2023/12/11/Alpha/</url>
    
    <content type="html"><![CDATA[<h1 id="DolphinDB高性能基础设施的构建和应用"><a href="#DolphinDB高性能基础设施的构建和应用" class="headerlink" title="DolphinDB高性能基础设施的构建和应用"></a>DolphinDB高性能基础设施的构建和应用</h1><h2 id="新的挑战"><a href="#新的挑战" class="headerlink" title="新的挑战"></a>新的挑战</h2><p><img src="/2023/12/11/Alpha/image-20231211145834360.png" alt="image-20231211145834360"></p><p>中高频：</p><p>机构交易所 1s一个快照</p><p>股票交易所 3s一个快照</p><p>现在高频  多因子（万级因子数）</p><h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><p><img src="/2023/12/11/Alpha/image-20231211150143306.png" alt="image-20231211150143306"></p><p>债券交易 使用excel </p><p><img src="/2023/12/11/Alpha/image-20231211150645352.png" alt="image-20231211150645352"></p><p><img src="/2023/12/11/Alpha/image-20231211150811580.png" alt="image-20231211150811580"></p><p><img src="/2023/12/11/Alpha/image-20231211151537213.png" alt="image-20231211151537213"></p><p><img src="/2023/12/11/Alpha/image-20231211151848599.png" alt="image-20231211151848599"></p><h2 id="MA移动平均线的使用"><a href="#MA移动平均线的使用" class="headerlink" title="MA移动平均线的使用"></a>MA移动平均线的使用</h2><p>MA N </p><ul><li>Moving Average 移动平均线，用过去N天的<strong>收盘价</strong>取平均得出当前值</li></ul><p>一般交易员需要采取三根线，以长周期技术指标来看，通常可以选取ma30 ma60 ma120的日线（币圈单月交易日为30天，因此长周期可以用月为单位）</p><p>若当前价格高于ma30，表示当前是多头趋势，ma30可以看作多头支持</p><p>均线的交叉</p><ul><li>短周期平均值高于长周期平均值，若是价格低点可以考虑是否为下跌回调</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>BlockChain</title>
    <link href="/2023/12/05/BlockChain/"/>
    <url>/2023/12/05/BlockChain/</url>
    
    <content type="html"><![CDATA[<h2 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h2><ul><li><p>去中心化</p><p>通过prehash实现，保证前一个节点的内容不会被轻易篡改（比特币大概三十分钟可以确认一个交易）</p><ul><li>如何篡改区块链？在本地生成一个更长的区块链去替代主链即可</li><li>只有数据的区块链是没有意义的，中心节点还是可以随意修改hash</li></ul><p>所有节点都是等价的</p></li><li><p>奖励机制</p><p>随着交易的累积，账本数据达到好几百G，没有必要让所有参与者都记录如此庞大的数据，但也要尽量鼓励能记账的人前来记账，否则会退化为中心画</p><p>通过奖励机制激励所有节点参与记账</p><ul><li><p>打包</p><p>区块链高度，十分钟内的交易。。。</p></li><li><p>所有人都可以打包吗？</p><p>通过调整Nonce修改hash值，使得hash值满足一定的条件（挖矿）</p></li></ul><p>每生产一个区块，奖励一些比特币；第一笔交易是矿工转给矿工的12.5BTC</p></li><li><p>共识机制</p><p>有可能出现分叉，当节点意识到自己落后之后，会切换到最长的链（比特币成功支付是指三个区块产生）</p></li></ul><h3 id="Markle-Tree"><a href="#Markle-Tree" class="headerlink" title="Markle Tree"></a>Markle Tree</h3><p>在比特币系统中，不同区块通过哈希值指针连接，在同一个区块中的多个交易（数据块），则通过Markle Tree的形式组织在一起。区块本身分为两部分（块头和块身），在块头中存在有根哈希值（没有交易的具体信息），块身中存在交易列表。</p><h3 id="UTXO"><a href="#UTXO" class="headerlink" title="UTXO"></a>UTXO</h3><ul><li>全节点在内存中维护UTXO防止双花问题</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>RulesEngine</title>
    <link href="/2023/11/20/RulesEngine/"/>
    <url>/2023/11/20/RulesEngine/</url>
    
    <content type="html"><![CDATA[<h1 id="某资管规则引擎调研以及实践"><a href="#某资管规则引擎调研以及实践" class="headerlink" title="某资管规则引擎调研以及实践"></a>某资管规则引擎调研以及实践</h1><h2 id="背景调查"><a href="#背景调查" class="headerlink" title="背景调查"></a>背景调查</h2><p>资管公司的主要业务： 债券 股票 基金 <strong>投资类业务</strong> 风控</p><p>金融、投资等领域都属于数据密集型，需要处理大量数据并根据数据进行复杂决策，且收到市场变化等情况，决策条件需频繁变动调整。以上工作基于传统人工处理的方法，效率低下且难以保证实效性。</p><p>因此高效、轻量化、可验证的规则引擎能优化产品设计和销售、对现有案例进行优化调整，使其更贴合场景、增加业务扩展性</p><h2 id="什么是规则引擎"><a href="#什么是规则引擎" class="headerlink" title="什么是规则引擎"></a>什么是规则引擎</h2><p>将用户的决策信息作为输入，并对输入进行规则化判断，并以判断结果作为输出</p><h3 id="RETE算法"><a href="#RETE算法" class="headerlink" title="RETE算法"></a><strong>RETE算法</strong></h3><p>Rete 算法最初是由卡内基梅隆大学的 Charles L.Forgy 博士在 1974 年发表的论文中所阐述的算法 , 该算法提供了专家系统的一个高效实现。自 Rete 算法提出以后 , 它就被用到一些大型的规则系统中 , 像 ILog、Jess、JBoss Rules 等都是基于 RETE 算法的规则引擎。</p><p>Rete 在拉丁语中译为”net”，即网络。Rete 匹配算法是一种进行大量模式集合和大量对象集合间比较的高效方法，通过网络筛选的方法找出所有匹配各个模式的对象和规则。</p><p>其核心思想是将分离的匹配项根据内容动态构造匹配树（其实是构造一个DAG,有向无环图），以达到显著降低计算量的效果。Rete 算法可以被分为两个部分：规则编译和规则执行 。当 Rete 算法进行事实的断言时，包含三个阶段：匹配、选择和执行，称做 match-select-act cycle。本质上是利用空间换换时间，会消耗较多内存</p><h2 id="传统开发模式与应用规则引擎开发模式的对比"><a href="#传统开发模式与应用规则引擎开发模式的对比" class="headerlink" title="传统开发模式与应用规则引擎开发模式的对比"></a>传统开发模式与应用规则引擎开发模式的对比</h2><p>传统：</p><ol><li>业务人员与项目经理沟通需求，项目经理与开发人员讨论需求 </li><li>概要设计 + 详细设计</li><li>编码</li><li>测试</li><li>部署发布</li></ol><p><strong>缺点：</strong></p><ul><li>初次开发，需要频繁沟通确定需求</li><li>二次开发或业务变更时，以上流程需要重新进行</li><li>整体周期时间长，成本较大</li><li>市场变化迅速，难以及时应对新场景</li></ul><h3 id="规则该如何执行"><a href="#规则该如何执行" class="headerlink" title="规则该如何执行"></a>规则该如何执行</h3><p>我们知道规则是做什么的了，也知道规则的原理和语法结构，但是规则该以何种形态在我们代码中执行呢？目前大致有三种模式：</p><p><strong>（1）直接解释执行</strong></p><p>这个模式相对好理解，在我们的系统中内嵌了一个对于规则语言的解释器，在规则脚本中描述规则逻辑，然后系统传参给解释器并调用对应的脚本，最常见的就是lua&#x2F;js 这种。</p><p><strong>（2）动态编译成我们的代码</strong></p><p>这部分可以直接将所使用的规则脚本编译成我们系统的代码或者一些中间码比如JVM 字节码，运行时动态加载，在运行时状态来看，和我们直接写在代码里几乎没有区别，并且性能要几乎无差。</p><p><strong>（3）自定义解释规则</strong></p><p>这一种方式是我们自己定义脚本规范，最经典的就是‘<a href="https://zhuanlan.zhihu.com/p/62519257">逆波兰表达式</a>’或者自定义Json条件结构，按照约定去编写规则，执行时解析规则然后完成数据匹配及计算得出结果。</p><blockquote><p>主流产品对比 <a href="https://www.zhihu.com/column/c_1675176833120350208">https://www.zhihu.com/column/c_1675176833120350208</a></p></blockquote><h3 id="产品定位"><a href="#产品定位" class="headerlink" title="产品定位"></a>产品定位</h3><p>产品使用人群： 后台开发人员、前台业务人员、普通用户 </p><ul><li>提炼规则库，构建类似中台的功能，配合流程引擎或辅助开发等（大中台，小前台，针对开发人员）</li><li>单独提供可视化操作界面，对用户提供合理的使用接口（针对前台人员）</li><li>单独测试以及验证策略效果</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>流程分支非常复杂，规则变量庞大；</li><li>有不确定性的需求，变更频率较高；</li><li>需要快速做出响应和决策；</li><li>规则变更期望脱离于开发人员，脱离coding；</li></ul><ol><li>在银行、保险、证券等金融机构中它可以用于自动风险评估、信用评分、反欺诈检测等金融决策和业务规则的执行。</li><li>在零售和电子商务行业它可用于定价、促销活动、库存管理、订单处理以及客户行为分析等关键业务流程的自动化。</li><li>在健康医疗领域它应用于临床决策支持系统、医疗保险资格认证、病例诊断等领域，帮助医生和医疗专业人员做出更准确和及时的决策。</li><li>在政府和公共服务领域，规则引擎也可用于许可证审批、社会救助资格审核、税收计算等方面。</li><li>在电信、能源、教育、交通运输等许多其他行业和领域。规则引擎的适用性越来越广泛，越来越重要，它提供了一种通用的方法来处理和执行复杂的业务规则和决策逻辑。</li></ol><h2 id="如何提高效率"><a href="#如何提高效率" class="headerlink" title="如何提高效率"></a>如何提高效率</h2><p>自动化决策和处理：数据规则引擎可以根据预先设定的规则，自动进行决策和处理。这样可以减少人工干预，降低人力成本，并提高工作效率。</p><p>快速、准确处理大量数据：数据规则引擎具备快速、准确地处理大量数据的能力。在企业管理中，往往需要处理大量的数据，数据规则引擎可以迅速地对这些数据进行处理和分析，提高数据处理效率。</p><p>灵活配置和调整规则：数据规则引擎可以根据不同的数据类型和处理需求，灵活地进行规则的配置和调整。企业可以根据自身业务需求，定制适合自身的规则，提高业务处理的效率。</p><p>策略管理和验证：数据规则引擎提供了策略管理和验证的功能，可以帮助企业进行策略的分析和验证，提高策略制定的效率。</p><h2 id="用规则引擎实现风控自动审批"><a href="#用规则引擎实现风控自动审批" class="headerlink" title="用规则引擎实现风控自动审批"></a>用规则引擎实现风控自动审批</h2><p>贷款预警 产品定价 客户评级 授信模型</p><h2 id="用规则引擎驱动交易策略"><a href="#用规则引擎驱动交易策略" class="headerlink" title="用规则引擎驱动交易策略"></a>用规则引擎驱动交易策略</h2><blockquote><p>用规则引擎驱动交易策略 <a href="https://holbrook.github.io/2013/12/19/trading_strategy.html">https://holbrook.github.io/2013/12/19/trading_strategy.html</a></p></blockquote><h2 id="产品对比"><a href="#产品对比" class="headerlink" title="产品对比"></a>产品对比</h2><p>有哪些常用的规则引擎<br>Java 开源的规则引擎有：Drools、Easy Rules、Mandarax、IBM ILOG。使用最为广泛并且开源的是 Drools。</p><p>通过类型对规则引擎进行简单分类，一般有以下3类：</p><p><strong>通过界面配置的成熟规则引</strong>擎：这种规则引擎相对来说就比较重，但是因为功能全，也有部分业务会选择这个，一般出名的有:Drools、IBM ILOG、URule</p><p><strong>基于JVM脚本语言</strong>：这种其实不是一个成熟的规则引擎，应该算是规则引擎中的核心技术，因为Drools这种相对太重了，很多互联网公司会基于一些jvm的脚本语言，开发一个轻量级的规则引擎，这里比较出名的有：Groovy、AviatorScript、qlexpress。</p><p><strong>基于java代码的规则引擎</strong>：上面是基于jvm脚本语言去做的，会有一些语法学习的成本，所以就有基于java代码去做的规则引擎，比如通过一些注解实现抽象的方式去做到规则的扩展，比较出名的有: EasyRules</p><blockquote><p>产品对比 <a href="https://blog.csdn.net/erik_tse/article/details/119323719">https://blog.csdn.net/erik_tse/article/details/119323719</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247523851&amp;idx=1&amp;sn=89c3047fe91a2d733eff76a958cf5204&amp;chksm=fcf741c6cb80c8d07ac6a15c09100c207e85fcd79a4f090d234cb9aebcb4c15d306098d64102&amp;token=626363235&amp;lang=zh_CN&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247523851&amp;idx=1&amp;sn=89c3047fe91a2d733eff76a958cf5204&amp;chksm=fcf741c6cb80c8d07ac6a15c09100c207e85fcd79a4f090d234cb9aebcb4c15d306098d64102&amp;token=626363235&amp;lang=zh_CN&amp;scene=21#wechat_redirect</a></p></blockquote><h3 id="Drools"><a href="#Drools" class="headerlink" title="Drools"></a>Drools</h3><p><strong>为实现规则动态刷新、页面可视化配置、规则动态加载等属性，</strong></p><p><strong>在oup中规则引擎以无状态服务为目标</strong></p><p>drools7.12以后就不支持tomcat的workbench了</p><p>Drools 就是一个开源的业务规则引擎</p><p>Drools 支持四种规则描述文件，分别是：drl 文件、 xls 文件、brl 文件和 dsl 文件，其中，常用的描述文件是 drl 文件和 xls 文件，而 xls 文件更易于维护，更直观，更为被业务人员所理解。</p><p>规则全量更新</p><p>无论是Drools还是JBPM，生命周期都包含以下部分：</p><ul><li>编写：编写规则文件，比如：DRL，BPMN2、决策表、实体类等。</li><li>构建：构建一个可以发布部署的组件，对于KIE来说是JAR文件。</li><li>测试：部署之前对规则进行测试。</li><li>部署：利用Maven仓库将jar部署到应用程序。</li><li>使用：程序加载jar文件，通过KieContainer对其进行解析创建KieSession。</li><li>执行：通过KieSession对象的API与Drools引擎进行交互，执行规则。</li><li>交互：用户通过命令行或者UI与引擎进行交互。</li><li>管理：管理KieSession或者KieContainer对象。</li></ul><h4 id="drools中的概念"><a href="#drools中的概念" class="headerlink" title="drools中的概念"></a>drools中的概念</h4><p><strong>KieServices</strong>：kie整体的入口,可以用来创建<a href="https://so.csdn.net/so/search?q=Container&spm=1001.2101.3001.7020">Container</a>,resource,fileSystem等</p><p><strong>KieContainer</strong>： KieContainer就是一个KieBase的容器，可以根据kmodule.xml 里描述的KieBase信息来获取具体的KieSession</p><p><strong>KieBase</strong>： KieBase就是一个知识仓库，包含了若干的规则、流程、方法等，在Drools中主要就是规则和方法，KieBase本身并不包含运行时的数据之类的，如果需要执行规则KieBase中的规则的话，就需要根据KieBase创建KieSession</p><p><strong>KieSession</strong>：KieSession就是一个跟Drools引擎打交道的会话，其基于KieBase创建，它会包含运行时数据，包含“事实 Fact”，并对运行时数据事实进行规则运算</p><p><strong>KieModule &#x3D;&#x3D; kmodule.xm</strong> l：是一个包含了多个kiebase定义的容器。一般用kmodule.xml来表示</p><p><strong>KieModuleModel</strong>：是kmodule.xml 文件的java表示，可以不用添加xml文件而是通过程序代码的方式来构建，</p><p><strong>KieFileSystem</strong>：一个完整的文件系统,包括资源和组织结构 </p><p><strong>KieBuilder</strong>：当把所有的规则文件添加到KieFileSystem中后，通过把KieFileSystem传递给一个KieBuilder，可以构建出这个虚拟文件系统。其中有个buildAll（）方法，会在构建好虚拟文件系统后，自动去构建KieModule</p><p><strong>KieRepository</strong>：是一个KieModule的仓库，包含了所有的KieModule描述，用一个ReleaseId做区分</p><p><strong>KieResources</strong>：是一个定义了如何获取资源的工厂，包括url，classpath，filesystem等</p><h4 id="动态管理规则"><a href="#动态管理规则" class="headerlink" title="动态管理规则"></a>动态管理规则</h4><p>动态构建KieContainer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == kieContainer) &#123;<br>  kieContainer = kieServices.newKieContainer(kieServices.getRepository().getDefaultReleaseId());<br>&#125;<br><span class="hljs-comment">// 更新</span><br>((KieContainerImpl) kieContainer).updateToKieModule((InternalKieModule) kieBuilder.getKieModule());<br></code></pre></td></tr></table></figure><p><img src="/2023/11/20/RulesEngine/image-20231123143503834.png" alt="image-20231123143503834"></p><p><img src="/2023/11/20/RulesEngine/image-20231127091741875.png" alt="image-20231127091741875"></p><p><img src="https://img2022.cnblogs.com/blog/2588456/202205/2588456-20220529221714816-987511982.jpg" alt="决策表案例解释"></p><h3 id="LiteFlow"><a href="#LiteFlow" class="headerlink" title="LiteFlow"></a>LiteFlow</h3><p>LiteFlow是一个开源编排式规则引擎，能够让你的系统逻辑任意编排，可选用脚本书写逻辑，支持多达5种脚本语言，支持丰富的第三方存储的支持，所有的逻辑和规则均可热变更。设计系统和重构系统的神器</p><h3 id="自研设计"><a href="#自研设计" class="headerlink" title="自研设计"></a>自研设计</h3><p><img src="/2023/11/20/RulesEngine/image-20231121234611114.png" alt="image-20231121234611114"></p><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p><img src="/2023/11/20/RulesEngine/image-20231123140058607.png" alt="image-20231123140058607"></p><p>dotask为访问 , 简单规则（两个drl文件，8个规则）反复执行500次，对其中采样20s性能分析报告如下</p><p>dotask基本占据cpu大部分消耗，核心瓶颈点在于两处</p><ul><li>access control</li><li>获取jar包的io <strong><code>KieFileSystem</code>：这个是一个虚拟的文件系统，不会真实在磁盘上创建文件，是基于内存的</strong>。</li></ul><p>Drools热刷新规则的方式现在看起来有点傻，它的规则是通过生成jar的方式。然后系统远程动态读取jar包来完成规则刷新的。</p><p><img src="/2023/11/20/RulesEngine/image-20231123133842640.png" alt="image-20231123133842640"></p><blockquote><p>规则引擎在保险公司的应用 <a href="https://zhuanlan.zhihu.com/p/614812161">https://zhuanlan.zhihu.com/p/614812161</a></p></blockquote><h2 id="竞对分析"><a href="#竞对分析" class="headerlink" title="竞对分析"></a>竞对分析</h2><p>LiteFlow在这个层面做的高级很多。如果你是用Nacos，Etcd，zookeeper等方式存储，不用做任何事，改变即自动刷新。如果你是SQL数据库存储，或者本地存储。在改变规则之后，需要调用LiteFlow框架提供的一个API进行热变更。2种方式均可热更新。并且在高并发情况下是平滑的。</p><blockquote><p>腾讯规则引擎实践分析 <a href="https://www.infoq.cn/article/3str0gtgyrhy7hpmkqm0">https://www.infoq.cn/article/3str0gtgyrhy7hpmkqm0</a></p></blockquote><p><img src="/2023/11/20/RulesEngine/image-20231127104051321.png" alt="image-20231127104051321"></p><h3 id="4-2-关于gengine性能"><a href="#4-2-关于gengine性能" class="headerlink" title="4.2 关于gengine性能"></a>4.2 关于gengine性能</h3><p>真实的线上 grpc 服务，单场景线上 10 个规则，10 个 4 核 8G 的 docker 容器，每个规则内都有外部网络请求，压测 15 分钟，平均 2 万 QPS, 平均响应耗时在 2ms 到 4ms，容器 cpu 使用率在 30%，负载在 20%- 30%，但也有极个别请求的耗时在 500ms 左右，但不超过 700ms；</p><p>配合实体机使用效果会更好，因为在高并发情况下，容器确实会有一些网络问题。我们在压测日志上</p><p>gengine 支持<strong>全量更新</strong>（改动一个规则，重新编译全部规则）的规则更新的方式。</p><p>但是，随着业务规则越来越多，比如单场景达到 10000 个规则的时候，如果用户仅需要改动一个规则，但还是使用全量更新的方式，会在规则编译阶段，对计算机 CPU 资源造成极大的浪费，因此，gengine 也支持<strong>增量更新</strong>（用户改动哪个规则就去编译哪个规则，没有改动的规则，则不进行处理）的方式去更新实例中的规则看到，规则执行速度都非常好，稳定在 2ms-4ms 以下，但请求返回外部之后，某些响应的耗时就变得糟糕。</p><h3 id="5-2-1-一个例子"><a href="#5-2-1-一个例子" class="headerlink" title="5.2.1 一个例子"></a>5.2.1 一个例子</h3><p>曾经，我所在的一个在某行业属独角兽的公司，做风控，以数据过规则的模式来实现风控防刷，使用 java 实现的 drools 规则引擎，规则中加载了一个随机森林模型，需要取十几个指标，这些指标还是从 redis 中取回来的，因为 drools 只支持顺序执行模式，加载的所有规则都以顺序模式执行，规则内的取指标也不例外。每次一到数据高峰(300-500QPS，其实这个根本算不上高 QPS 吧？！)的时候，数据就会发生严重堆积，最后经确认，就是这个加载了随机森林的规则，基于 uid 来取关联指标的时候，因为指标过多，耗时过长导致的。当他们只要把随机森林这个模型规则一停，堆积瞬间消除（狗头尴尬）。</p><h2 id="个人观点"><a href="#个人观点" class="headerlink" title="个人观点"></a>个人观点</h2><ul><li><p>结合ai技术，提供智能问答，并基于规则引擎得出结果，结合问答内容自动构建规则，实现动态规则引擎，智能核保</p></li><li><p>拆分构建单独引擎后，系统间通信成本变高；并且规则存储于数据库，可能存在io瓶颈或数据不一致等问题</p></li><li><p>规则库过大，但项目复用规则较少，则存在较高的存储成本</p></li><li><p>应结合场景，项目成本（有较多复用或相同的评定规则，且需要灵活配置规则的场景）</p></li><li><p>瀑布开发流程 阶段开发</p></li></ul><p>不同的应用场景</p><p>打标签 if in cpu io 股票浮亏 指标判断 阈值管理（亏20和赢20的执行）</p><p>风控</p><h1 id="ruleEngine"><a href="#ruleEngine" class="headerlink" title="ruleEngine"></a>ruleEngine</h1><p>业务规则、配置化编程、政策引擎、规则引擎</p><p>最终实现看这个项目 <a href="https://github.com/failgoddess/rule">https://github.com/failgoddess/rule</a></p><h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h1><p>在项目步入成熟期，规则类需求几乎占据了业务所有需求的半边天。一方面规则唯一不变的是“多变”，另一方面开发团队对“规则开发”的感受是乏味、疲惫和缺乏技术含量。如何解决规则开发的效率问题，最大化解放开发团队成为一个新的挑战。</p><p>规则底层采用规则引擎来实现。规则引擎是一种嵌入在应用程序中的组件，实现了将业务规则从应用程序代码中分离出来，并使用预定义的规则语义来编写业务规则。规则引擎接受数据输入，解释业务规则，并根据规则执行相应的业务逻辑。一个业务规则包含一组条件和在此条件下执行的操作，它们表示业务规则应用程序的一段业务逻辑。我们在业务中设置一个或者多个条件，当满足这些条件时触发相应的操作，规则引擎设计的初衷是可以将复杂多变的规则从硬编码中解放出来，以规则脚本的形式存放在文件或者数据库中，使得规则的变更不需要修改代码即可使用，做到最大程度的灵活。</p><h1 id="2-方案考察"><a href="#2-方案考察" class="headerlink" title="2. 方案考察"></a>2. 方案考察</h1><p>现在市面上在做业务规则的过程中有多种实现方案：</p><h2 id="2-1-硬编码："><a href="#2-1-硬编码：" class="headerlink" title="2.1. 硬编码："></a>2.1. 硬编码：</h2><p>优点：</p><p>稳定性较佳：语法级别错误不会出现，由编译系统保证。</p><p>当规则较少、变动不频繁时，开发效率最高。</p><p>缺点：</p><p>规则迭代成本高：对规则的少量改动就需要走全流程（开发、测试、部署）。</p><p>规则开发和维护门槛高：规则对业务分析人员不可见。业务分析人员有规则变更需求后无法自助完成开发，需要由开发人员介入开发。</p><h2 id="2-2-Drools："><a href="#2-2-Drools：" class="headerlink" title="2.2. Drools："></a>2.2. Drools：</h2><p>优点：</p><p>策略规则和执行逻辑解耦方便维护。</p><p>缺点：</p><p>业务分析师无法独立完成规则配置：由于规则主体DSL是编程语言（支持Java, Groovy, Python），因此仍然需要开发工程师维护。</p><p>规则的语法仅适合扁平的规则，对于嵌套条件语义（then里嵌套when…then子句）的规则只能将条件进行笛卡尔积组合以后进行配置，不利于维护。</p><h2 id="2-3-Urule："><a href="#2-3-Urule：" class="headerlink" title="2.3. Urule："></a>2.3. Urule：</h2><p>优点：</p><p>可视化操作完善、功能强大</p><p>缺点：</p><p>不支持回溯：当前分支没有符合条件的之后不支持回溯</p><p>不支持动态加载数据：例如门店有等级、店龄、区域等若干属性，业务规则具体是根据店龄不同给出结果还是根据等级，属于规则的业务范畴，调用方并不关心。要是每次需要将所有可能用于规则判断的数据全部由调用方传入，无疑降低了规则的灵活性。</p><h2 id="2-4-自研规则引擎"><a href="#2-4-自研规则引擎" class="headerlink" title="2.4. 自研规则引擎"></a>2.4. 自研规则引擎</h2><p>在学习机器学习中决策树的算法时可以生成决策树的决策流图。决策树整体分为两个阶段：通过算法计算找出规律将规律构建决策模型、传入新数据基于决策流进行新的决策分析。这一点给我带来了很大的思想启发，配置规则的过程作为决策树的构建阶段，新数据决策为决策树的预测过程。出现多个决策路径组合的为最终结果的场景也可以理解决策森林算法的演化。</p><h1 id="3-能力要求"><a href="#3-能力要求" class="headerlink" title="3. 能力要求"></a>3. 能力要求</h1><p>规则引擎的设计主要分为两部分：一部分是规则的维护，包括规则的创建、修改、删除；一部分是规则的执行。规则的维护部分侧重点是页面，我们需要将用户在页面上的操作转换为内置规则并保存到数据库中。在规则执行的过程中调用方只需要选择规则传入相应的数据即可获得决策结果。结合整体需求，规则引擎应该有可扩展、易维护的特点，先将规则引擎的功能需要实现的功能点总结如下：</p><p>指标部分（维护指标、计算执行指标）</p><p>模型维护（模型即实体，包括模型的创建以及模型属性的维护）</p><p>规则维护（包括对规则的增删改查）</p><p>条件维护（对规则条件的增删改查）</p><p>指标维护（对规则指标的增删改查）</p><p>结果维护（对规则结果的增删改查）</p><p>节点维护（包括静态节点和动态节点部分）</p><p>基于规则版本的决策记录（基于历史规则查看判定过程记录）</p><p>规则的版本控制</p><p>根据技术考察和能力要求对我们的规则引擎提出了更为全面的要求：</p><p>l 支持可视化的界面配置</p><p>l 支持嵌套条件语义</p><p>l 支持组合条件</p><p>l 支持动态加载</p><p>l 支持决策日志</p><p>l 支持规则历史版本</p><p>l 支持回溯</p><p>l 支持决策森林</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>6.824Lab2</title>
    <link href="/2023/11/13/6-824Lab2/"/>
    <url>/2023/11/13/6-824Lab2/</url>
    
    <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="日志函数"><a href="#日志函数" class="headerlink" title="日志函数"></a>日志函数</h3><p>测试命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go <span class="hljs-built_in">test</span> -race</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">go <span class="hljs-built_in">test</span> -race -run 2A</span> <br><span class="hljs-meta prompt_">$ </span><span class="language-bash">go <span class="hljs-built_in">test</span> -race -run 2B</span> <br><span class="hljs-meta prompt_">$ </span><span class="language-bash">go <span class="hljs-built_in">test</span> -race -run 2C</span> <br><span class="hljs-meta prompt_">$ </span><span class="language-bash">go <span class="hljs-built_in">test</span> -race -run 2D</span> <br></code></pre></td></tr></table></figure><p>debug格式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">Debug(dTimer, <span class="hljs-string">&quot;S%d Leader, checking heartbeats&quot;</span>, rf.me)<br></code></pre></td></tr></table></figure><p>如何格式化debug</p><figure class="highlight shell"><figcaption><span>l</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">You can just pipe the go <span class="hljs-built_in">test</span> output into the script</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">VERBOSE=1 go <span class="hljs-built_in">test</span> -run InitialElection | python log.py</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">... colored output will be printed</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">We can ignore verbose topics like timers or <span class="hljs-built_in">log</span> changes</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">VERBOSE=1 go <span class="hljs-built_in">test</span> -run Backup | python log.py -c 5 -i TIMR,DROP,LOG2</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">... colored output <span class="hljs-keyword">in</span> 5 columns</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Dumping output to a file can be handy to iteratively</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">filter topics and when failures are hard to reproduce</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">VERBOSE=1 go <span class="hljs-built_in">test</span> -run Figure8Unreliable &gt; output.log</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Print from a file, selecting just two topics</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">python dslogs output.log -j CMIT,PERS</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">... colored output</span><br></code></pre></td></tr></table></figure><h2 id="lab-2b"><a href="#lab-2b" class="headerlink" title="lab 2b"></a>lab 2b</h2><p>逻辑上默认Term从1开始计算，Index也从1开始</p><p>所以nextindex[i]初始化为len(rf.log) + 1</p><p>根据index找到对应的日志</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> index &gt; <span class="hljs-number">1</span>&#123;<br>entry =rf.log[index - <span class="hljs-number">1</span>]  <br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> index == <span class="hljs-number">0</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>完成start函数，这个函数负责接收外部命令，但并不保证command被应用或提交</p><p>start函数在收到command后需要将这个封装为entry添加到本地</p><p>通过心跳把这个这个entry发送出去</p></li><li><p>sendHeartbeat函数</p><p>将对应server需要的日志加入appendEntriesRPC中 </p><p><strong>len(rf.log)代表 节点最后一个日志的index</strong></p><ul><li><p>如果nextindex[i] &gt; len(rf.log) 不需要加入日志</p></li><li><p>如果nextindex[i] &lt;&#x3D; len(rf.log) 则将[nextindex[i], len(rf.log)]</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> index := nextIndex[i]; index &lt;= <span class="hljs-built_in">len</span>(rf.log) ; index++ &#123;<br>  args.entry = <span class="hljs-built_in">append</span>(args.entry, rf.getlog(index))<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>RequestVoteRPC函数</p><p>需要判断candidate是否拥有当前集群最新的日志</p><ul><li>首先比较 args.Term 和 rf.currentTerm， args大，则直接投票</li><li>若相等，则看 args.LastlogTerm 和 rf.log[len(rf.log) - 1].Term 还有index的值</li></ul></li><li></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Database</title>
    <link href="/2023/11/01/Database/"/>
    <url>/2023/11/01/Database/</url>
    
    <content type="html"><![CDATA[<h2 id="分布式数据库架构"><a href="#分布式数据库架构" class="headerlink" title="分布式数据库架构"></a>分布式数据库架构</h2><p><img src="/2023/11/01/Database/image-20231120000818788.png" alt="image-20231120000818788"></p><ul><li><strong>Shared Disk</strong></li></ul><p>多个数据库实例，每个实例有自己的内存，但是通过网络共享同一个disk。Shared Disk架构在<a href="https://www.zhihu.com/search?q=%E4%BA%91%E5%8E%9F%E7%94%9F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2517108061%7D">云原生</a>比较常见，这样的好处就是利于存算分离，计算层和存储层能够解耦，因此计算层和存储层在扩缩容的时候彼此不影响。</p><p>缺点是因为共享disk，因此对于<a href="https://www.zhihu.com/search?q=%E9%AB%98%E5%B9%B6%E5%8F%91&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2517108061%7D">高并发</a>的写请求势必性能会比较差，因此这种架构比较适合OLAP这种读多写少的数仓。</p><ul><li><strong>Shared Nothing</strong></li></ul><p>各个数据库实例，都有自己的内存和disk，这些实例之间只能通过网络通信来感知各个实例的状态变化。通常表会水平划分到各个节点，每个节点只负责其本地磁盘上的数据行。 这种设计非常适合<a href="https://www.zhihu.com/search?q=%E6%98%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2517108061%7D">星型模式</a>查询，因为连接维度比较小的维度表和宽的事实表所需的带宽非常少。</p><p>Share Nothing架构的优点在于性能和效率比较高，缺点在于灵活性较差，因为扩缩容的时候，需要在节点之间移动数据。而且对于事物的支持性较差，因为各个节点之间必须通过网络进行协调。存在单机存储瓶颈</p><ul><li>Storage Disaggregation（存储计算分离架构）</li></ul><p>存储和Shared Storage类似，有一个分布式的共享存储集群，计算层处理数据的模式和Shared Nothing类似，数据是分片的，每个Shard只处理自己所在分片的数据，每个计算节点还可以有本地缓存。</p><p>存储计算分离的架构存在以下优势。</p><ul><li>一致性问题处理简单：计算层只需要保证同一时刻有一个计算节点写入同一分片的数据。</li><li>扩展更灵活：计算和存储可以分开扩展，计算不够扩计算节点，存储不够扩存储节点。这样在大促等场景上会非常灵活。计算资源不够了，马上扩容计算就好了，不需要像Shared Nothing那样做耗时耗力的数据Rebalance；也不会像Shared Nothing那样，出现单机的存储容量瓶颈。</li><li>计算节点故障恢复快：计算节点发生Failover之后，数据可以按需从分布式的共享存储异步拉取。因此Failover的速度非常快。</li></ul><blockquote><p>polordb 存储计算分离介绍 <a href="https://docs.polardbpg.com/1653230754878/PolarDB-for-PostgreSQL/Storage-Compute-Decoupled-Arch.html">https://docs.polardbpg.com/1653230754878/PolarDB-for-PostgreSQL/Storage-Compute-Decoupled-Arch.html</a></p><p>Hologres产品架构 <a href="https://help.aliyun.com/zh/hologres/product-overview/architecture">https://help.aliyun.com/zh/hologres/product-overview/architecture</a></p></blockquote><h2 id="分布式join"><a href="#分布式join" class="headerlink" title="分布式join"></a>分布式join</h2><p><img src="/2023/11/01/Database/image-20231101152907378.png" alt="image-20231101152907378"></p><blockquote><p>分布式join <a href="https://www.cnblogs.com/xueqiuqiu/articles/13716454.html">https://www.cnblogs.com/xueqiuqiu/articles/13716454.html</a></p></blockquote><h2 id="分布式数据库事务"><a href="#分布式数据库事务" class="headerlink" title="分布式数据库事务"></a>分布式数据库事务</h2><h4 id="Percolator过程："><a href="#Percolator过程：" class="headerlink" title="Percolator过程："></a>Percolator过程：</h4><p>1. </p><p><img src="/2023/11/01/Database/image-20231101180440726.png" alt="image-20231101180440726"></p><p><img src="/2023/11/01/Database/image-20231101180619575.png" alt="image-20231101180619575"></p><ul><li><p>为什么primary锁可以直接清除？</p></li><li><p>如果有别的事务还没写完secondary锁的信息，这样会不会造成事务的不完整？</p></li></ul><p>因为primary锁和secondary不是同时写入，可能会存在primary锁写入成功，secondary锁写入失败的情况（比如已经被其他事务写入锁了）</p><p>不会，因为有token注册机制，没写入secondary锁的事务应该是活跃事务会被注册进token中，新事务来写锁时会检查token发现是活跃事务进而等待该事务的完成。</p><ul><li>为什么在get的阶段清理锁，如果proxy宕机，锁还被清理了，会不会导致事务的错误？</li></ul><h2 id="Cleanup-lock"><a href="#Cleanup-lock" class="headerlink" title="Cleanup lock"></a>Cleanup lock</h2><p>Cleanup 操作是在事务执行阶段进行的，开启start_ts后，首先检查要写入的行上是否有锁</p><ul><li><p>如果是primary lock:  代表老的事务还未提交，已经超时，直接清理</p></li><li><p>如果是secondary lock: 检查对应primary锁的状态。如果没有primary锁，老事务已经提交，需要等待secondary锁释放；如果还有primary锁，老事务未提交，直接清理</p></li></ul><p><strong>这个机制会造成大量已经prepare的事务的回滚，所以注册token</strong></p><ol><li>主锁已经commit: commit该次锁</li><li>主锁未commit &amp;&amp; 已超时: 如果次锁也超时则清理次锁，否则不做任何操作</li><li>主锁未commit &amp;&amp; 未超时: 不做任何操作</li></ol><p><img src="/2023/11/01/Database/image-20231109105310517.png" alt="image-20231109105310517"></p><h4 id="实践中存在的问题"><a href="#实践中存在的问题" class="headerlink" title="实践中存在的问题"></a>实践中存在的问题</h4><ol><li>每个事务都会有四次RTT（两次 getTimeStamp）</li></ol><ul><li>从 PD 获取 2 次 Timestamp；</li><li>提交时的 Prewrite 和 Commit</li></ul><p>小事务需要频繁RPC，消耗太高，因此要将小事务batch（TiDB性能不行的原因？）</p><p>大事务容易出现OOM或者耗时太长提交失败(容易被清理锁？)，因此事务尽量小于500条sql语句</p><ul><li>乐观事务模型中，在高冲突率的场景，事务很容易提交失败。TiDB 乐观事务提供了重试机制，但tidb默认不重试事务，重试时将重新获取start_ts，必将导致无法保证可重复读。为解决高冲突场景重试的问题，在tidb v3.0之后的版本中，实现了悲观事务，并从v3.0.8 开始，新创建的 TiDB 集群默认使用悲观事务模型。</li></ul><blockquote><p>Percolator 事务模型解析 <a href="https://www.cnblogs.com/FateTHarlaown/p/12084983.html">https://www.cnblogs.com/FateTHarlaown/p/12084983.html</a></p><p>TIDB分布式事务算法 <a href="https://blog.csdn.net/qq_22351805/article/details/114987229">https://blog.csdn.net/qq_22351805/article/details/114987229</a></p></blockquote><h2 id="分布式数据库-银行业"><a href="#分布式数据库-银行业" class="headerlink" title="分布式数据库 银行业"></a>分布式数据库 银行业</h2><h3 id="选型"><a href="#选型" class="headerlink" title="选型"></a>选型</h3><p><strong>什么指标决定了需要分库分表或者选用分布式数据库？</strong></p><p>TPS or 数据量？</p><ol><li><p>一致性 账务不能错，数据不能丢</p></li><li><p>高可用 </p><p>系统不能停，应用可逃生</p><p>主要验证 RTO 和 RPO</p><ul><li>多中心切换：<ul><li>整体切换（中心整体切换）</li><li>中心间网路故障（网络抖动，网络中断、网络阻塞）</li></ul></li><li>内中心切换<ul><li>计算资源故障（服务器故障）</li><li>存储资源故障（磁盘异常）</li><li>网络资源故障</li><li>软件故障<ul><li>NTP时间异常</li><li>进程异常（进程崩溃、进程挂起）</li><li>文件异常（权限、误删除、文件系统慢）</li></ul></li></ul></li></ul></li><li><p>高性能 联机不能慢，批量不能晚</p></li><li><p>可扩展 线性扩容能力</p></li><li><p>生态</p></li><li><p>易于维护</p></li></ol><p><img src="/2023/11/01/Database/image-20231102232939962.png" alt="image-20231102232939962"></p><p><img src="/2023/11/01/Database/image-20231102233119421.png" alt="image-20231102233119421"></p><h3 id="region分裂"><a href="#region分裂" class="headerlink" title="region分裂"></a>region分裂</h3><ol><li>什么时候split region？</li></ol><p>tidb的split up是在region大小达到128MB或者region中有1w行数据时分裂</p><h3 id="统计信息的维护："><a href="#统计信息的维护：" class="headerlink" title="统计信息的维护："></a>统计信息的维护：</h3><ol><li>取消了count-min sketch（q-error太大，对于低频的数据估算误差太大）<ul><li>代码中是FMSketch（使用末尾0来识别数据，并用2的最高频率次幂作为频率估计）</li></ul></li><li>增加了top-n，以提高点查询的准确率（取前1000的top N，且直方图中不包含这些top N）</li></ol><h3 id="统计信息的收集"><a href="#统计信息的收集" class="headerlink" title="统计信息的收集"></a>统计信息的收集</h3><p> TiDB 中，会对每个表具体的列构建一个等深直方图，区间查询的估算便是借助该直方图来进行。</p><ol><li>抽样方法的调整，从蓄水池转化为伯努利抽样</li><li>全表更新，mysql是部分页面的抽样（也可以开启快速分析，使得抽样范围缩小到1w条记录）</li><li>索引列的统计数据可以做增量更新</li></ol><h3 id="更新周期以及条件"><a href="#更新周期以及条件" class="headerlink" title="更新周期以及条件"></a>更新周期以及条件</h3><ol><li><p>在发生增加，删除以及修改语句时，TiDB 会自动更新表的总行数以及修改的行数。这些信息会定期持久化下来，更新的周期为 20 * stats-lease 。stats-lease 配置项的默认值是 3s，</p></li><li><p>当某个表 tbl 的修改行数与总行数的比值大于 tidb_auto_analyze_ratio，并且当前时间在 tidb_auto_analyze_start_time 和 tidb_auto_analyze_end_time 之间时，TiDB 会在后台执行 ANALYZE TABLE tbl 语句自动更新这个表的统计信息。</p></li></ol><h2 id="数据库存储"><a href="#数据库存储" class="headerlink" title="数据库存储"></a>数据库存储</h2><h3 id="如何存储数据"><a href="#如何存储数据" class="headerlink" title="如何存储数据"></a>如何存储数据</h3><h3 id="存储介质"><a href="#存储介质" class="headerlink" title="存储介质"></a>存储介质</h3><h3 id="如何查找数据"><a href="#如何查找数据" class="headerlink" title="如何查找数据"></a>如何查找数据</h3><h3 id="如何提高数据访问效率"><a href="#如何提高数据访问效率" class="headerlink" title="如何提高数据访问效率"></a>如何提高数据访问效率</h3><h3 id="如何保证数据不丢失"><a href="#如何保证数据不丢失" class="headerlink" title="如何保证数据不丢失"></a>如何保证数据不丢失</h3><h3 id="如何管理缓冲区"><a href="#如何管理缓冲区" class="headerlink" title="如何管理缓冲区"></a>如何管理缓冲区</h3><h3 id="数据的管理单位"><a href="#数据的管理单位" class="headerlink" title="数据的管理单位"></a>数据的管理单位</h3><h3 id="行存or列存"><a href="#行存or列存" class="headerlink" title="行存or列存"></a>行存or列存</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Software  Engineering</title>
    <link href="/2023/10/28/Software-Engineering/"/>
    <url>/2023/10/28/Software-Engineering/</url>
    
    <content type="html"><![CDATA[<h1 id="灰度发布"><a href="#灰度发布" class="headerlink" title="灰度发布"></a>灰度发布</h1><ol><li>按流量阶段性发布</li><li>按照用户业务属性发布</li></ol><blockquote><p>灰度发布 滚动发布 <a href="https://testerhome.com/topics/15746">https://testerhome.com/topics/15746</a></p></blockquote><h3 id="金融业务痛点"><a href="#金融业务痛点" class="headerlink" title="金融业务痛点"></a>金融业务痛点</h3><ol><li>实时金融业务，转账</li><li>定时批处理操作，对账、发工资</li><li>热点数据感知，冷热数据分离</li><li>无感知升级</li></ol><p>北京银行：医保代发</p><h3 id="金融应用场景："><a href="#金融应用场景：" class="headerlink" title="金融应用场景："></a>金融应用场景：</h3><ol><li>支付清算 快捷支付</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Financial Engineering</title>
    <link href="/2023/09/16/Financial-Engineering/"/>
    <url>/2023/09/16/Financial-Engineering/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是金融工程？"><a href="#什么是金融工程？" class="headerlink" title="什么是金融工程？"></a>什么是金融工程？</h1><ul><li><p>衍生品derivatives</p><p>是指价值依赖于其标的资产（underlying assets）的金融工具</p><p>为一种特殊类别买卖的<a href="https://zh.wikipedia.org/wiki/%E9%87%91%E8%9E%8D%E5%95%86%E5%93%81">金融商品</a>统称，主要有<a href="https://zh.wikipedia.org/wiki/%E6%9C%9F%E8%B4%A7">期货</a>、<a href="https://zh.wikipedia.org/wiki/%E9%81%B8%E6%93%87%E6%AC%8A">期权</a>、<a href="https://zh.wikipedia.org/wiki/%E9%81%A0%E6%9C%9F%E5%A5%91%E7%B4%84">远期合约</a>、<a href="https://zh.wikipedia.org/wiki/%E4%BA%A4%E6%8F%9B%E4%BA%A4%E6%98%93">掉期交易</a>及<a href="https://zh.wikipedia.org/wiki/%E5%B7%AE%E5%83%B9%E5%90%88%E7%B4%84">差价合约</a>、<a href="https://zh.wikipedia.org/wiki/%E8%99%9B%E6%93%AC%E8%B2%A8%E5%B9%A3">虚拟货币</a>等。</p></li></ul><p>此种交易的<a href="https://zh.wikipedia.org/wiki/%E6%8A%95%E8%B3%87%E5%A0%B1%E9%85%AC%E7%8E%87">投资回报率</a>是根据其他<a href="https://zh.wikipedia.org/wiki/%E9%87%91%E8%9E%8D">金融</a>标的的表现所衍生出来。如<a href="https://zh.wikipedia.org/wiki/%E8%B5%84%E4%BA%A7">资产</a>（<a href="https://zh.wikipedia.org/wiki/%E5%A4%A7%E5%AE%97%E7%89%A9%E8%B3%87">大宗商品</a>、<a href="https://zh.wikipedia.org/wiki/%E8%82%A1%E7%A5%A8">股票</a>或<a href="https://zh.wikipedia.org/wiki/%E5%80%BA%E5%88%B8">债券</a>）、<a href="https://zh.wikipedia.org/wiki/%E5%88%A9%E7%8E%87">利率</a>、<a href="https://zh.wikipedia.org/wiki/%E6%B1%87%E7%8E%87">汇率</a>、指数（<a href="https://zh.wikipedia.org/wiki/%E8%82%A1%E7%A5%A8%E6%8C%87%E6%95%B0">股票指数</a>、<a href="https://zh.wikipedia.org/wiki/%E6%B6%88%E8%B2%BB%E8%80%85%E7%89%A9%E5%83%B9%E6%8C%87%E6%95%B8">居民消费价格指数</a>以及天气指数）、<a href="https://zh.wikipedia.org/wiki/%E8%99%9B%E6%93%AC%E8%B2%A8%E5%B9%A3">虚拟货币</a>等，这些标的的表现将会决定一个衍生工具的回报率及回报时间。金融衍生工具大多可在<a href="https://zh.wikipedia.org/wiki/%E4%BA%A4%E6%98%93%E6%89%80">交易所</a>或<a href="https://zh.wikipedia.org/wiki/%E6%9F%9C%E5%8F%B0%E4%B9%B0%E5%8D%96">柜台买卖</a>交易。</p><p>对此类金融工具进行买卖投资者需要十分谨慎，因为由其引起的损失有可能大于投资者最初投放于其中的资金。同时由于其本身并不代表任何资产，其买卖也不应该被视作投资。</p><p>债券是利率的衍生品</p><p>股票是公司资产价值的衍生品</p><ul><li>远期产品：锁定价格（四大问题 信用风险）</li><li>期货：</li></ul><p><img src="/2023/09/16/Financial-Engineering/image-20230916223226210.png" alt="image-20230916223226210"></p><p>金融工程是资源分配，风险配置</p><p>风险管理可以创造价值</p><p><img src="/2023/09/16/Financial-Engineering/image-20230916225855621.png" alt="image-20230916225855621"></p><p>盈亏和回报</p><p>套利利率决定期货价格</p><p><img src="/2023/09/16/Financial-Engineering/image-20230917120321059.png" alt="image-20230917120321059"></p><p>金融工程的三大主要内容：</p><ol><li>设计</li><li>定价</li><li>风险管理</li></ol><p>主要工具：</p><ol><li>基础证券和衍生品</li></ol><p>组合与拆分</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Optimizer</title>
    <link href="/2023/08/25/Optimizer/"/>
    <url>/2023/08/25/Optimizer/</url>
    
    <content type="html"><![CDATA[<h1 id="Optimizer"><a href="#Optimizer" class="headerlink" title="Optimizer"></a>Optimizer</h1><h2 id="B-plus-tree-based"><a href="#B-plus-tree-based" class="headerlink" title="B plus tree based"></a>B plus tree based</h2><h2 id="LSM-based"><a href="#LSM-based" class="headerlink" title="LSM based"></a>LSM based</h2><h2 id="分布式join"><a href="#分布式join" class="headerlink" title="分布式join"></a>分布式join</h2><p>通常，分布式JOIN实现机制无非如下几种：</p><ul><li>Broadcast JOIN</li><li>Shuffle Join</li><li>Colocate JOIN</li></ul><p>分布式事务：</p><p>消息队列 RocketMQ</p><p>异步解耦多个服务或操作</p><p>缺点：</p><ol><li>下游失败后无法会退</li><li>上游操作很难保障原子性 </li><li>事务消息重点解决的问题（事务执行成功如何确保本地事务执行和投递消息的原子性）</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LRU</title>
    <link href="/2023/08/25/LRU/"/>
    <url>/2023/08/25/LRU/</url>
    
    <content type="html"><![CDATA[<h1 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h1><h2 id="什么是LRU？"><a href="#什么是LRU？" class="headerlink" title="什么是LRU？"></a>什么是LRU？</h2><h2 id="Xv6-中的LRU"><a href="#Xv6-中的LRU" class="headerlink" title="Xv6 中的LRU"></a>Xv6 中的LRU</h2><h2 id="LevelDB-数据结构之-LRU-缓存"><a href="#LevelDB-数据结构之-LRU-缓存" class="headerlink" title="LevelDB 数据结构之 LRU 缓存"></a>LevelDB 数据结构之 LRU 缓存</h2><p>Leveldb中使用了一种基于LRUCache的缓存机制，用于缓存：</p><ul><li>已打开的sstable文件对象和相关元数据；</li><li>sstable中的dataBlock的内容；</li></ul><h2 id="如何实现一个线程安全的LRU"><a href="#如何实现一个线程安全的LRU" class="headerlink" title="如何实现一个线程安全的LRU"></a>如何实现一个线程安全的LRU</h2><blockquote><p><a href="https://www.51cto.com/article/661585.html">LevelDB中实现LRU</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql</title>
    <link href="/2023/08/20/mysql/"/>
    <url>/2023/08/20/mysql/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL面试复习"><a href="#MySQL面试复习" class="headerlink" title="MySQL面试复习"></a>MySQL面试复习</h1><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>InnoDB：</p><p>* </p><p>MyISAM：</p><p>* </p><p>RocksDB（LevelDB）</p><h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><p>记录数据库数据变化的，mysql用binlog做<strong>主从同步和备份</strong></p><p>只记录对数据库的修改操作，<strong>记录逻辑日志（记录sql）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">## 查看binlog<br><span class="hljs-keyword">show</span> binlog events;<br>## 翻译binlog文件<br>mysqlbinlog filename <span class="hljs-operator">&gt;</span> out.sql<br></code></pre></td></tr></table></figure><ul><li>刷盘</li></ul><h2 id="redolog"><a href="#redolog" class="headerlink" title="redolog"></a>redolog</h2><p>innodb级别的日志，用来确保事务原子性的日志，当事务执行一半失败时，通过redo log重新执行即可，其目的是<strong>故障恢复</strong></p><p>记录的是<strong>数据页面的变动（磁盘上字节的变动）</strong>，顺序写</p><ul><li><p>刷盘</p></li><li><p>checkpoint</p></li></ul><h2 id="undolog"><a href="#undolog" class="headerlink" title="undolog"></a>undolog</h2><p>innodb用来确保事务原子性的日志，当事务需要rollback时，执行undolog，消除事务的影响</p><h2 id="缓存雪崩和缓存穿透"><a href="#缓存雪崩和缓存穿透" class="headerlink" title="缓存雪崩和缓存穿透"></a>缓存雪崩和缓存穿透</h2><ul><li>如何解决缓存穿透？</li></ul><p>穿透是因为key不在redis中或者已经失效，导致直接访问数据库</p><ol><li>布隆过滤器</li><li>直接返回null，redis再去请求数据库</li></ol><ul><li>如何解决缓存雪崩？</li></ul><p>雪崩的原因是因为许多热点key在同时失效，或者大量特殊请求</p><ol><li>key的超时时间均匀设置，避免同时失效</li><li>热点数据不过期</li></ol><ul><li>如何解决缓存击穿？</li></ul><p>击穿的原因是因为许多请求同时访问一个数据，而这个数据过期了，导致所有请求都进入了数据库</p><ol><li>加锁</li><li>热点数据不过期</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++</title>
    <link href="/2023/08/19/c/"/>
    <url>/2023/08/19/c/</url>
    
    <content type="html"><![CDATA[<h1 id="C-11"><a href="#C-11" class="headerlink" title="C++ 11"></a>C++ 11</h1><h2 id="C-11新特性"><a href="#C-11新特性" class="headerlink" title="C++ 11新特性"></a>C++ 11新特性</h2><ul><li>智能指针<ul><li>Shared_ptr</li><li>Weak_ptr </li><li>Unique_ptr</li></ul></li><li>RAII(智能指针，scope_lock)</li><li>左值 右值</li><li>lambda表达式</li><li>Auto decltype</li><li>尾返回</li><li>for each</li><li>nullptr</li><li>final  override</li></ul><blockquote><p><a href="https://cloud.tencent.com/developer/article/1745592">c++11新特性，所有知识点都在这了！</a></p></blockquote><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>rule of five :  有类型声明的时候，不管有没有等号都是构造，之前定义过用等号接收的就是赋值。</p><table><thead><tr><th></th><th align="center">调用时机</th></tr></thead><tbody><tr><td>Constructor 构造函数</td><td align="center">构造一个class variable时调用构造函数<strong>分配内存</strong>并<strong>初始化</strong></td></tr><tr><td>Copy Constructor 拷贝构造</td><td align="center">使用一个对象构造新的对象时；函数使用类变量作为参数；函数返回一个类变量</td></tr><tr><td>Copy Assignment 拷贝赋值</td><td align="center">使用 &#x3D; 为一个已经初始化过的变量进行赋值，且 &#x3D; 右边为<strong>左</strong>值</td></tr><tr><td>Move Constructor 移动构造</td><td align="center">调用到移动语义时会调用移动构造</td></tr><tr><td>Move Assignment 移动赋值</td><td align="center">使用 &#x3D; 为一个已经初始化过的变量进行赋值，且 &#x3D; 右边为<strong>右</strong>值</td></tr></tbody></table><ul><li>移动语义下记得将&amp;&amp;变量赋值为 nullptr，以避免double use等</li></ul><h3 id="为什么要有初始化列表？"><a href="#为什么要有初始化列表？" class="headerlink" title="为什么要有初始化列表？"></a>为什么要有初始化列表？</h3><p>因为 <strong>std::reference_wrapper</strong> <strong>引用类型成员变量</strong> <strong>const类型变量</strong>都无法通过 <strong>assignment</strong>的方式初始化，只能通过初始化列表</p><blockquote><p><a href="https://www.zhihu.com/question/485487580/answer/2110539152">C++构造函数为什么要依赖初始化列表</a></p></blockquote><h2 id="smart-pointer"><a href="#smart-pointer" class="headerlink" title="smart pointer"></a>smart pointer</h2><p>什么是智能指针： 能够自动管理指针声明周期的释放，主要解决c++内存问题</p><p>解决了什么问题：</p><ol><li>内存泄露</li><li>对象的析构</li></ol><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><ol><li>需要被多个对象共享使用时</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shared_Ptr</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Shared_Ptr</span>(T* ptr = <span class="hljs-literal">nullptr</span>)<br>:_pPtr(ptr)<br>, _pRefCount(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">1</span>))<br>, _pMutex(<span class="hljs-keyword">new</span> mutex)<br>&#123;&#125;<br>~<span class="hljs-built_in">Shared_Ptr</span>()<br>&#123;<br><span class="hljs-built_in">Release</span>();<br>&#125;<br><span class="hljs-built_in">Shared_Ptr</span>(<span class="hljs-type">const</span> Shared_Ptr&lt;T&gt;&amp; sp)<br>:_pPtr(sp._pPtr)<br>, _pRefCount(sp._pRefCount)<br>, _pMutex(sp._pMutex)<br>&#123;<br><span class="hljs-built_in">AddRefCount</span>();<br>&#125;<br>Shared_Ptr&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Shared_Ptr&lt;T&gt;&amp; sp)<br>&#123;<br><span class="hljs-comment">//if (this != &amp;sp)</span><br><span class="hljs-keyword">if</span> (_pPtr != sp._pPtr)<br>&#123;<br><span class="hljs-comment">// 释放管理的旧资源</span><br><span class="hljs-built_in">Release</span>();<br><span class="hljs-comment">// 共享管理新对象的资源，并增加引用计数</span><br>_pPtr = sp._pPtr;<br>_pRefCount = sp._pRefCount;<br>_pMutex = sp._pMutex;<br><span class="hljs-built_in">AddRefCount</span>();<br>&#125;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>T&amp; <span class="hljs-keyword">operator</span>*()&#123;<br><span class="hljs-keyword">return</span> *_pPtr;<br>&#125;<br>T* <span class="hljs-keyword">operator</span>-&gt;()&#123;<br><span class="hljs-keyword">return</span> _pPtr;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">UseCount</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> *_pRefCount; &#125;<br><span class="hljs-function">T* <span class="hljs-title">Get</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> _pPtr; &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddRefCount</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>_pMutex-&gt;<span class="hljs-built_in">lock</span>();<br>++(*_pRefCount);<br>_pMutex-&gt;<span class="hljs-built_in">unlock</span>();<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Release</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">bool</span> deleteflag = <span class="hljs-literal">false</span>;<br>_pMutex-&gt;<span class="hljs-built_in">lock</span>();<br><span class="hljs-keyword">if</span> (--(*_pRefCount) == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> _pRefCount;<br><span class="hljs-keyword">delete</span> _pPtr;<br>deleteflag = <span class="hljs-literal">true</span>;<br>&#125;<br>_pMutex-&gt;<span class="hljs-built_in">unlock</span>();<br><span class="hljs-keyword">if</span> (deleteflag == <span class="hljs-literal">true</span>)<br><span class="hljs-keyword">delete</span> _pMutex;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> *_pRefCount;<br>T* _pPtr;<br>mutex* _pMutex;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">smartpoint</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 表示有多少个共享这个指针</span><br>    <span class="hljs-type">int</span>* count;<br>    <span class="hljs-comment">// 指针所指向的数据</span><br>    <span class="hljs-type">int</span>* data;<br>    <span class="hljs-comment">// threa safe</span><br>    mutex mtx;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">message</span><span class="hljs-params">()</span></span>&#123;<br>        mtx.<span class="hljs-built_in">lock</span>();<br>        cout &lt;&lt; <span class="hljs-string">&quot;user count &quot;</span>&lt;&lt; *count &lt;&lt; <span class="hljs-string">&quot; data:&quot;</span> &lt;&lt; *data &lt;&lt;endl;<br>        mtx.<span class="hljs-built_in">unlock</span>();<br>    &#125;<br>    <span class="hljs-built_in">smartpoint</span>(<span class="hljs-type">int</span> *value)&#123;<br>        mtx.<span class="hljs-built_in">lock</span>();<br>        data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*value);<br>        count = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">1</span>);<br>        mtx.<span class="hljs-built_in">unlock</span>();<br>    &#125;<br>    <span class="hljs-built_in">smartpoint</span>(<span class="hljs-type">const</span> smartpoint&amp; s)&#123;<br>        mtx.<span class="hljs-built_in">lock</span>();<br>        count = s.count;<br>        (*count)++;<br>        data = s.data;<br>        mtx.<span class="hljs-built_in">unlock</span>();<br>    &#125;<br>    ~<span class="hljs-built_in">smartpoint</span>()&#123;<br>        mtx.<span class="hljs-built_in">lock</span>();<br>        (*count) --;<br>        <span class="hljs-keyword">if</span>((*count) == <span class="hljs-number">0</span>)&#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;user count 0&quot;</span> &lt;&lt;endl;<br>            <span class="hljs-keyword">delete</span> count;<br>            count = <span class="hljs-literal">nullptr</span>;<br>            <span class="hljs-keyword">delete</span> data;<br>            data = <span class="hljs-literal">nullptr</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;user count &quot;</span>&lt;&lt; *count &lt;&lt;endl;<br>        &#125;<br>        mtx.<span class="hljs-built_in">unlock</span>();<br>    &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p><strong>什么时候使用？</strong></p><ul><li>类内部使用不对外暴露</li><li>方法内部使用，不对外暴露</li></ul><p>unique_ptr是一个删除了拷贝构造函数、保留了移动构造函数的指针封装类型</p><ol><li>类内部自己使用</li><li>离开作用域自动释放资源</li><li>通过operator&#x3D;或reset()赋值另一指针给管理的unique_ptr对象</li></ol><p><strong>如何实现一个unique_ptr？</strong></p><p>构造函数：</p><ol><li>要向外显示的提供构造函数：<ul><li>普通构造函数，移动构造函数，移动赋值（不支持拷贝构造）</li></ul></li><li>提供一个默认的删除器，在适当的时候释放unique_ptr<ul><li>释放的时候必须要将内部的ptr指向nullptr</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyUniquePtr</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyUniquePtr</span>(T* ptr = <span class="hljs-literal">nullptr</span>)<br>        :<span class="hljs-built_in">mPtr</span>(ptr)<br>    &#123;&#125;<br><br>    ~<span class="hljs-built_in">MyUniquePtr</span>()<br>    &#123;<br>        <span class="hljs-keyword">if</span>(mPtr)<br>            <span class="hljs-keyword">delete</span> mPtr;<br>    &#125;<br><br>    <span class="hljs-built_in">MyUniquePtr</span>(MyUniquePtr &amp;&amp;p) ;<br>    MyUniquePtr&amp; <span class="hljs-keyword">operator</span>=(MyUniquePtr &amp;&amp;p) ;<br><br>    <span class="hljs-built_in">MyUniquePtr</span>(<span class="hljs-type">const</span> MyUniquePtr &amp;p) = <span class="hljs-keyword">delete</span>;<br>    MyUniquePtr&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyUniquePtr &amp;p) = <span class="hljs-keyword">delete</span>;<br><br>    T&amp; <span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span> &#123;<span class="hljs-keyword">return</span> *mPtr;&#125;<br>    T* <span class="hljs-keyword">operator</span>-&gt;()<span class="hljs-type">const</span> &#123;<span class="hljs-keyword">return</span> mPtr;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(T* q = <span class="hljs-literal">nullptr</span>)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(q != mPtr)&#123;<br>            <span class="hljs-keyword">if</span>(mPtr)<br>                <span class="hljs-keyword">delete</span> mPtr;<br>            mPtr = q;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">T* <span class="hljs-title">release</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        T* res = mPtr;<br>        mPtr = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function">T* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> mPtr;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(MyUniquePtr &amp;p)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">using</span> std::swap;<br>        <span class="hljs-built_in">swap</span>(mPtr, p.mPtr);<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    T* mPtr;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>MyUniquePtr&lt;T&gt;&amp; MyUniquePtr&lt;T&gt;::<span class="hljs-keyword">operator</span>=(MyUniquePtr &amp;&amp;p)<br>&#123;<br>    <span class="hljs-keyword">if</span>(*<span class="hljs-keyword">this</span> != p)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(mPtr)<br>            <span class="hljs-keyword">delete</span> mPtr;<br>        mPtr = p.mPtr;<br>        p.mPtr = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>MyUniquePtr&lt;T&gt; :: <span class="hljs-built_in">MyUniquePtr</span>(MyUniquePtr &amp;&amp;p) : <span class="hljs-built_in">mPtr</span>(p.mPtr)<br>&#123;<br>    p.mPtr == <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><ol><li>解决了循环引用的问题</li><li>缓存问题</li><li>观察者模式下通知问题（不希望让观察者影响对象的生命周期，因而需要使用weak_ptr）</li></ol><blockquote><p><a href="https://www.modb.pro/db/218468">C++ 智能指针最佳实践&amp;源码分析</a></p><p><a href="https://01io.tech/unique_ptr-vs-shared_ptr-vs-weak_ptr/">C++ 三种智能指针的使用场景(unique_ptr vs shared_ptr vs weak_ptr)</a></p></blockquote><h2 id="引用和指针"><a href="#引用和指针" class="headerlink" title="引用和指针"></a>引用和指针</h2><ul><li>指针</li></ul><p>指向一个地址空间的变量，变量里存的是一个地址</p><p>可以指向空，定义时也不是必须初始化</p><ul><li>引用</li></ul><p>一个变量的别名，与这个变量同步，对引用的修改就是对变量的修改</p><p>定义时必须引用某个变量，不能换一个变量引用</p><p>引用类似于一个<strong>const pointer</strong>，指向的地址不能改变，但地址上的内容可以改变</p><h2 id="左值-右值"><a href="#左值-右值" class="headerlink" title="左值 右值"></a>左值 右值</h2><p><strong>核心目的：</strong> 提出右值是为了<strong>解决深拷贝时的性能问题</strong></p><ul><li><p><strong>左值</strong>：左值是可寻址的变量，有持久性；</p></li><li><p><strong>左值引用</strong>：引用一个对象；</p></li><li><p><strong>右值</strong>： 右值一般是不可寻址的常量，或在表达式求值过程中创建的无名临时对象，短暂性的。</p></li><li><p><strong>右值引用</strong>：就是必须绑定到右值的引用，C++11中右值引用可以实现“移动语义”，通过 &amp;&amp; 获得右值引用。</p></li></ul><hr><p><strong>被声明出来的左、右值引用都是左值</strong>。 因为被声明出的<a href="https://www.zhihu.com/search?q=%E5%B7%A6%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22335994370%22%7D">左右值引用</a>是有地址的，也位于等号左边</p><h3 id="右值引用接受左值"><a href="#右值引用接受左值" class="headerlink" title="右值引用接受左值"></a>右值引用接受左值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp;&amp; arg)</span></span>&#123;<br>  <span class="hljs-comment">// 被声明出来的左、右值引用都是左值</span><br>  <span class="hljs-comment">// 右值引用必须接受右值</span><br>  <br>  <span class="hljs-comment">// 编译失败</span><br>  <span class="hljs-type">int</span>&amp;&amp; b = arg; <br>  <span class="hljs-comment">// 编译成功</span><br>  <span class="hljs-type">int</span>&amp;&amp; a = std::<span class="hljs-built_in">move</span>(arg);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="std-move-std-forward"><a href="#std-move-std-forward" class="headerlink" title="std::move std::forward"></a>std::move std::forward</h3><p><strong>可移动对象在&lt;需要拷贝且被拷贝者之后不再被需要&gt;的场景，建议使用</strong><code>std::move</code><strong>触发移动语义，提升性能。</strong></p><p><strong>std::move本身只做类型转换，对性能无影响。</strong> <strong>我们可以在自己的类中实现移动语义，避免深拷贝，充分利用右值引用和std::move的语言特性。</strong></p><ul><li><p>std::move 只能将一个左值转化为右值</p></li><li><p>std::forward<T>(u)有两个参数：T与 u</T></p><p>a. 当T为左值引用类型时，u将被转换为T类型的左值；</p><p>b. 否则u将被转换为T类型右值。</p></li></ul><h3 id="push-back-and-emplace-back"><a href="#push-back-and-emplace-back" class="headerlink" title="push_back and emplace_back"></a>push_back and emplace_back</h3><ul><li>Push_back : 会创建一个变量，再将变量拷贝到vector中</li><li>emplace_back : 会在vector中原地创建一个变量</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 例2：std::vector和std::string的实际例子</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string str1 = <span class="hljs-string">&quot;aacasxs&quot;</span>;<br>    std::vector&lt;std::string&gt; vec;<br>     <br>    vec.<span class="hljs-built_in">push_back</span>(str1); <span class="hljs-comment">// 传统方法，copy</span><br>    vec.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(str1)); <span class="hljs-comment">// 调用移动语义的push_back方法，避免拷贝，str1会失去原有值，变成空字符串</span><br>    vec.<span class="hljs-built_in">emplace_back</span>(std::<span class="hljs-built_in">move</span>(str1)); <span class="hljs-comment">// emplace_back效果相同，str1会失去原有值</span><br>    vec.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-string">&quot;axcsddcas&quot;</span>); <span class="hljs-comment">// 当然可以直接接右值</span><br>&#125;<br> <br><span class="hljs-comment">// std::vector方法定义</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span> <span class="hljs-params">(<span class="hljs-type">const</span> value_type&amp; val)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span> <span class="hljs-params">(value_type&amp;&amp; val)</span></span>;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">emplace_back</span> <span class="hljs-params">(Args&amp;&amp;... args)</span></span>;<br></code></pre></td></tr></table></figure><blockquote><p><a href="https://zhuanlan.zhihu.com/p/335994370">一文读懂C++右值引用和std::move</a></p></blockquote><h2 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h2><p>继承和多态： 继承（Inheritance）是面向对象编程中的一种机制，允许一个类（派生类）继承另一个类（基类）的属性和方法。继承可以建立类之间的层次关系，派生类可以继承基类的数据和方法，并可以添加自己的特性。 多态（Polymorphism）是实现面向对象编程中的一个重要概念，通过派生类对基类的虚函数进行重写，可以实现不同类型的对象对同一消息的不同响应。多态性可以提高代码的灵活性和可扩展性，通过基类的指针或引用调用虚函数时，根据对象的实际类型来确定调用的函数版本，实现多态行为。</p><p>C++如何实现多态？通过虚函数实现，虚函数通过虚函数表实现。编译器在编译阶段将所有包含虚函数的对象增强，为每个类增加一个虚函数指针</p><p>虚函数和纯虚函数： 虚函数（Virtual Function）是在基类中声明的函数，可以在派生类中进行重写，通过基类指针或引用调用时根据对象的实际类型来确定具体调用的函数版本，实现多态性。</p><p>虚函数需要通过基类的指针或引用来调用，因为动态绑定是在运行时确定的。 </p><p>纯虚函数（Pure Virtual Function）是一个没有实现的虚函数，在基类中只有函数的声明，没有函数的定义。派生类必须实现纯虚函数，否则派生类也会成为抽象类。纯虚函数用于定义接口，强制派生类实现特定的函数，实现接口的统一性。 </p><h2 id="std-bind-std-functional"><a href="#std-bind-std-functional" class="headerlink" title="std::bind &amp;&amp; std::functional"></a>std::bind &amp;&amp; std::functional</h2><h2 id="std-unique-lock-std-scope-lock-std-lock-guard"><a href="#std-unique-lock-std-scope-lock-std-lock-guard" class="headerlink" title="std::unique_lock &amp;&amp; std::scope_lock &amp;&amp; std::lock_guard"></a>std::unique_lock &amp;&amp; std::scope_lock &amp;&amp; std::lock_guard</h2><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>static作用是更改<strong>变量的存储方式和作用域</strong>；</p><p>static可以修饰全局变量和局部变量，<strong>静态全局变量和非静态全局变量都是静态存储方式，存储方式相同（都在静态区）；</strong></p><ol><li>修饰局部变量：静态局部变量存储在静态区，非静态存储在栈上，生命周期结束后静态局部变量不会被销毁</li><li>修饰全局变量：静态全局变量同样存储在静态区，并且只能被当前文件内使用</li><li>修饰成员变量：成员变量归类所属而不是具体属于某一对象，实现了同一类多对象之间的数据共享</li><li>静态成员函数：主要用于管理静态变量，静态成员函数只能访问静态成员变量</li></ol><p>原因在于：非静态成员函数，在调用时，this指针被当做参数传进。而静态成员函数属于类，而不属于对象，<strong>没有this指针</strong>。</p><blockquote><p> static修饰符的作用 <a href="https://blog.csdn.net/sss_369/article/details/90243145">https://blog.csdn.net/sss_369/article/details/90243145</a></p></blockquote><h2 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h2><p><strong>目的：</strong>这样可以解决一些频繁调用的函数大量消耗栈空间（栈内存）的问题；</p><ul><li>inline是在编译阶段，define是在预处理阶段</li></ul><p>1．inline定义的类的内联函数，函数的代码被放入符号表中，在使用时直接进行替换（像宏一样展开），没有了调用的开销，效率也很高。<br>2．很明显，类的内联函数也是一个真正的函数，编译器在调用一个内联函数时，会首先检查它的参数的类型，保证调用正确。然后进行一系列的相关检查，就像对待任何一个真正的函数一样。这样就消除了它的隐患和局限性。<br>3．inline可以作为某个类的成员函数，当然就可以在其中使用所在类的保护成员及私有成员。</p><ul><li>为什么不能inline递归函数？</li></ul><p>递归函数是通过函数自身来实现循环的一种方式，<strong>它需要在每次递归调用时保留一些状态信息</strong>，如局部变量和返回地址。</p><p>由于内联函数在编译阶段展开，它的代码会在调用点完全展开，而不会像普通函数调用一样建立新的函数调用栈帧。然而，递归函数需要多个函数调用栈帧来保存不同递归层次的状态信息，这与内联函数的展开机制不兼容。如果将递归函数声明为内联函数，编译器将无法在编译阶段确定需要展开的次数，也无法正确地管理函数调用栈帧。</p><p>因此，由于内联函数的展开方式和递归函数的调用栈需求不匹配，大多数编译器会禁止将递归函数声明为内联函数。如果确实需要在递归函数中获得类似内联函数的效果，通常需要手动展开递归，或者考虑其他的优化方式。</p><h2 id="编译和链接"><a href="#编译和链接" class="headerlink" title="编译和链接"></a>编译和链接</h2><p><a href="https://zhuanlan.zhihu.com/p/369039101">https://zhuanlan.zhihu.com/p/369039101</a></p><h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><p>C++优先队列是优先级高的在队首，定义优先级大小的方式是传入一个算子的参数比较a, b两个东西，返回true则a的优先级&lt;b的优先级。</p><p>默认是less算子也就是返回a&lt;b，也就是小的优先级也小，而greater算子返回a&gt;b，小的优先级高。</p><p>如果是默认的less算子，值大的优先级高，值大的排到了队头，优先队列大的先出队。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, less&lt;<span class="hljs-type">int</span>&gt;&gt;s;   <span class="hljs-comment">//less默认大堆</span><br><span class="hljs-comment">//less表示按照递减(从大到小)的顺序插入元素</span><br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt;s; <span class="hljs-comment">//greater默认小堆</span><br><span class="hljs-comment">//greater表示按照递增（从小到大）的顺序插入元素</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Language</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gdb</title>
    <link href="/2023/08/08/gdb/"/>
    <url>/2023/08/08/gdb/</url>
    
    <content type="html"><![CDATA[<h1 id="GDB-使用技巧"><a href="#GDB-使用技巧" class="headerlink" title="GDB 使用技巧"></a>GDB 使用技巧</h1><h2 id="gdb调试多线程死锁"><a href="#gdb调试多线程死锁" class="headerlink" title="gdb调试多线程死锁"></a>gdb调试多线程死锁</h2><p><strong>出现死锁的必要条件：</strong></p><ul><li>互斥条件：一个资源每次只能被一个进程使用</li><li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放</li><li>不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺</li><li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系</li></ul><ol start="0"><li>g++ -o deadlock -g <strong>-lpthread</strong> deadlock.cpp</li></ol><p>​<strong>多线程程序编译时记得加上plthread，否则无法编译成功</strong></p><ol><li>首先找到出现死锁进程的pid<br><code>ps -ef | grep deadlock.out</code></li><li>然后可以通过gdb -p 进程号，进入运行进程的gdb模式<br><code>gdb -p pid</code></li><li>使用info threads查看所有的线程运行信息</li></ol><p><img src="/2023/08/08/gdb/image-20230808231006297.png" alt="image-20230808231006297"></p><ul><li><p>LWP (Light Weight Process) 是一种线程，它在操作系统中被称为轻量级进程。它与普通线程相比，具有更少的系统开销，因此在多线程程序中的使用非常广泛。</p><p>当我们使用 GDB 调试多线程的 LWP 时，我们可以在程序运行时对每个线程的行为进行独立跟踪，以帮助我们找出线程间的冲突或其他问题。GDB 可以帮助我们暂停、继续、单步执行每个线程，并且可以查看每个线程的堆栈、变量和其他信息。</p></li></ul><ol start="4"><li>使用<strong>backtrace</strong>即可查看死锁位置</li></ol><p><img src="/2023/08/08/gdb/image-20230808231203795.png" alt="image-20230808231203795"></p><h2 id="gdb调试coredump"><a href="#gdb调试coredump" class="headerlink" title="gdb调试coredump"></a>gdb调试coredump</h2><p>coredump是指程序在发生错误退出时，计算机当时的状态，因此使用gdb对coredump程序调试就相当于对崩溃那一瞬间的程序进行调试。</p><ul><li>ulimit -c ulimit确保可以声称coredump程序</li><li>正常执行调试即可</li></ul><p>编写代码的过程中总会遇到一些bug，有些会在编译阶段提示，而有些则会在程序运行时中断，还有些bug会不停的积累，直到严重时显现，以下为平常容易遇到bug info</p><ol><li>segment fault （段错误）</li><li>heap buffer overflow （堆溢出）</li><li>stack overflow（栈溢出）</li></ol><hr><p><strong>Segment Fault</strong></p><p>段错误就是程序访问了错误的内存段或者访问了不存在的地址空间（访问nullptr）</p><ul><li>数组越界（int array[10];   array[100] &#x3D; 10; ）<ul><li>这种是在栈上声明一个数组，因此访问数组之外的空间会立刻提示Segment fault</li></ul></li><li>访问系统数据区，尤其是往系统保护的内存地址写数据，最常见就是给一个指针以0地址<ul><li>int* ptr &#x3D; nullptr; *ptr &#x3D; 1; </li><li>char* ptr &#x3D; “hello world”; ptr[1] &#x3D; ‘a’; (hello world作为字符串常量会被存储在 <code>.rodata段</code>无法被修改)</li></ul></li></ul><p><strong>Heap Buffer Overflow</strong></p><p>堆溢出是由于<strong>new</strong> 或者 <strong>malloc</strong>等在堆上进行内存申请和释放时<strong>访问</strong>了或者<strong>写入了过多数据</strong>导致的bug</p><ul><li>int* array &#x3D; new int[10]; a[11] &#x3D; 1; <ul><li>new 是在堆上分配内存空间，此时越界访问不一定会触发错误</li></ul></li></ul><p><strong>Stack Overflow</strong></p><p>栈溢出是比较经典的错误，一般是由于无限调用栈，导致栈空间不够而带来的问题</p><ul><li>随便一个无限递归的函数都会带来这种bug</li></ul><h2 id="backtrace-和-signal"><a href="#backtrace-和-signal" class="headerlink" title="backtrace 和 signal"></a>backtrace 和 signal</h2><p>内存泄露检测<br>内存溢出和内存泄露</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LSM</title>
    <link href="/2023/08/06/LSM/"/>
    <url>/2023/08/06/LSM/</url>
    
    <content type="html"><![CDATA[<h2 id="LevelDB"><a href="#LevelDB" class="headerlink" title="LevelDB"></a>LevelDB</h2><p>我感觉分层设计并不是为了解决全量读的问题，因为仍然会有key是要遍历所有的层。分层设计的目的是为了<strong>分摊写放大</strong>，此时有一个memtable写满了，需要从内存刷入磁盘，而此时恰好该memtable内的数据范围正好完全覆盖了整个level0中的所有SSTable，那么会造成一个很恐怖的事情：需要将level0中所有的SSTable和Memtable中的数据做合并，也就是说，需要将每个SSTable读到内存后，将Memtable里面符合其范围的数据插入到该SSTable中。这就造成了该时间段内的大量磁盘IO并阻塞内存写入磁盘。</p><p>相比于b+树索引的存储引擎有什么优点？</p><ol><li>是ou t-of-place的修改，更适用于多写的场景（现代日志系统）</li><li>append-only模式，lsm中的更新 删除操作都是追加写即可，通过顺序IO取代随机IO</li></ol><p>lsm结构带来了什么缺点？</p><ol><li>分层结构带来了读放大</li><li>为了解决读放大增加了compaction机制，这又带来了写放大</li><li>不利于range scan</li></ol><p><img src="/2023/08/06/LSM/image-20240524191637488.png" alt="image-20240524191637488"></p><h2 id="LevelDB-Arena内存池"><a href="#LevelDB-Arena内存池" class="headerlink" title="LevelDB Arena内存池"></a>LevelDB Arena内存池</h2><p>为了避免因频繁使用new&#x2F;delete而带来性能损失，leveldb中设计了一个简易的内存池<strong>Arena</strong>来提高内存分配效率。Arena本身是不保证线程安全的，但leveldb能够确保arena的调用者是线程安全的</p><p>leveldb为每个memtable分配一个内存管理器，而Arena只有allocate而没有free，其申请的全部内存随着arena析构而释放。</p><h4 id="分配策略"><a href="#分配策略" class="headerlink" title="分配策略"></a>分配策略</h4><p>Arena内部使用一个<em>alloc_ptr_（分配指针）</em> &amp;&amp; <em>alloc_bytes_remaining_（剩余字节数）</em> &amp;&amp; *vector&lt;char*&gt; blocks_（已分配内存地址） &amp;&amp; atomic<size_t> memory_usage_（内存使用量） 来表示内存分配状态</size_t></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 向外提供的申请内存接口</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">char</span>* <span class="hljs-title">Arena::Allocate</span><span class="hljs-params">(<span class="hljs-type">size_t</span> bytes)</span> </span>&#123;<br>  <span class="hljs-comment">// The semantics of what to return are a bit messy if we allow</span><br>  <span class="hljs-comment">// 0-byte allocations, so we disallow them here (we don&#x27;t need</span><br>  <span class="hljs-comment">// them for our internal use).</span><br>  <span class="hljs-built_in">assert</span>(bytes &gt; <span class="hljs-number">0</span>);<br>  <span class="hljs-comment">// arena的内存块中仍有足够的空间，则用block分配内存</span><br>  <span class="hljs-keyword">if</span> (bytes &lt;= alloc_bytes_remaining_) &#123;<br>    <span class="hljs-type">char</span>* result = alloc_ptr_;<br>    alloc_ptr_ += bytes;<br>    alloc_bytes_remaining_ -= bytes;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>  <span class="hljs-comment">// arena没有足够的空间时，去申请新的内存块</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">AllocateFallback</span>(bytes);<br>&#125;<br><span class="hljs-comment">// 调用AllocateFallback函数就代表当前arena没有足够的剩余空间</span><br><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">Arena::AllocateFallback</span><span class="hljs-params">(<span class="hljs-type">size_t</span> bytes)</span> </span>&#123;<br>  <span class="hljs-comment">// 当所需内存大于kBlockSize / 4时，直接为其分配需要的内存空间</span><br>  <span class="hljs-keyword">if</span> (bytes &gt; kBlockSize / <span class="hljs-number">4</span>) &#123;<br>    <span class="hljs-comment">// Object is more than a quarter of our block size.  Allocate it separately</span><br>    <span class="hljs-comment">// to avoid wasting too much space in leftover bytes.</span><br>    <span class="hljs-type">char</span>* result = <span class="hljs-built_in">AllocateNewBlock</span>(bytes);<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br><span class="hljs-comment">// 当所需内存较小时</span><br>  <span class="hljs-comment">// We waste the remaining space in the current block.</span><br>  alloc_ptr_ = <span class="hljs-built_in">AllocateNewBlock</span>(kBlockSize);<br>  alloc_bytes_remaining_ = kBlockSize;<br><br>  <span class="hljs-type">char</span>* result = alloc_ptr_;<br>  alloc_ptr_ += bytes;<br>  alloc_bytes_remaining_ -= bytes;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// 分配新的内存块</span><br><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">Arena::AllocateNewBlock</span><span class="hljs-params">(<span class="hljs-type">size_t</span> block_bytes)</span> </span>&#123;<br>  <span class="hljs-type">char</span>* result = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[block_bytes];<br>  <span class="hljs-comment">// 将新的内存地址插入blocks_以便记录</span><br>  blocks_.<span class="hljs-built_in">push_back</span>(result);<br>  <span class="hljs-comment">// 记录当前占用的内存空间</span><br>  memory_usage_.<span class="hljs-built_in">fetch_add</span>(block_bytes + <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>*),<br>                          std::memory_order_relaxed);<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="看代码时的疑惑"><a href="#看代码时的疑惑" class="headerlink" title="看代码时的疑惑"></a>看代码时的疑惑</h4><p>Q1: 既然arena的调用者是线程安全的，为什么memory_usage_不能直接用size_t？</p><p>A1: 虽然arena的调用者是线程安全的，但在分配内存时还有可能被调用MemoryUsage()函数</p><blockquote><p>去翻github的提交记录可以找到早些版本的leveldb确实是用size_t的 &gt; &lt; </p><p>Resolve race when getting approximate-memory-usage property <a href="https://github.com/google/leveldb/commit/706b7f8d43b0aecdc75c5ee49d3e4ef5f27b9faf">https://github.com/google/leveldb/commit/706b7f8d43b0aecdc75c5ee49d3e4ef5f27b9faf</a></p></blockquote><p>Q2: Arena在什么场景比较合适？</p><p>A2: Arena在需要小内存的场景比较适合，在leveldb中小内存是指小于4k&#x2F;4的情况，当频繁申请4k&#x2F;4以上的内存时，arena会退化为new的分配方式</p>]]></content>
    
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Detecting bugs of join</title>
    <link href="/2023/06/26/Detecting-bugs-of-join/"/>
    <url>/2023/06/26/Detecting-bugs-of-join/</url>
    
    <content type="html"><![CDATA[<h2 id="why"><a href="#why" class="headerlink" title="why?"></a>why?</h2><ul><li>Optimizer 是十分重要的，好的执行计划能大幅度提高sql语句的执行效率</li><li>Nonetheless, existing generation-based debug tools are limited to single-table queries and there is a substantial research gap regarding multi-table queries with join operators</li></ul><h2 id="what？"><a href="#what？" class="headerlink" title="what？"></a>what？</h2><ul><li>这篇论文提出一个框架-TQS（Data-guided Schema and Query Generation (DSG) and Knowledge-guided Query Space Exploration (KQE)）</li></ul><h2 id="how？"><a href="#how？" class="headerlink" title="how？"></a>how？</h2><h2 id="now？"><a href="#now？" class="headerlink" title="now？"></a>now？</h2><blockquote><p>PQS Testing <a href="https://zhuanlan.zhihu.com/p/144725800">https://zhuanlan.zhihu.com/p/144725800</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>八股文</title>
    <link href="/2023/06/15/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    <url>/2023/06/15/%E5%85%AB%E8%82%A1%E6%96%87/</url>
    
    <content type="html"><![CDATA[<h1 id="15445"><a href="#15445" class="headerlink" title="15445"></a>15445</h1><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><ul><li>B+树和B树的区别</li></ul><ol><li>B树的节点(根节点&#x2F;父节点&#x2F;中间节点&#x2F;叶子节点)中没有重复元素，B+树有。</li><li>B树的中间节点会存储数据指针信息，而B+树只有叶子节点才存储。</li><li>B+树的每个叶子节点有一个指针指向下一个节点，把所有的叶子节点串在了一起。</li></ol><ul><li>B+树的插入？</li></ul><ol><li><p>找到合适的LeafPage，插入</p><p>如何找到合适的leafPage：在internal page中找到第一个大于key的index所对应的value，并进入其所在的page，如此循环直到leaf</p></li><li><p>LeafPage插入后如果size &lt; maxSize，则结束进程</p></li><li><p>插入后若size &#x3D;&#x3D; maxSize，则分裂，将中间值插入父节点，插入前若internal size &#x3D;&#x3D; maxSize，怎继续分裂并把中间值向上插入（有可能分裂到根，插入有可能引发树高+1）</p><p>怎样分裂：先开辟一片可以存放leaf maxSize + 1个kv的内存空间，并将要插入的kv对以及leaf中所有kv对插入进这片空间，随后将前minSize个转移到原有leaf中，将后面maxSize - minSize个转移到一个新创建的page中，并选新创建的page中的第一个key向父节点插入，以此循环，有可能插入到根</p></li></ol><ul><li>B+树的删除？</li></ul><ol><li><p>找到合适的LeafPage，删除</p><p>如何找到合适的leafPage：在internal page中找到第一个大于key的index所对应的value，并进入其所在的page，如此循环直到leaf</p></li><li><p>LeafPage中包含对应key的value，且删除后size &gt; minSize ，则结束</p></li><li><p>删除后若size &lt; minSize，首先看左右两个兄弟节点是否有富裕的kv（富裕代表size &gt; minSize ），则借一个kv即可</p></li><li><p>若左右兄弟不富裕，那么要进行合并操作，两节点合并后，删除父节点对应的指针，若父节点也不富裕了，则向上合并直到跟节点</p></li></ol><ul><li>B+树索引如何实现并发？</li></ul><p>悲观：</p><ul><li><p>B+树处理并发的思路，如何优化？</p></li><li><p>为什么MySQL使用B+树而不是用B树？</p></li><li><p>B树的应用场景</p></li><li><p>B+树和LSM的应用场景？LSM存在哪些问题，若何解决？</p></li></ul><h2 id="查询执行"><a href="#查询执行" class="headerlink" title="查询执行"></a>查询执行</h2><ul><li>什么是火山模型</li></ul><p>流式迭代模型</p><p>所有的代数运算符(operator)都被看成是一个迭代器，它们都提供一组简单的接口：open()—next()—close()，查询计划树由一个个这样的关系运算符组成，每一次的next()调用，运算符就返回一行(Row)，每一个运算符的next()都有自己的流控逻辑，数据通过运算符自上而下的next()嵌套调用而被动的进行拉取。</p><ul><li>为什么要用火山模型？有什么优点？有什么缺点？缺点怎么改进？</li></ul><p>火山模型中每一个运算符都将下层的输入看成是一张表，next()接口的一次调用就获取表中的一行数据，这样设计的优点是：</p><ol><li><strong>每个运算符之间的代数计算是相互独立的</strong>，并且运算符可以伴随查询关系的变化出现在查询计划树的任意位置，这使得运算符的算法实现变得简单并且富有拓展性。<strong>（抽象程度高，实现简单）</strong></li><li>数据以row的形式在运算符之间流动，只要没有sort之类破坏流水性的运算出现，每个运算符仅需要很少的buffer资源就可以很好的运行起来，非常的节省内存资源。</li></ol><p>但是这种运算符的嵌套模型也有它的缺点：</p><ol><li>火山模型的流控是一种被动拉取数据的过程，每行数据流向每一个运算符都需要额外的流控操作，所以数据在操作符之间的流动带来了很多冗余的流控指令。</li><li>运算符之间的next()调用带来了<strong>很深的虚函数嵌套</strong>，编译器无法对虚函数进行inline优化，每一次<strong>虚函数的调用都需要查找虚函数表</strong>，同时也带来了更多的分支指令，<strong>复杂的虚函数嵌套对CPU的分支预测非常不友好</strong>，很容易因为预测失败而导致CPU流水线变得混乱。这些因素都会导致CPU执行效率低下。</li></ol><ul><li><p>解释一下左连接和内连接</p></li><li><p>怎么理解数据库回表</p></li></ul><p>早物化，无需回表；晚物化，最后返回结果时还需要回表</p><ul><li>两个大表怎么进行join？大表指的是内存装不下的表</li></ul><p>连表时，有个原则，要尽量把小表（所占页数较少的表）放在左侧（此时这个小表也叫驱动表），后面会讲到，这会减少硬盘IO次数</p><ol><li>hash join：（join时那个表放进内存，那个表在disk？）</li></ol><ul><li>还有什么查询优化的方式？（逻辑优化）</li></ul><p>谓词划分、谓词下推、嵌套子循环转换为join、解耦子查询和父查询（难以重写为join的情况下）、join order顺序调整、</p><h2 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h2><ul><li><p>MVCC有什么作用？怎么实现的？</p></li><li><p>2PL和MVVC的效率对比？</p></li></ul><p>二阶段锁会在事务对对象更新的时候加锁，其余事务无法对对象进行读取，直到事务提交；</p><p>MVCC没有利用锁机制实现版本并发控制，而是通过版本号将不同版本的数据分割开，只读事务可以在无锁的情况下读取需要的一致性快照，以解决读写冲突；</p><p>在效率上相对2PL会更高一点，因为没有锁申请和锁释放，包括也没有锁等待或者死锁的情况出现。</p><ul><li>2PL的原理，它存在什么问题？如何解决这些问题？</li><li>如何基于2PL实现事务的隔离级别？</li><li>什么是严格两阶段锁？strict-2PL</li><li>什么是强两阶段锁？strong-2PL</li><li>隔离级别是什么？</li><li>什么情况下会存在幻读？</li><li>快照隔离存在什么问题？什么是写偏序？</li><li>项目中所设计的几种锁介绍一下？怎么理解隔离级别和锁的关系？</li><li>怎么解决死锁？</li><li>MySQL怎么保证原子性？</li><li>MySQL默认的隔离级别是什么？可重复读会有什么问题？既然可重复读有幻读的问题那MySQL满足了隔离性吗？如果满足了幻读问题如何解决？如果没满足如何保证的数据一致性？</li><li>为什么要设计成非聚簇索引形式？</li><li>非聚簇索引和聚簇索引在效率上区别？</li></ul><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><h2 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h2><ul><li>可扩展哈希如何扩容？如何缩容？</li><li>LRU-K算法的应用场景</li><li>LRU-K对比LRU的优势在哪里？</li><li>缓冲池的执行流程？</li><li>Page cache的执行流程</li><li>什么情况下可以用O_Direct？</li><li>如果页的大小为16kb，而磁盘只保证4kb的读写是原子的，刷脏页的时候只刷了部分页进程就崩溃了，怎么处理？</li></ul><h2 id="总体"><a href="#总体" class="headerlink" title="总体"></a>总体</h2><ul><li>sql语句的执行流程？</li><li>最左匹配原则？为什么？</li><li>什么情况下使用索引速度反而慢？</li><li>回表是什么？怎么避免？</li><li>慢查询怎么排查？如何优化？</li><li>如何提高插入大量数据的速度？</li><li>为什么要做分库分表？</li></ul><h1 id="6-824"><a href="#6-824" class="headerlink" title="6.824"></a>6.824</h1><ol><li>Raft是什么？为什么不写Paxos？</li><li>Raft选举讲一下</li><li>Raft逻辑时钟会不会倒退</li><li>Raft日志同步</li><li>Raft脑裂</li></ol><p>445一般问一问隔离级别，b+树锁</p><p>824问cap和脑裂</p>]]></content>
    
    
    
    <tags>
      
      <tag>八股文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.13</title>
    <link href="/2023/06/13/6-13/"/>
    <url>/2023/06/13/6-13/</url>
    
    <content type="html"><![CDATA[<h1 id="6-12-学习笔记"><a href="#6-12-学习笔记" class="headerlink" title="6.12 学习笔记"></a>6.12 学习笔记</h1><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>反转链表:主要还是围绕递归，所以关于链表的题目我们要明确递归函数的定义（递归函数的输入是什么，输出是什么，中间做了什么）</p><ul><li>反转链表</li></ul><p>reverse(ListNode* head)函数表示反转从head开始的链表，并返回新的头节点，因此我们只需要接受新的头节点并作为最终头节点，并反转当前节点即可（当前节点的next指针还连接着一个节点）</p><p><strong>有点像是把当前节点重新插入一个链表的尾部</strong></p><ul><li>反转链表中前N个数</li></ul><p>reverse(ListNode* head, int n)函数表示反转从head开始的N个数，并返回新的头节点，因此我们只需要接受新的头节点并作为最终头节点，并把当前节点插入已经反转的链表中（这时需要注意要存下来第N + 1个节点，并让当前节点指向N+1个节点 ）</p><ul><li>两两交换反转链表</li></ul><p>ListNode* swapPairs(ListNode* head) 函数表示反转head开始的两个节点，并返回新的头节点；我们可以先反转两个节点，并接着反转后面的节点，也可以先接收后面已经反转成功的链表。再反转head和head-&gt;next</p><ul><li>反转left到right之间的数</li></ul><p>利用反转前N个数的函数定义</p><ul><li>K个一组反转链表</li></ul><p>和两个一组交换节点的感觉差不多，先反转k个节点，再接收后面已经反转好的链表</p><h2 id="CMU15445"><a href="#CMU15445" class="headerlink" title="CMU15445"></a>CMU15445</h2><h3 id="p2-B-Tree-Internal-Page"><a href="#p2-B-Tree-Internal-Page" class="headerlink" title="p2 B+Tree Internal Page"></a>p2 B+Tree Internal Page</h3><ul><li><p>An Internal Page does not store any real data, but instead it stores an ordered <strong>m</strong> key entries and <strong>m+1</strong> child pointers (a.k.a page_id). Since the number of pointers does not equal the number of keys, the first key is set to be invalid, and lookup methods should always start with the second key. At any time, each internal page is at least half full. During deletion, two half-full pages can be joined to make a legal one or can be redistributed to avoid merging, while during insertion one full page can be split into two. This is an example of one of the many design choices that you will make in the implementation of the B+ Tree.</p><p>You must implement your Internal Page in the designated files. You are only allowed to modify the header file (<code>src/include/storage/page/b_plus_tree_internal_page.h</code>) and its corresponding source file (<code>src/storage/page/b_plus_tree_internal_page.cpp</code>).</p><ul><li>中间节点并不存储真实的数据，然而它会存储m个有序的key和m+1个指针（page_id）。因为指针的数量不等于key的数量，因此internal page的第一个key被设为invalid，并且lookup函数都从第二个key开始。internal page再任何时候都是至少半满的，在删除操作时，两个半满的page能够合并为一个or通过重新分布key避免合并；在插入操作时，一个全满的page有可能被分成两个</li></ul></li></ul><h3 id="B-Tree-Leaf-Page"><a href="#B-Tree-Leaf-Page" class="headerlink" title="B+Tree Leaf Page"></a>B+Tree Leaf Page</h3><ul><li><p>The Leaf Page stores an ordered <strong>m</strong> key entries and <strong>m</strong> value entries. In your implementation, value should only be 64-bit record_id that is used to locate where actual tuples are stored, see <code>RID</code> class defined under in <code>src/include/common/rid.h</code>. Leaf pages have the same restriction on the number of key&#x2F;value pairs as Internal pages, and should follow the same operations of merge, redistribute and split.</p><p>You must implement your Internal Page in the designated files. You are only allowed to modify the header file (<code>src/include/storage/page/b_plus_tree_leaf_page.h</code>) and its corresponding source file (<code>src/storage/page/b_plus_tree_leaf_page.cpp</code>).</p></li><li><p>叶子结点存储m个有序的key和m个真实的值，在我们的实现中这个value应该是record_id，我们可以通过record_id去定位一个真实的tuples存储的位置</p></li></ul><ol><li>为什么internal page的maxminSize是(max_size_ + 1)&#x2F;2?</li></ol><h2 id="muduo项目介绍"><a href="#muduo项目介绍" class="headerlink" title="muduo项目介绍"></a>muduo项目介绍</h2><p>本项目是参考 muduo 实现的基于 Reactor 模型的多线程网络库。使用 C++ 11 编写去除 muduo 对 boost 的依赖，内部实现了一个小型的 HTTP 服务器，可支持 GET 请求和静态资源的访问，且附有异步日志监控服务端情况。</p><p>项目已经实现了 Channel 模块、Poller 模块、事件循环模块、HTTP 模块、定时器模块、异步日志模块、内存池模块、数据库连接池模块。</p><h2 id="项目特点"><a href="#项目特点" class="headerlink" title="项目特点"></a>项目特点</h2><ul><li>底层使用 Epoll + LT 模式的 I&#x2F;O 复用模型，并且结合非阻塞 I&#x2F;O 实现主从 Reactor 模型。</li><li>采用「one loop per thread」线程模型，并向上封装线程池避免线程创建和销毁带来的性能开销。</li><li>采用 eventfd 作为事件通知描述符，方便高效派发事件到其他线程执行异步任务。</li><li>基于自实现的双缓冲区实现异步日志，由后端线程负责定时向磁盘写入前端日志信息，避免数据落盘时阻塞网络服务。</li><li>基于红黑树实现定时器管理结构，内部使用 Linux 的 timerfd 通知到期任务，高效管理定时任务。</li><li>遵循 RAII 手法使用智能指针管理内存，减小内存泄露风险。</li><li>利用有限状态机解析 HTTP 请求报文。</li><li>参照 Nginx 实现了内存池模块，更好管理小块内存空间，减少内存碎片。</li><li>数据库连接池可以动态管理连接数量，及时生成或销毁连接，保证连接池性能。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>daily</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TiDB</title>
    <link href="/2023/06/12/TiDB/"/>
    <url>/2023/06/12/TiDB/</url>
    
    <content type="html"><![CDATA[<h1 id="TiDB"><a href="#TiDB" class="headerlink" title="TiDB"></a>TiDB</h1><h2 id="统计信息的维护："><a href="#统计信息的维护：" class="headerlink" title="统计信息的维护："></a>统计信息的维护：</h2><ol><li>取消了count-min sketch（q-error太大，对于低频的数据估算误差太大）<ul><li>代码中是FMSketch（使用末尾0来识别数据，并用2的最高频率次幂作为频率估计）</li></ul></li><li>增加了top-n，以提高点查询的准确率（取前1000的top N，且直方图中不包含这些top N）</li></ol><h2 id="统计信息的收集"><a href="#统计信息的收集" class="headerlink" title="统计信息的收集"></a>统计信息的收集</h2><p> TiDB 中，会对每个表具体的列构建一个等深直方图，区间查询的估算便是借助该直方图来进行。</p><ol><li>抽样方法的调整，从蓄水池转化为伯努利抽样</li><li>全表更新，mysql是部分页面的抽样（也可以开启快速分析，使得抽样范围缩小到1w条记录）</li><li>索引列的统计数据可以做增量更新</li></ol><h3 id="更新周期以及条件"><a href="#更新周期以及条件" class="headerlink" title="更新周期以及条件"></a>更新周期以及条件</h3><ol><li><p>在发生增加，删除以及修改语句时，TiDB 会自动更新表的总行数以及修改的行数。这些信息会定期持久化下来，更新的周期为 20 * stats-lease 。stats-lease 配置项的默认值是 3s，</p></li><li><p>当某个表 tbl 的修改行数与总行数的比值大于 tidb_auto_analyze_ratio，并且当前时间在 tidb_auto_analyze_start_time 和 tidb_auto_analyze_end_time 之间时，TiDB 会在后台执行 ANALYZE TABLE tbl 语句自动更新这个表的统计信息。</p></li></ol><p>idea：先建立单表估计模型以学习单表的分布，当处理连接查询时，FactorJoin首先依据已学习到的分布将查询建模为因子图（Factor Graph），而后使用变量消除（Variable Elimination，VE）算法进行推理。因只需单表的统计信息即可估计出多表连接的基数</p><blockquote><p>TiDB 架构介绍 <a href="https://karellincoln.github.io/2018/06/07/TiDB-analysis-application/#more">https://karellincoln.github.io/2018/06/07/TiDB-analysis-application/#more</a></p><p>关系型数据库内容与KV存储引擎的转换 <a href="https://segmentfault.com/a/1190000008343682">https://segmentfault.com/a/1190000008343682</a></p><p>TiDB对于KV的映射 <a href="https://docs.pingcap.com/zh/tidb/stable/tidb-computing">https://docs.pingcap.com/zh/tidb/stable/tidb-computing</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.12</title>
    <link href="/2023/06/12/6-12/"/>
    <url>/2023/06/12/6-12/</url>
    
    <content type="html"><![CDATA[<h1 id="6-12-学习笔记"><a href="#6-12-学习笔记" class="headerlink" title="6.12 学习笔记"></a>6.12 学习笔记</h1><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ol><li><p>二分查找，完整学习了左右侧边界的照法以及数组中含有重复数字时的处理方法；</p><p>左边界，返回left即可（最后判断left是否超出nums的size）</p><p>右边界，返回right即可（最后判断right是否小于0）</p></li><li><p>螺旋矩阵：四个边界，注意如何调整边界即可</p></li></ol><p>数组中的题目主要是使用双指针（快慢指针， 双向指针）</p><ul><li>注意指针的结束条件，边界条件</li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="多版本并发控制"><a href="#多版本并发控制" class="headerlink" title="多版本并发控制"></a>多版本并发控制</h3><p>二阶段锁更新数据时阻塞其他事务，MVCC通过留下数据的历史版本，让事务读取数据的历史版本</p><p>使用时间戳来记录版本号， 时间旅行</p><ul><li>通过version chain遍历各个版本的数据</li></ul><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><ol><li><p>undo：撤销的时候做undo&#x2F; delta storage</p><p>removing the effects of an incomplete or aborted txn</p><p>mysql使用undo log实现mvcc，回退日志时也是使用undo log</p></li><li><p>redo：重做（恢复的时候做redo）</p><p>re-instating the effects of a committed txn for durability</p></li></ol><p><strong>用以上两个操作实现事物的安全性以及原子性</strong></p><p><img src="/2023/06/12/6-12/image-20230612162417149.png" alt="image-20230612162417149"></p><p>steal policy：刷脏页时不管是否committed，直接刷入disk（steal no-steal）【因为page太大，数据太小，一个page上可能有多个txn的数据】</p><p>force policy：</p><p>steal&#x2F;no-steal:<br>      是否允许一个uncommitted的事务中的数据被更新到磁盘；如果是steal策略，那么此时磁盘上就可能包含uncommitted的数据，<strong>因此系统需要记录undo log，以防事务abort时进行回滚（roll-back）</strong>。如果是no steal策略，就表示磁盘上不会存在uncommitted数据，因此无需回滚操作，也就无需记录undo log。</p><p>force&#x2F;no-force:<br>      force策略表示事务在committed之后必须将所有更新立刻持久化到磁盘，这样会导致磁盘发生很多小的写操作（更可能是随机写）。no-force表示事务在committed之后可以不立即持久化到磁盘， 这样可以缓存很多的更新批量持久化到磁盘，这样可以降低磁盘操作次数（提升顺序写），但是如果committed之后发生crash，那么此时已经committed的事务数据将会丢失（因为还没有持久化到磁盘），因此系统需要记录redo log，在系统重启时候进行前滚（roll-forward）操作。   </p><p> steal&#x2F;no-steal主要决定了磁盘上是否会包含uncommitted的数据。force&#x2F;no-force主要决定了磁盘上是否会不包含已经committed的数据。</p><p>现在DBMS常用的是steal&#x2F;no-force策略，因此一般都需要记录redo log和undo log。这样可以获得较快的运行时性能，代价就是在数据库恢复（recovery）的时候需要做很多的事情，增大了系统重启的时间。</p><ul><li><p>no-steal + force（shadow paging）</p><p>相当于一个事务只负责一个事务的数据，写入disk时会创建一个自己修改的副本并写入</p><p>无需undo也无需redo（每次都把数据写入磁盘所以不需要redo）</p><p>因为没有undo，所以写入数据量必须小于内存</p></li><li><p>steal + no force（Write-AHEAD log 预写日志）</p><p>将数据写入disk之前，先把wal写入disk</p><p>单独创建一个文件保留事务对数据的修改，log file</p></li></ul><h4 id="WAL-Protocol"><a href="#WAL-Protocol" class="headerlink" title="WAL Protocol"></a>WAL Protocol</h4><ol><li>Information</li></ol><ul><li>txn_id</li><li>Obj_id</li><li>Before value(for undo)</li><li>after value(for redo)</li></ul><ol start="2"><li>Implement</li></ol><p> Group committed </p><h4 id="CheckPoint"><a href="#CheckPoint" class="headerlink" title="CheckPoint"></a>CheckPoint</h4><p>到了checkpoint，把所有未写入disk的日志和数据都写入disk，并记录checkpoint </p><p>通过checkpoint点判断事务是否需要执行undo or redo</p><ul><li><p>如果没有checkpoint，那么需要把所有committed的事务执行redo，未committed的事务执行undo</p><p>checkpoint前已经提交的事务，无需对其进行执行redo</p><p>WAL中显示已经提交的事务表明用户已经接收到写入成功，因此我们需要redo</p><p>WAL中未提交的事务只需要undo即可，因为本身用户也没有收到提交的响应</p></li></ul><p><img src="/2023/06/12/6-12/image-20230612173452531.png" alt="image-20230612173452531"></p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p><img src="/2023/06/12/6-12/image-20230612174111674.png" alt="image-20230612174111674"></p><h2 id="Financial-Statement"><a href="#Financial-Statement" class="headerlink" title="Financial Statement"></a>Financial Statement</h2><p>课程目的：怎么生成以下四张表？怎么读懂财报怎么看四张表</p><ul><li>Income Statement 收入表<ul><li>Revenue （营收）</li><li>expense （支出）</li></ul></li><li>Statement of Changes in Equality </li><li>Balance Sheet Asset &#x3D; Liabilities  + SE(股东权益)</li><li>Cash Flow（现金流）</li></ul><hr><ol><li>Financial Accounting(外部人员看)</li><li>Management Accounting（内部人员看）</li></ol><hr><p>LLC有限责任公司&#x2F;LLP有限责任伙伴</p><ol><li>single owner</li><li>Partnership： 2+ 对公司权益划分，每一个partner有一部分权益</li></ol><p>Limited Liability Company 公司和个人是分开的。个人财产与公司无关</p><p>公司破产清算，无需关注自己银行账户</p><ul><li>Income Statement<ul><li>Revenue</li><li>Expense</li></ul></li></ul><p>Fiscal Year 人为规定</p><ul><li>statement of changes Equity<ul><li>Returned Earing</li><li>Dividend</li><li>Common Share</li></ul></li><li>Balance Sheet</li></ul><h2 id="杂七杂八"><a href="#杂七杂八" class="headerlink" title="杂七杂八"></a>杂七杂八</h2><h3 id="MySQL的MVCC是怎么实现的"><a href="#MySQL的MVCC是怎么实现的" class="headerlink" title="MySQL的MVCC是怎么实现的"></a>MySQL的MVCC是怎么实现的</h3><h3 id="主备复制"><a href="#主备复制" class="headerlink" title="主备复制"></a>主备复制</h3><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3>]]></content>
    
    
    
    <tags>
      
      <tag>daliy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tools</title>
    <link href="/2023/05/22/Tools/"/>
    <url>/2023/05/22/Tools/</url>
    
    <content type="html"><![CDATA[<h1 id="Tmux"><a href="#Tmux" class="headerlink" title="Tmux"></a>Tmux</h1><p>使用tmux在服务器后台运行程序</p><ol><li>创建一个会话，并进入该会话</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tmux new-session -s mysession<br></code></pre></td></tr></table></figure><ol start="2"><li>运行对应程序</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python my_program.py<br></code></pre></td></tr></table></figure><ol start="3"><li><p>退出当前会话，先按下***<u>ctrl + b</u>***再按d，即可退出当前会话</p></li><li><p>重新连接该会话</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tmux attach -t mysession<br></code></pre></td></tr></table></figure><h2 id="mac-脚本程序执行时间测试"><a href="#mac-脚本程序执行时间测试" class="headerlink" title="mac 脚本程序执行时间测试"></a>mac 脚本程序执行时间测试</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">获取脚本开始时间（精确到毫秒）</span><br>start_time=$(ruby -e &#x27;puts (Time.now.to_f * 1000).to_i&#x27;)<br><span class="hljs-meta prompt_"># </span><span class="language-bash">循环一万次</span><br>for ((i=1; i&lt;=10; i++)); do<br><span class="hljs-meta prompt_">  # </span><span class="language-bash">使用curl访问指定URL并获取内容</span><br>  response=$(curl -s http://localhost:8091/task/do)<br><span class="hljs-meta prompt_">  # </span><span class="language-bash">打印获取到的内容</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;请求 <span class="hljs-variable">$i</span>: <span class="hljs-variable">$response</span>&quot;</span></span><br>done<br><span class="hljs-meta prompt_"># </span><span class="language-bash">获取脚本结束时间（精确到毫秒）</span><br>end_time=$(ruby -e &#x27;puts (Time.now.to_f * 1000).to_i&#x27;)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">计算执行时间（精确到毫秒）</span><br>execution_time=$((end_time - start_time))<br><span class="hljs-meta prompt_"># </span><span class="language-bash">打印执行时间</span><br>echo &quot;脚本执行时间为 $execution_time 毫秒&quot;<br></code></pre></td></tr></table></figure><p>这条命令使用 Ruby 编程语言来执行一个简单的脚本，并输出当前时间的毫秒级别时间戳。</p><p>具体来说，这个命令执行以下操作：</p><ol><li><code>ruby -e</code>：这部分表示在命令行中运行 Ruby 解释器，并且 <code>-e</code> 选项后面跟着一段 Ruby 代码。</li><li><code>&#39;puts (Time.now.to_f * 1000).to_i&#39;</code>：这是 Ruby 代码段，它执行以下操作：<ul><li><code>Time.now</code> 获取当前时间，包括日期和时间。</li><li><code>.to_f</code> 将时间转换为浮点数，表示从某个基准时间以来的秒数，包括小数部分。</li><li><code>* 1000</code> 将秒数转换为毫秒，因为 1 秒 &#x3D; 1000 毫秒。</li><li><code>.to_i</code> 将浮点数转换为整数，以获得毫秒级别的时间戳。</li><li><code>puts</code> 命令用于将时间戳打印到标准输出（终端）。</li></ul></li></ol><p>因此，这个命令会在终端中打印出当前时间的毫秒级别时间戳，表示从某个基准时间以来的毫秒数。</p><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./profiler.sh -d 20 -f 87484.html 87484</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">jps</span><br>87394<br>92580 Jps<br>87483 Launcher<br>87452 RemoteMavenServer36<br>87484 Main<br></code></pre></td></tr></table></figure><p><code>jps</code> 命令用于列出 Java 进程的信息，显示每个 Java 进程的进程 ID（PID）以及 Java 进程的主类名。</p><p>在你提供的输出中：</p><ul><li><code>87394</code> 是一个 Java 进程的 PID，但由于没有指定主类名，因此无法确定是哪个 Java 进程。</li><li><code>92580</code> 是 <code>jps</code> 命令本身的 PID，<code>Jps</code> 是 Java 进程的监视工具。</li><li><code>87483</code> 的主类名是 <code>Launcher</code>，这可能是某个 Java 应用程序的启动器。</li><li><code>87452</code> 的主类名是 <code>RemoteMavenServer36</code>，这可能是一个与 Maven 相关的 Java 进程。</li><li><code>87484</code> 的主类名是 <code>Main</code>，这可能是另一个 Java 应用程序的主类。</li></ul><blockquote><p> async-profiler Java 程序性能分析 <a href="https://www.wdbyte.com/2019/12/async-profiler/">https://www.wdbyte.com/2019/12/async-profiler/</a></p></blockquote><h1 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h1><ol><li><p>设置项目名称</p><p>PROJECT (DEMO)</p><p>设置项目名称为DEMO</p></li><li><p>设置头文件或者项目文件目录</p><p>include_directories(${CMAKE_CURRENT_LIST_DIR}&#x2F;include)</p><p>${CMAKE_CURRENT_LIST_DIR} 表示CMakelist.txt所在位置</p></li><li><p>将项目源文件添加至变量中</p><p>aux_source_directory(.&#x2F;src SRC) </p><p>将.&#x2F;src 下的所有源文件递归的加入SRC变量中</p></li><li><p>构造可执行文件</p><p>ADD_EXECUTABLE(${PROJECT_NAME} ${SRC})</p><p>将变量SRC内的源文件构建成可执行文件，并命名为开头设置的project_name</p></li></ol><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">PROJECT</span> (DEMO)<br><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.10</span>)<br><br><span class="hljs-keyword">SET</span>(CMAKE_CXX_STANDARD <span class="hljs-number">14</span>)<br><br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span>/<span class="hljs-keyword">include</span>)<br><br><span class="hljs-comment"># link_directories($&#123;CMAKE_CURRENT_LIST_DIR&#125;/lib)</span><br><br><span class="hljs-keyword">aux_source_directory</span>(./src SRC)<br><br><span class="hljs-comment"># 把所有.cpp的main函数都构建起来</span><br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">file</span> <span class="hljs-variable">$&#123;files&#125;</span>)<br><span class="hljs-keyword">string</span>(REGEX REPLACE <span class="hljs-string">&quot;.+/(.+)\\..*&quot;</span> <span class="hljs-string">&quot;\\1&quot;</span> exe <span class="hljs-variable">$&#123;file&#125;</span>)<br><span class="hljs-keyword">add_executable</span> (<span class="hljs-variable">$&#123;exe&#125;</span> <span class="hljs-variable">$&#123;file&#125;</span>)<br><span class="hljs-keyword">message</span> (\ \ \ \ --\ src/<span class="hljs-variable">$&#123;exe&#125;</span>.cpp\ will\ be\ compiled\ to\ bin/<span class="hljs-variable">$&#123;exe&#125;</span>)<br><span class="hljs-keyword">endforeach</span> ()<br><br><span class="hljs-comment"># ADD_EXECUTABLE($&#123;PROJECT_NAME&#125; $&#123;SRC&#125;)</span><br><br><span class="hljs-comment"># target_link_libraries($&#123;PROJECT_NAME&#125; util)</span><br><br><span class="hljs-comment"># set(CMAKE_CXX_COMPILER      &quot;clang++&quot; )         # 显示指定使用的C++编译器</span><br><br><span class="hljs-comment"># set(CMAKE_CXX_FLAGS   &quot;-std=c++11&quot;)             # c++11</span><br><br><span class="hljs-comment"># set(CMAKE_CXX_FLAGS   &quot;-g&quot;)                     # 调试信息</span><br><br><span class="hljs-comment"># set(CMAKE_CXX_FLAGS   &quot;-Wall&quot;)                  # 开启所有警告</span><br><br><span class="hljs-comment"># set(CMAKE_CXX_FLAGS_DEBUG   &quot;-O0&quot; )             # 调试包不优化</span><br><br><span class="hljs-comment"># set(CMAKE_CXX_FLAGS_RELEASE &quot;-O2 -DNDEBUG &quot; )   # release包优化</span><br></code></pre></td></tr></table></figure><blockquote><p>[CMake 构建测试用例 ]<a href="https://blog.csdn.net/weixin_39766005/article/details/122686185">https://blog.csdn.net/weixin_39766005/article/details/122686185</a></p></blockquote><h1 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a><a href="https://linux265.com/course/vim-intro.html">Vim</a></h1><h2 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h2><ul><li><p>行内的向后移动： <strong>w</strong></p></li><li><p>行内的向前移动：<strong>b</strong> (e 可以移动到词尾)</p></li><li><p>移动到当前行尾：**$**</p></li><li><p>移动到当前行首：<strong>0</strong></p></li><li><p>移动到屏幕顶部：<strong>H</strong></p></li><li><p>移动到屏幕末尾：<strong>L</strong></p></li><li><p>移动到屏幕中间：<strong>M</strong></p></li><li><p>删除至行尾：<strong>D</strong></p></li><li><p>跳转到某一行：<strong>n</strong></p></li><li><p>移动到文件尾部：<strong>gg</strong></p></li><li><p>移动到文件首部：<strong>G</strong></p></li></ul><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p>Git 中的对象可以是 blob、tree或commit</p><p>Git 在储存数据时，所有的对象都会基于它们的 <strong>SHA-1哈希</strong> 进行寻址。所有的快照都可以通过它们的 SHA-1 哈希值来标记。针对这一问题，Git 的解决方法是给这些哈希值赋予人类可读的名字，也就是引用**(references)**。引用是指向提交的指针。与对象不同的是，它是可变的(引用可以被更新，指向新的提交)。例如，master 引用通常会指向主分支的最新一次提交。</p><p>HEAD branch都是指向这个commit的<strong>引用</strong>，而commit本质就是一个hash</p><h2 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h2><p>HEAD 指向当前的commit，每当执行git commit操作时，会生成一个新的commit对象，并移动HEAD指针，若HEAD指向一个branch，则带动branch一起向前移动</p><h2 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 代表把HEAD移动到another上</span></span><br>git rebase anthoer -i<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 代表把main移动到another上</span></span><br>git rebase another main -i<br>git rebase target_commit ready_to_move_commit -i<br></code></pre></td></tr></table></figure><p>当你知道你所需要的提交记录（<strong>并且</strong>还知道这些提交记录的哈希值）时, 用 cherry-pick 再好不过了 —— 没有比这更简单的方式了。</p><p>但是如果你不清楚你想要的提交记录的哈希值呢? 幸好 Git 帮你想到了这一点, 我们可以利用交互式的 rebase —— 如果你想从一系列的提交记录中找到想要的记录, 这就是最好的方法了</p><p>当 rebase UI界面打开时, 你能做3件事:</p><ul><li>调整提交记录的顺序（通过鼠标拖放来完成）</li><li>删除你不想要的提交（通过切换 <code>pick</code> 的状态来完成，关闭就意味着你不想要这个提交记录）</li><li>合并提交</li></ul><p><strong>变基操作：</strong></p><ol><li><p>可以把当前HEAD所指向的commit变为rebase指定的commit <strong>&#x2F;&#x2F; 代表将HEAD移动到target git rebase target_commit</strong> </p></li><li><p>也可以用来把父commit指向继承的commit</p></li></ol><p><strong>交互式rebase</strong></p><p>-i : 可以指定以交互形式在当前节点提交，放弃某些提交</p><h2 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h2><p>要在心里牢记 cherry-pick 可以将提交树上任何地方的提交记录取过来追加到 HEAD 上</p><p>如果你想将一些提交复制到当前所在的位置（<code>HEAD</code>）下面的话， Cherry-pick 是最直接的方式了。我个人非常喜欢 <code>cherry-pick</code>，因为它特别简单。</p><h2 id="git-reset-git-revert"><a href="#git-reset-git-revert" class="headerlink" title="git reset &amp;&amp; git revert"></a>git reset &amp;&amp; git revert</h2><h2 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h2><p>由于先抓取更新再合并到本地分支这个流程很常用，因此 Git 提供了一个专门的命令来完成这两个操作。它就是我们要讲的 <code>git pull</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git pull == git fetch &amp;&amp; git merge</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git pull --rebase == git fetch &amp;&amp; git rebase</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">本地创建foo分支，并将远端main分支下的内容拉入foo</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git pull origin main:foo</span> <br></code></pre></td></tr></table></figure><h3 id="git-fetch-做了些什么"><a href="#git-fetch-做了些什么" class="headerlink" title="git fetch 做了些什么"></a>git fetch 做了些什么</h3><p><code>git fetch</code> 完成了仅有的但是很重要的两步:</p><ul><li>从远程仓库下载本地仓库中缺失的提交记录</li><li>更新远程分支指针(如 <code>o/main</code>)</li></ul><p><code>git fetch</code> 实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态。</p><p>远程分支反映了远程仓库在你<strong>最后一次与它通信时</strong>的状态，<code>git fetch</code> 就是你与远程仓库通信的方式了！希望我说的够明白了，你已经了解 <code>git fetch</code> 与远程分支之间的关系了吧。</p><p><code>git fetch</code> 通常通过互联网（使用 <code>http://</code> 或 <code>git://</code> 协议) 与远程仓库通信。</p><p><code>&lt;place&gt;</code> 参数</p><p>如果你像如下命令这样为 git fetch 设置 的话：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ git fetch origin foo<br></code></pre></td></tr></table></figure><p>Git 会到远程仓库的 <code>foo</code> 分支上，然后获取所有本地不存在的提交，放到本地的 <code>o/foo</code> 上。</p><h3 id="git-fetch-不会做的事"><a href="#git-fetch-不会做的事" class="headerlink" title="git fetch 不会做的事"></a>git fetch 不会做的事</h3><p><code>git fetch</code> 并不会改变你本地仓库的状态。它不会更新你的 <code>main</code> 分支，也不会修改你磁盘上的文件。</p><p>理解这一点很重要，因为许多开发人员误以为执行了 <code>git fetch</code> 以后，他们本地仓库就与远程仓库同步了。它可能已经将进行这一操作所需的所有数据都下载了下来，但是<strong>并没有</strong>修改你本地的文件。我们在后面的课程中将会讲解能完成该操作的命令 :D</p><p><strong>所以, 你可以将 <code>git fetch</code> 的理解为单纯的下载操作。</strong></p><h2 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ git push &lt;remote&gt; &lt;place&gt;<br>$ git push origin main<br></code></pre></td></tr></table></figure><p>把这个命令翻译过来就是：</p><p><em>切到本地仓库中的“main”分支，获取所有的提交，再到远程仓库“origin”中找到“main”分支，将远程仓库中没有的提交记录都添加上去，搞定之后告诉我。</em></p><p>我们通过“place”参数来告诉 Git 提交记录来自于 main, 要推送到远程仓库中的 main。它实际就是要同步的两个仓库的位置。</p><p>需要注意的是，因为我们通过指定参数告诉了 Git 所有它需要的信息, 所以它就忽略了我们所切换分支的属性！</p><h3 id="冲突处理-线性提交"><a href="#冲突处理-线性提交" class="headerlink" title="冲突处理&amp;线性提交"></a>冲突处理&amp;线性提交</h3>]]></content>
    
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>15445-lab2</title>
    <link href="/2023/05/14/15445-lab2/"/>
    <url>/2023/05/14/15445-lab2/</url>
    
    <content type="html"><![CDATA[<h1 id="BPlusTree-Index"><a href="#BPlusTree-Index" class="headerlink" title="BPlusTree Index"></a>BPlusTree Index</h1><p>15445中使用MappingType类型的数组 <code>array_ </code>描述b+的node，MappingType则表示了一个kv对，internal node中的value是page_id而leaf_node的value是record_id。</p><p>这些kv对是按照key的顺序有序存储在array_中</p><h2 id="Page-Structure"><a href="#Page-Structure" class="headerlink" title="Page Structure"></a>Page Structure</h2><ul><li>Bplus Page</li></ul><p>作为internal page和leaf page的父类，提供了一些二者共同需要使用的函数，参数传递时也可以借助bplus tree page这种类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">IsLeafPage</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> -&gt; <span class="hljs-type">bool</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">IsRootPage</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> -&gt; <span class="hljs-type">bool</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetPageType</span><span class="hljs-params">(IndexPageType page_type)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">GetSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> -&gt; <span class="hljs-type">int</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetSize</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">IncreaseSize</span><span class="hljs-params">(<span class="hljs-type">int</span> amount)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">GetMaxSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> -&gt; <span class="hljs-type">int</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetMaxSize</span><span class="hljs-params">(<span class="hljs-type">int</span> max_size)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">GetMinSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> -&gt; <span class="hljs-type">int</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">GetParentPageId</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> -&gt; <span class="hljs-type">page_id_t</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetParentPageId</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> parent_page_id)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">GetPageId</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> -&gt; <span class="hljs-type">page_id_t</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetPageId</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> page_id)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>Internal Page</li></ul><p>内部节点，存储其他节点page的page_id；15445中规定内部节点用来存储kv对的array数组中第一个元素的key是invalid的，这就导致了内部节点的max_size为m，则key的数量为m - 1, value的数量为m</p><ul><li>Leaf Page</li></ul><p>叶子结点，用来存储对应key在某个表中的rid</p><h2 id="Point-Search"><a href="#Point-Search" class="headerlink" title="Point Search"></a>Point Search</h2><h3 id="RoadMap"><a href="#RoadMap" class="headerlink" title="RoadMap"></a>RoadMap</h3><ul><li>如何对b+树进行点查询？</li></ul><p>首先我们来思考如何在有序二叉树上进行查找对应节点，我们第一反应就是使用递归的中序遍历，target大于当前节点的value则向right child移动，若target小于当前节点的value则向left child移动，若等于则返回当前节点。</p><p>在b+树中，我们真实的结果都存储于leaf node中，因此我们第一步就需要找到符合包含需求key的leaf node page</p><ul><li>如何找到leaf node page？</li></ul><p>internal page中的key是有序排列的，因此我们只需要在当前internal page的array中找到第一个大于等于target的key即可，此后只需要根据这个key对应的page_id中进入下一个page，随后重复上述过程。一旦我们进入leaf page，则表示我们找到了target可能存在的page。</p><ul><li>在所有的B Plus Tree Node Page上，我们可以使用顺序查找，也可以使用二分查找，我们只需找到第一个大于等于target key的index即可</li></ul><h3 id="Detail"><a href="#Detail" class="headerlink" title="Detail"></a>Detail</h3><h2 id="Insertion"><a href="#Insertion" class="headerlink" title="Insertion"></a>Insertion</h2><h2 id="Deletion"><a href="#Deletion" class="headerlink" title="Deletion"></a>Deletion</h2><blockquote><p>Ref :</p><p>参考博客： <a href="https://blog.eleven.wiki/posts/cmu15-445-project2-b+tree-index/#task1-btree-pages">https://blog.eleven.wiki/posts/cmu15-445-project2-b+tree-index/#task1-btree-pages</a></p><p>可视化B+树：<a href="https://15445.courses.cs.cmu.edu/fall2022/bpt-printer/">https://15445.courses.cs.cmu.edu/fall2022/bpt-printer/</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>CMU15445</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TVM</title>
    <link href="/2023/04/07/TVM/"/>
    <url>/2023/04/07/TVM/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>MLC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMU-15445</title>
    <link href="/2023/04/04/15445/"/>
    <url>/2023/04/04/15445/</url>
    
    <content type="html"><![CDATA[<h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><h1 id="Hash-Table"><a href="#Hash-Table" class="headerlink" title="Hash Table"></a>Hash Table</h1><p>应用场景：</p><ul><li>internal-meta data</li><li>core data storage redis</li><li>temporary data structures</li><li>Table indexs</li></ul><p>Design decisions</p><ul><li>Data Organization</li><li>Concurrency</li></ul><h2 id="hash-function"><a href="#hash-function" class="headerlink" title="hash function"></a>hash function</h2><ul><li><p>开放地址</p></li><li><p>cuckoo hashing</p></li><li><p>robin hood  hasing</p></li><li><p>chained hasing 拉链</p></li></ul><img src="/2023/04/04/15445/image-20230318204918510.png" alt="image-20230318204918510.png" style="zoom:35%;"><h1 id="B-树索引并发"><a href="#B-树索引并发" class="headerlink" title="B+树索引并发"></a>B+树索引并发</h1><p>本章重点介绍Latch而不是Lock</p><h3 id="Latch的实现方法"><a href="#Latch的实现方法" class="headerlink" title="Latch的实现方法"></a>Latch的实现方法</h3><ul><li>Blocking OS Mutex<br>翻译成中文就是，“阻塞式的操作系统互斥锁”，它比较容易使用，因为这是操作系统原生支持的，但不能应对大规模并发竞争的场面，比如说C++的<code>std::mutex</code>就属于这种锁，具体的实现原理和xv6的<code>sleeplock</code>差不多：用最基本的自旋锁保护一个条件变量，获取该锁时检查这个条件变量，如果满足条件则修改条件变量从而获得该互斥锁，否则进入睡眠状态，直到该互斥锁被释放时条件变量被修改回来，释放互斥锁的线程唤醒已经睡眠的线程（详情参考xv6源码）</li></ul><p>互斥锁和自旋锁相比，争用锁的时候，得不到锁的线程不会一直自旋，浪费CPU资源，而是会进入睡眠，但是相应的睡眠与后续的唤醒操作由于会修改线程的状态，因此也有一定的开销</p><ul><li>Test-and-Set Spin Latch<br>这个简单来说，就是自旋锁，好处是可以通过一个指令就能获取&#x2F;释放锁，实现简单，但也不能应对大规模的并发竞争，而且对缓存和操作系统不友好;  实现方式和xv6的<code>spinlock</code>差不多</li><li>Reader-Writer Latches<br>其实就是前面一开始提到的读写锁，读写锁底层是基于自旋锁来实现的，并且设有等待队列，为了避免想要获取写锁的线程等待太久（即避免starvation），会限制在同一时刻能够获取写锁的线程的数量：自从有线程开始排队等待获取写锁之后，后面想要获取读锁的线程都要开始等待，直到想获取写锁的线程成功获取写锁并完成相关操作，释放写锁为止。</li></ul><h1 id="排序和聚集"><a href="#排序和聚集" class="headerlink" title="排序和聚集"></a>排序和聚集</h1><ol><li>排序方法：外部归并排序</li><li>聚集：外部哈希聚集（也可以用排序）</li></ol><h2 id="TopK-Sort"><a href="#TopK-Sort" class="headerlink" title="TopK Sort"></a>TopK Sort</h2><p>查询数据表中最大的k个值时，我们通过维持一个大小为k的小根堆？</p><img src="/2023/04/04/15445/image-20230327182110475.png" alt="image-20230327182110475" style="zoom:50%;"><h2 id="External-Merge-Sort"><a href="#External-Merge-Sort" class="headerlink" title="External Merge Sort"></a>External Merge Sort</h2><p>时间复杂度：logN</p><p>外部排序的流程：</p><ol><li>先将数据表切分为N个page，并将每一个page内部排好顺序</li><li>在缓冲区开辟至少三个page的空间（两个加载未排序的page，一个用来存储中间结果，中间结果写满后落盘）</li><li>重复第二步</li></ol><img src="/2023/04/04/15445/image-20230327182221374.png" alt="image-20230327182221374" style="zoom:50%;"><h2 id="聚集"><a href="#聚集" class="headerlink" title="聚集"></a>聚集</h2><ul><li>排序聚集（order by）</li><li>哈希聚集（不需要对数据进行排序时， GROUPE BY， distinct）</li></ul><h3 id="外部哈希聚集"><a href="#外部哈希聚集" class="headerlink" title="外部哈希聚集"></a>外部哈希聚集</h3><p>当数据过大无法一次加载进内存时，我们通常采用外部哈希的方法对数据进行聚集。</p><img src="/2023/04/04/15445/image-20230327183352927.png" alt="image-20230327183352927" style="zoom:50%;"><img src="/2023/04/04/15445/image-20230327183529986.png" alt="image-20230327183529986" style="zoom:40%;"><img src="/2023/04/04/15445/image-20230327183738335.png" alt="image-20230327183738335" style="zoom:55%;"><img src="/2023/04/04/15445/image-20230327183801276.png" alt="image-20230327183801276" style="zoom:40%;"><h3 id="连表操作"><a href="#连表操作" class="headerlink" title="连表操作"></a>连表操作</h3><img src="/2023/04/04/15445/image-20230326103631213.png" alt="image-20230326103631213" style="zoom:50%;"><p>我个人以为的执行流程：</p><ol><li>两数据表做笛卡尔积，生成中间表</li><li>执行on，删除不符合条件的结果</li><li>添加外部行，left join或者right join</li><li>执行where进行进行筛选</li><li>select出相应的结果</li></ol><ul><li><p>join的方法：hash join、radix join</p></li><li><p>hash join</p><ul><li>不分区的hash，首先对小表遍历，并对每一个key进行hash计算，将结果存入hash表中。随后在对大表进行遍历，对每一个值进行计算并和hash表中的结果进行匹配</li><li>分区hash 先将大表拆分成多个小表，每个表进行hash计算，将结果写入一个hash的bucket中，写入时要加锁。最后用大表中并行计算其中元素的hash，去bucket中匹配</li></ul></li></ul><h3 id="连表操作-1"><a href="#连表操作-1" class="headerlink" title="连表操作"></a>连表操作</h3><h4 id="1-stupid"><a href="#1-stupid" class="headerlink" title="1. stupid"></a>1. stupid</h4><img src="/2023/04/04/15445/image-20230326104455875.png" alt="image-20230326104455875" style="zoom:50%;"><p>缓存有可能失效，不断的替换缓存</p><h5 id="优化策略："><a href="#优化策略：" class="headerlink" title="优化策略："></a>优化策略：</h5><ol><li>固定驱动表，不断io inner table</li></ol><p>留一个page做output，一个给inner table，B-2给outer table</p><p>尽量缓存外表，内表什么情况都要面临缓存重刷的问题</p><img src="/2023/04/04/15445/image-20230326105513361.png" alt="image-20230326105513361" style="zoom:50%;"><ol start="2"><li>内表设置索引</li></ol><h4 id="2-merge-join"><a href="#2-merge-join" class="headerlink" title="2. merge join"></a>2. merge join</h4><p>什么时候最差？比较的都一样，都为100，可能回退</p><p>最好是两表已经排好序</p><p><img src="/2023/04/04/15445/image-20230326110539085.png" alt="image-20230326110539085"></p><h4 id="3-hash-join"><a href="#3-hash-join" class="headerlink" title="3. hash join"></a>3. hash join</h4><ul><li><p>build hash table</p></li><li><p>probe</p></li></ul><p><strong>布隆过滤器</strong></p><p>grace hash join</p><img src="/2023/04/04/15445/image-20230326112616444.png" alt="image-20230326112616444" style="zoom:45%;"><p><strong>大表怎么做join？</strong></p><p>对数据进行分区；对全局的hash table做分区；</p><img src="/2023/04/04/15445/image-20230326112856686.png" alt="image-20230326112856686" style="zoom:40%;"><img src="/2023/04/04/15445/image-20230326113606448.png" alt="image-20230326113606448" style="zoom:50%;"><p>并发算子的实现有两大思路：第一个思路是多个线程去操纵集中的全部数据（比如说多个线程同时读一个表），第二个思路是把集中的数据切开，把每部分分给相应的线程，使得线程可以在本地处理</p><blockquote><p>Main-Memory Hash Joins on Multi-Core CPUs&#x2F; Tuning to the Underlying Hardware 论文解读<a href="https://zhuanlan.zhihu.com/p/616540684">https://zhuanlan.zhihu.com/p/616540684</a></p></blockquote><h1 id="并发控制理论"><a href="#并发控制理论" class="headerlink" title="并发控制理论"></a>并发控制理论</h1><ul><li>motivation</li></ul><p>how to avoid race condition? ( change the same record in a table at the same time ) <strong>lost update</strong></p><p>what is the correct database state? <strong>concurrency control and recovery</strong></p><ul><li>transcation</li></ul><p>is the exection of a swquence of one or more operations on adatabse to perform some higher-level function</p><p>basic unit of data base</p><h3 id="数据库中存在的四种问题"><a href="#数据库中存在的四种问题" class="headerlink" title="数据库中存在的四种问题"></a>数据库中存在的四种问题</h3><ol><li><p>脏读：读到了其他事务未commit的数据（写后读）</p></li><li><p>不可重复读：同一个事务中，两次读出的数据不一致（读后写）</p></li><li><p>幻读：同一个事务中，第二次读出的数据量和第一次的不一致（读后写）</p></li><li><p>更新丢失：insert or update lost</p></li></ol><h3 id="数据的四种隔离状态"><a href="#数据的四种隔离状态" class="headerlink" title="数据的四种隔离状态"></a>数据的四种隔离状态</h3><ol><li>Read Uncommitted:</li><li>Read Commited:</li><li>Read Repeatale:</li><li>Serialize :</li></ol><h3 id="锁的种类"><a href="#锁的种类" class="headerlink" title="锁的种类"></a>锁的种类</h3><p>本章节着重讨论lock</p><img src="/2023/04/04/15445/image-20230403211905717.png" alt="image-20230403211905717" style="zoom:50%;"><h2 id="2Phase-Locking"><a href="#2Phase-Locking" class="headerlink" title="2Phase Locking"></a>2Phase Locking</h2><p>Two-phase locking (2PL) is a concurrency control protocol that determines whether a txn can access an object in the database at runtime.</p><p> The protocol does not need to know all the queries that a txn will execute ahead of time.</p><ul><li>二阶段锁：数据库的事务分为两个阶段，第一个阶段是growing获取锁的阶段，只有当获取到本次事务所需要的全部锁资源时才会结束该阶段。第二个阶段是shrinking阶段，即释放锁资源的阶段，这个阶段只允许释放锁资源</li></ul><ol><li>普通的2PL会在对修改数据时加X锁并在事务结束时释放；在读取数据时加S锁，并在读取结束后释放</li><li>stronger strict 2PL会在事务结束时释放所有锁资源</li></ol><h3 id="2PL"><a href="#2PL" class="headerlink" title="2PL"></a>2PL</h3><p>2PL on its own is sufficient to guarantee conflict serializability because it generates schedules whose precedence graph is acyclic. </p><p>2PL本身就足以保证冲突的可序列化，因为它产生的时间表的优先级图是无环的。</p><img src="/2023/04/04/15445/image-20230403212310101.png" alt="image-20230403212310101" style="zoom:50%;"><h4 id="Dirty-read"><a href="#Dirty-read" class="headerlink" title="Dirty read"></a>Dirty read</h4><p>But it is subject to cascading aborts.</p><p>然而二阶段锁受限于集联回滚（dirty read）</p><img src="/2023/04/04/15445/image-20230403213848544.png" alt="image-20230403213848544" style="zoom:50%;"><p>脏读的问题本质上因为T2这个事务在T1事务没有提交前就获得了读写权限，进而在未提交的临时版本上做了操作。</p><p>Solution 采取strong strict 2PL</p><p>严格二阶段锁协议的特点是事务所修改的数据在事务结束之前，其他事务都不能读写，这个协议的好处就是不会产生级联回滚。而且事务可能对数据进行了很多次更新，但在严格二阶段锁协议下，需要回滚时，直接回滚到事务开始时即可，不用管它进行过多少次更新，因为这个事务在进行数据更新时，绝对不会有其他的事务也在更新共享的数据</p><h4 id="Deadlock"><a href="#Deadlock" class="headerlink" title="Deadlock"></a>Deadlock</h4><p>下图为导致死锁发生的情况，T1和T2互相占用相互需要的资源且不会释放</p><img src="/2023/04/04/15445/image-20230403214939513.png" alt="image-20230403214939513" style="zoom:50%;"><p>本质：相互等待</p><p>Solution</p><ol><li>死锁检测：</li></ol><p>DMBS去维护一个锁等待图，只要确保图中不出现环，则安全（周期性检查，有环就想办法解开）</p><p>选择一个victim事务，让其回滚（选择影响小的事务回滚）</p><ol start="2"><li>死锁避免：</li></ol><p>给予事务优先级，高优先级的事务拥有锁资源时低优先级的锁无法获取该锁，只能等待</p><p>优先级可能导致饥饿现象</p><h2 id="Hierarchical-Locking"><a href="#Hierarchical-Locking" class="headerlink" title="Hierarchical Locking"></a>Hierarchical Locking</h2><h2 id="TimeStamp-Ordering"><a href="#TimeStamp-Ordering" class="headerlink" title="TimeStamp Ordering"></a>TimeStamp Ordering</h2><p>时间戳顺序并发控制</p><p>锁是一种悲观的并发控制手段，对数据加锁总是建立在未来有可能对数据进行操作的基础上，这会带来系统效率的下降。因此我们希望能利用一些乐观锁的方式来提高系统的性能。</p><p>如果事务Ti的时间戳在Tj之前，那么DBMS要保证这两个事务都被提交之后的效果相当于Ti先执行，Ti执行完了之后Tj再执行</p><h3 id="Basic-Timestamp-Ordering"><a href="#Basic-Timestamp-Ordering" class="headerlink" title="Basic Timestamp Ordering"></a>Basic Timestamp Ordering</h3><p>每一行数据都要有两个时间戳，一个是read timestamp另一个是read timestamp</p><p>check timestamp for every op： if txn tries to access an obj written a higher timestamp, it aborts and restarts</p><p><strong>本质上就是不能对还未到达的数据进行修改，即不能对未来的数据做操作</strong></p><p>如果发现当前事务的时间戳比要读的对象的写时间戳（上次修改它的事务的时间戳）早，这就属于“操作来自未来的数据”了，无法满足“执行调度的结果等效于先到达的事务完整地在后到达的事务之前发生”，那么当前的Ti事务就不能再操作这个共享的对象，于是abort，之后系统给这个abort的事务一个新的时间戳，事务重启。</p><p>否则就是合法的，当前事务可以读共享的对象，读完了之后更新这个对象的读时间戳（如果这个对象的读时间戳比当前事务的时间戳早，那就把读时间戳修改成当前事务的时间戳），然后把对象从数据库拷贝一份到事务本地（因为对象可能会在接下来被其他事务修改）</p><img src="/2023/04/04/15445/image-20230403222103713.png" alt="image-20230403222103713" style="zoom:50%;"><p>如何优化以上这种情况呢？W(A)操作只需要写入本地事务即可，随后R(A)操作也只需要读本地的事务，且执行结果和串形结果一致</p><h4 id="Tomas-rule"><a href="#Tomas-rule" class="headerlink" title="Tomas rule"></a>Tomas rule</h4><p>当前事务写一个对象时，如果当前事务的时间戳早于对象的读时间戳，表示未来存在一个读取该对象的事务，因此我们必须要abort当前事务。如果当前事务的时间戳早于对象的写时间戳，代表未来还会有一个事务来改变这个对象，因此我们可以正常执行无需abort</p><img src="/2023/04/04/15445/image-20230403222349585.png" alt="image-20230403222349585" style="zoom:50%;"><p><u>基础的T&#x2F;O协议还有一些性能问题，事务在读任何数据的时候都要往本地拷贝一份，这会带来不小的开销（比如说全表扫描的时候就要把整个表复制一份）；</u></p><p><u>以及还有长事务容易饥饿的问题</u></p><h3 id="Optimistic-Concurrency-Control"><a href="#Optimistic-Concurrency-Control" class="headerlink" title="Optimistic Concurrency Control"></a>Optimistic Concurrency Control</h3><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><p>以上三种方式都难以解决幻读的问题，因此幻读是指第二次读出第一次未读出的数据。是insert并发的问题。而且以上三种并发控制都是对已有数据进行限制，所以很难解决幻读的问题。（MVCC也不能解决幻读）</p><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>Muti Version Concurrency Control</p><p>2PL或者TO等并发控制协议都存在一些问题，即无法对历史的数据进行操作。MVCC则是通过某些设计留下过去的数据版本，根据事务的序号决定读取的版本。并且2PL仍然存在读写冲突，MVCC能够允许数据事务同时对对象进行读写操作。</p><h4 id="Undo-log"><a href="#Undo-log" class="headerlink" title="Undo log"></a>Undo log</h4><p>MVCC 的目的就是多版本并发控制，在数据库中的实现，就是为了解决<code>读写冲突</code>，它的实现原理主要是依赖记录中的 <strong><code>3个隐式字段</code><strong>，</strong><code>undo日志</code></strong> ，**<code> Read View</code>** 来实现的。所以我们先来看看这个三个 point 的概念</p><ul><li>DB_TRX_ID<br>6 byte，最近修改(修改&#x2F;插入)事务 ID：记录创建这条记录&#x2F;最后一次修改该记录的事务 ID</li><li>DB_ROLL_PTR<br>7 byte，回滚指针，指向这条记录的上一个版本（存储于 rollback segment 里）</li><li>DB_ROW_ID<br>6 byte，隐含的自增 ID（隐藏主键），如果数据表没有主键，InnoDB 会自动以DB_ROW_ID产生一个聚簇索引</li></ul><p>undo log 主要分为两种：</p><ul><li>insert undo log<br>代表事务在 insert 新记录时产生的 undo log, 只在事务回滚时需要，并且在事务提交后可以被立即丢弃</li><li>update undo log<br>事务在进行 update 或 delete 时产生的 undo log ; 不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被 purge 线程统一清除</li></ul><h4 id="Read-View"><a href="#Read-View" class="headerlink" title="Read View"></a>Read View</h4><p>利用readview做可见性判断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">readview</span>&#123;</span><br>  <span class="hljs-type">int</span> row_trx_id;<br>  <span class="hljs-type">int</span>* trx_ids;<br>  <span class="hljs-type">int</span> min_trx_id;<br>  <span class="hljs-type">int</span> max_trx_id;<br>&#125;readview;<br></code></pre></td></tr></table></figure><ul><li>Row_trx_id : 上一次对对象操作的id</li><li>trx_ids : readview创建时活动的事务id集合</li><li>min&#x2F;max：ids中最小或者最大的事务id</li></ul><p><em><strong>RC隔离条件下，要求在每次select时对事务创建一个readview；RR条件下，每次事务begin时创建一个readview</strong></em></p><h4 id="可见性算法"><a href="#可见性算法" class="headerlink" title="可见性算法"></a>可见性算法</h4><p>Read View遵循一个可见性算法，主要是将要被修改的数据的最新记录中的 DB_TRX_ID（即当前事务 ID ）取出来，与系统当前其他活跃事务的 ID 去对比（由 Read View 维护），如果 DB_TRX_ID 跟 Read View 的属性做了某些比较，不符合可见性，那就通过 DB_ROLL_PTR 回滚指针去取出 Undo Log 中的 DB_TRX_ID 再比较，即遍历链表的 DB_TRX_ID（从链首到链尾，即从最近的一次修改查起），直到找到满足特定条件的 DB_TRX_ID , 那么这个 DB_TRX_ID 所在的旧记录就是当前事务能看见的最新老版</p><ol><li>首先比较 DB_TRX_ID &lt; up_limit_id , 如果小于，则当前事务能看到 DB_TRX_ID 所在的记录，如果大于等于进入下一个判断</li><li>接下来判断 DB_TRX_ID &gt;&#x3D; low_limit_id , 如果大于等于则代表 DB_TRX_ID 所在的记录在 Read View 生成后才出现的，那对当前事务肯定不可见，如果小于则进入下一个判断</li><li>判断 DB_TRX_ID 是否在活跃事务之中，trx_list.contains (DB_TRX_ID)，如果在，则代表我 Read View 生成时刻，你这个事务还在活跃，还没有 Commit，你修改的数据，我当前事务也是看不见的；如果不在，则说明，你这个事务在 Read View 生成之前就已经 Commit 了，你修改的结果，我当前事务是能看见的</li></ol><img src="/2023/04/04/15445/image-20230403225052564.png" alt="image-20230403225052564" style="zoom:50%;"><blockquote><p>【MySQL笔记】正确的理解MySQL的MVCC及实现原理<a href="https://blog.csdn.net/SnailMann/article/details/94724197">https://blog.csdn.net/SnailMann/article/details/94724197</a></p></blockquote><h1 id="Buffer-Pool-Manager"><a href="#Buffer-Pool-Manager" class="headerlink" title="Buffer Pool Manager"></a>Buffer Pool Manager</h1><h1 id="Lock-Manager"><a href="#Lock-Manager" class="headerlink" title="Lock Manager"></a>Lock Manager</h1><h2 id="Task-1"><a href="#Task-1" class="headerlink" title="Task 1"></a>Task 1</h2><ul><li>使用二阶段锁机制，实现<strong>READ_UNCOMMITED, READ_COMMITTED, and REPEATABLE_READ</strong>三个事务隔离级别，确保LM能够正确的grant lock or release lock</li></ul><ol><li><p>事务开始时进入growing，当事务要访问数据时，首先向LM申请对应数据的锁</p><p>LM中的操作：</p><ol><li>会检查该数据是否有被锁住，若没有被锁住，则直接grant lock；若锁住，则判断申请锁与当前锁是否兼容，不兼容 throw exception</li><li>若是同一个等级的锁，则无需操作；若是可以升级的锁，则升级后重新加入等待队列</li></ol></li></ol><p><img src="/2023/04/04/15445/image-20230615205243038.png" alt="image-20230615205243038"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP/IP</title>
    <link href="/2023/01/14/TCP-IP/"/>
    <url>/2023/01/14/TCP-IP/</url>
    
    <content type="html"><![CDATA[<h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP&#x2F;IP"></a>TCP&#x2F;IP</h2>]]></content>
    
    
    
    <tags>
      
      <tag>cs144</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Raft</title>
    <link href="/2022/11/29/raft/"/>
    <url>/2022/11/29/raft/</url>
    
    <content type="html"><![CDATA[<h1 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h1><h2 id="0-Raft的内部结构"><a href="#0-Raft的内部结构" class="headerlink" title="0. Raft的内部结构"></a>0. Raft的内部结构</h2><h3 id="什么是raft"><a href="#什么是raft" class="headerlink" title="什么是raft"></a>什么是raft</h3><ul><li>raft是分布式系统中的一致性算法，其目的是保障分布式集群中不同节点上数据的一致性，同时为分布式系统提供高可用性，能够持续对外提供服务。</li></ul><p> Leader 负责与Client和集群中的Follower沟通，主要控制数据的流向</p><ol><li>Client 接受用户的指令，并将数据传递给Leader</li><li>Follower 可以理解为正在运行的机器，接受Leader传递的日志，并将日志执行到状态机中</li></ol><h3 id="Raft-中存在的struct"><a href="#Raft-中存在的struct" class="headerlink" title="Raft 中存在的struct"></a>Raft 中存在的struct</h3><p>在RPC响应之前，需要更新稳定存储介质</p><table><thead><tr><th align="center">需要持久化的状态</th><th align="center"></th></tr></thead><tbody><tr><td align="center">currentTerm</td><td align="center">server存储的最新任期（初始化为0且单调递增）</td></tr><tr><td align="center">votedFor</td><td align="center">当前任期接受到的candidateID（初始化为0）</td></tr><tr><td align="center">log[ ]</td><td align="center">日志记录包含状态机的命令和从leader接收到的日志任期</td></tr></tbody></table><table><thead><tr><th align="center">所有机器可变状态</th><th align="center"></th></tr></thead><tbody><tr><td align="center">commitIndex</td><td align="center">即将被提交的日志记录的索引</td></tr><tr><td align="center">lastApplied</td><td align="center">已经被提交到状态机的最后一个日志的索引（初值为0且单调递增）</td></tr></tbody></table><table><thead><tr><th align="center">leader可变状态</th><th align="center">每次选举后重新初始化</th></tr></thead><tbody><tr><td align="center">nextIndex[ ]</td><td align="center">每台机器在数组占据一个元素，元素的值为下条发送到该机器的日志索引 (初始值为 leader 最新一条日志的索引 +1)</td></tr><tr><td align="center">matchIndex[ ]</td><td align="center">每台机器在数组中占据一个元素，元素的记录将要复制给该机器日志的索引</td></tr></tbody></table><ul><li>AppendEntriesArgs</li></ul><p>appendentries 是leader用来维持心跳机制和日志添加功能的结构，具体包含的参数如下</p><p>其中PreLogIndex和PreLogTerm是用来为确定follower所需的日志号</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> AppendEntriesArgs <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// Your data here (2A, 2B).</span><br>Term         <span class="hljs-type">int</span><span class="hljs-comment">// 表明这是Term这个任期的Leader</span><br>LeaderId     <span class="hljs-type">int</span><span class="hljs-comment">// </span><br>PreLogIndex  <span class="hljs-type">int</span><span class="hljs-comment">// 前一条日志的槽位，不一定是已提交的日志</span><br>PreLogTerm   <span class="hljs-type">int</span><span class="hljs-comment">// 前一条日志的任期号</span><br>LeaderCommit <span class="hljs-type">int</span><span class="hljs-comment">// leader已经提交的日志号</span><br>  Log []Entry<span class="hljs-comment">// 日志内容</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>RequestVoteArgs</li></ul><p>LastLogIndex和LastLogTerm用来做Election Restriction，确保能够选出当前任期内具有最新日志的节点作为leader</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> RequestVoteArgs <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// Your data here (2A, 2B).</span><br>Term         <span class="hljs-type">int</span><br>CandidateId  <span class="hljs-type">int</span><br>LastLogTerm  <span class="hljs-type">int</span><span class="hljs-comment">// leader最后一条日志所属的任期号</span><br>LastLogIndex <span class="hljs-type">int</span><span class="hljs-comment">// leader最后一条日志的槽位</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="一、-Leader-election"><a href="#一、-Leader-election" class="headerlink" title="一、 Leader election"></a>一、 Leader election</h2><p>Raft 使用心跳机制来触发选主</p><p>每次随机时间结束，server都会将term+1，较少的随机时间会导致先结束的server变成Candidate</p><p>下图为raft中节点的状态转换图，其中Leader状态只能由Candidate转变而来</p><p><img src="/2022/11/29/raft/image-20230201175417736.png" alt="image-20230201175417736"></p><h3 id="1-选主流程"><a href="#1-选主流程" class="headerlink" title="1. 选主流程"></a>1. 选主流程</h3><p>在随机事件到达后，follower先将自己的term+1，立刻将自身状态更新为candidate并投自己一票，随后向其他节点发送request vote，等待大多数节点的返回；</p><ol><li>若candidate收到大多数的投票，自己直接转变为leader，并向其他节点发送心跳抑制其他节点进行选举</li><li>若candidate先接受到leader的心跳，若心跳任期大余candidate任期，则当前节点转变为follower；若小于或等于其任期，无需操作；</li><li>若candidate在规定时间既没收到大多数选票，则等待一个随机事件后重新进行选主过程</li></ol><h3 id="2-细节"><a href="#2-细节" class="headerlink" title="2. 细节"></a>2. 细节</h3><ul><li>节点如何判断是否向candidate投票？</li></ul><p>若candidate的任期号大于当前节点的任期号，进入Election Restriction判断（其余情况均无法投票）</p><p>若candidate 的 LastLogTerm &gt; 当前节点的最后一条日志的任期号，则可以投票</p><p>若candidate 的 LastLogTerm &#x3D; 当前节点的最后一条日志的任期号，则比较二者日志的index，若candidate的index号 &gt; 当前的index号，则可以投票</p><ul><li>在安全性章节中我们规定了选主时的限制，以保证当前leader包含了最新的日志信息</li></ul><p>此时只有s2可以向s4投票，因为s1，s3，s5都有新的日志[ 5 ]</p><p><strong>日志文件是指写入的日志，并不一定要是提交的日志（实验证明）</strong></p><img src="/2022/11/29/raft/image-20230316215346215.png" alt="image-20230316215346215" style="zoom:50%;"><h2 id="二、-Log-Replicated"><a href="#二、-Log-Replicated" class="headerlink" title="二、 Log Replicated"></a>二、 Log Replicated</h2><h3 id="1-日志复制流程"><a href="#1-日志复制流程" class="headerlink" title="1. 日志复制流程"></a>1. 日志复制流程</h3><p>candidate变为leader后，会开始处理客户端的请求，那么client怎么确定那台机器是leader呢？</p><ul><li>client会直接向集群中任意一台机器发送询问请求，若机器恰好为leader则直接确定；若为普通follower，则可以等待Leader的心跳结果并返回；若当前为宕机的机器，经过一段时间后重新发送请求即可</li></ul><p>client发送指令给leader，leader首先会将其写入自己的日志，并发送appendEntry开启日志复制阶段，当集群复制完毕，leader会将日志应用到当前状态机，并开启应用阶段，当集群应用完毕，leader会提交当前日志（只要复制成功，此日志就一定存在于大多数节点中，无需关注提交是否成功）</p><h3 id="2-一致性检测（日志恢复）"><a href="#2-一致性检测（日志恢复）" class="headerlink" title="2. 一致性检测（日志恢复）"></a>2. 一致性检测（日志恢复）</h3><p>判断leader发来的AppendEntry RPC是否能成功的应用在当前节点上</p><ul><li>为什么需要做这样的判断呢？</li></ul><p>因为Raft中只要求大多数节点保持一致，整个集群就可用，因此集群中可能存在落后很多日志的慢速节点。为了保障慢速节点的一致性，我们不能将最新的日志插入这样的节点，一旦为慢速节点插入新的日志就会造成不一致的现象发生。所以在插入日志前我们需要对节点做一致性检测</p><ul><li>如何做一致性检测？</li></ul><p>AppendEntry中包含这样两个参数，并且Leader还维护了两个数组分别是nextIndex和matchIndex</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">PreLogIndex  <span class="hljs-type">int</span><span class="hljs-comment">// 待插入日志的前一条日志的槽位，不一定是已提交的日志</span><br>PreLogTerm   <span class="hljs-type">int</span><span class="hljs-comment">// 待插入日志的前一条日志的任期号</span><br></code></pre></td></tr></table></figure><p>节点收到AppendEntry时，会将自己的最后一条日志的index与PreLogIndex相比较，若相等，则比较最后一条日志的任期号和PreLogTerm，若也相等则可以顺利插入日志，返回插入成功更新nextIndex和matchIndex</p><p>若index比较不等（只有可能是最后一条日志的index小），则返回插入失败，Leader更新nextIndex &#x3D; nextIndex - 1；随后Leader重新发送AppendEntry，并对此前插入日志失败的节点调整PreLogIndex和PreLogIndex，PreLogIndex &#x3D; nextIndex[ rf.me ] - 1，并重复做上面两步骤，直到成功插入</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rf *Raft)</span></span> AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) &#123;<br>rf.mu.Lock()<br><span class="hljs-keyword">defer</span> rf.mu.Unlock()<br>reply.Success = <span class="hljs-literal">false</span><br><br><span class="hljs-comment">// Reply false if term &lt; currentTerm (§5.1)</span><br><span class="hljs-keyword">if</span> args.Term &lt; rf.currentTerm &#123;<br>reply.Term = rf.currentTerm<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// For Candidates. If AppendEntries RPC received from new leader: convert to follower</span><br><span class="hljs-keyword">if</span> rf.state == CandidateState &amp;&amp; rf.currentTerm == args.Term &#123;<br>rf.state = FollowerState<br>&#125;<br><br>rf.checkTerm(args.Term)<br>reply.Term = rf.currentTerm<br>rf.setElectionTimeout(randHeartbeatTimeout())<br><br><span class="hljs-comment">// Reply false if log doesn’t contain an entry at prevLogIndex whose term matches prevLogTerm (§5.3)</span><br><span class="hljs-keyword">if</span> args.PrevLogTerm == <span class="hljs-number">-1</span> || args.PrevLogTerm != rf.log.getEntry(args.PrevLogIndex).Term &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// If an existing entry conflicts with a new one (same index but different terms),</span><br><span class="hljs-comment">// delete the existing entry and all that follow it (§5.3)</span><br><span class="hljs-keyword">for</span> i, entry := <span class="hljs-keyword">range</span> args.Entries &#123;<br><span class="hljs-keyword">if</span> rf.log.getEntry(i+<span class="hljs-number">1</span>+args.PrevLogIndex).Term != entry.Term &#123;<br>rf.log = <span class="hljs-built_in">append</span>(rf.log.getSlice(<span class="hljs-number">1</span>, i+<span class="hljs-number">1</span>+args.PrevLogIndex), args.Entries[i:]...)<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>reply.Success = <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>hints</li></ul><p>在此阶段，我们有可能会擦除一些节点的日志，为什么这样擦出是安全的呢，因为这些日志一定是没有应用到大多数节点的日志</p><ul><li>什么时候重置ElectionTimeOut？</li></ul><p>每次发起</p><ul><li>什么时候重置HeartBeatTimeOut？</li></ul><h2 id="三、-持久化和日志压缩"><a href="#三、-持久化和日志压缩" class="headerlink" title="三、 持久化和日志压缩"></a>三、 持久化和日志压缩</h2><h3 id="1-日志压缩流程"><a href="#1-日志压缩流程" class="headerlink" title="1. 日志压缩流程"></a>1. 日志压缩流程</h3><ul><li>为什么要日志压缩？</li></ul><p>集群中每一个机器的容量是有限的，如果日志无限的增长一定会对我们的机器带来隐患，因此在某些时间点对过去的一些已经被应用的日志做压缩是十分有必要的。</p><ul><li>怎么做日志压缩？</li></ul><p>TODO：</p><p>好复杂。。不知道怎么写了。。找时间再补上</p><p><img src="/2022/11/29/raft/image-20231110232838107.png" alt="image-20231110232838107"></p><h2 id="四、面试题"><a href="#四、面试题" class="headerlink" title="四、面试题"></a>四、面试题</h2><ol><li>如果worker节点重启后直接变为candidate会怎么样？</li></ol><h2 id="五、性能优化"><a href="#五、性能优化" class="headerlink" title="五、性能优化"></a>五、性能优化</h2><h2 id="六、集群成员变更"><a href="#六、集群成员变更" class="headerlink" title="六、集群成员变更"></a>六、集群成员变更</h2><h3 id="联合一致"><a href="#联合一致" class="headerlink" title="联合一致"></a>联合一致</h3><p><img src="/2022/11/29/raft/image-20231111094702450.png" alt="image-20231111094702450"></p><h2 id="七、引用"><a href="#七、引用" class="headerlink" title="七、引用"></a>七、引用</h2><blockquote><p>Raft Scope 演示视频地址 <a href="https://raft.github.io/raftscope/index.html">https://raft.github.io/raftscope/index.html</a></p><p><a href="https://observablehq.com/@stwind/raft-consensus-simulator">https://observablehq.com/@stwind/raft-consensus-simulator</a></p></blockquote><h2 id="locking-rules"><a href="#locking-rules" class="headerlink" title="locking rules"></a>locking rules</h2><p>用一个中间变量保存rf.currentTerm，并确保前后currentTerm一致</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/* Rule 5: Be careful about assumptions across a drop and re-acquire of a</span><br><span class="hljs-comment">lock. One place this can arise is when avoiding waiting with locks</span><br><span class="hljs-comment">held. For example, this code to send vote RPCs is incorrect:</span><br><span class="hljs-comment">*/</span><br>  rf.mu.Lock()<br>  rf.currentTerm += <span class="hljs-number">1</span><br>  rf.state = Candidate<br>  <span class="hljs-keyword">for</span> &lt;each peer&gt; &#123;<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      rf.mu.Lock()<br>      args.Term = rf.currentTerm<br>      rf.mu.Unlock()<br>      Call(<span class="hljs-string">&quot;Raft.RequestVote&quot;</span>, &amp;args, ...)<br>      <span class="hljs-comment">// handle the reply...</span><br>    &#125; ()<br>  &#125;<br>  rf.mu.Unlock()<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">The code sends each RPC in a separate goroutine. It&#x27;s incorrect</span><br><span class="hljs-comment">because args.Term may not be the same as the rf.currentTerm at which</span><br><span class="hljs-comment">the surrounding code decided to become a Candidate. Lots of time may</span><br><span class="hljs-comment">pass between when the surrounding code creates the goroutine and when</span><br><span class="hljs-comment">the goroutine reads rf.currentTerm; for example, multiple terms may</span><br><span class="hljs-comment">come and go, and the peer may no longer be a candidate. One way to fix</span><br><span class="hljs-comment">this is for the created goroutine to use a copy of rf.currentTerm made</span><br><span class="hljs-comment">while the outer code holds the lock. Similarly, reply-handling code</span><br><span class="hljs-comment">after the Call() must re-check all relevant assumptions after</span><br><span class="hljs-comment">re-acquiring the lock; for example, it should check that</span><br><span class="hljs-comment">rf.currentTerm hasn&#x27;t changed since the decision to become a</span><br><span class="hljs-comment">candidate.</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Distributed System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab6-COW</title>
    <link href="/2022/11/18/Lab6-COW/"/>
    <url>/2022/11/18/Lab6-COW/</url>
    
    <content type="html"><![CDATA[<h2 id="Copy-on-Write"><a href="#Copy-on-Write" class="headerlink" title="Copy on Write"></a>Copy on Write</h2><h3 id="什么是写时复制机制？"><a href="#什么是写时复制机制？" class="headerlink" title="什么是写时复制机制？"></a>什么是写时复制机制？</h3><p>写时复制机制是操作系统中非常常见的一种优化机制，主要为了解决fork-exec这一系列的问题。</p><p>例如，当我们使用shell处理指令时，shell通常会通过fork创建一个子进程，并利用exec加载指令程序到子进程中。通常fork会将shell父进程中的所有内容都做一份拷贝，例如pagetable，用户栈，甚至包括打开文件表。然而exec会加载一个新的程序占据子进程，所以以上这些资源会被立刻丢弃，在用户的视角这样的操作显然有点浪费</p><p>那么我们就可以利用一种乐观的心态来解决这个问题，例如在fork的时候并不去真正的复制内存空间（因为uvmcopy会为我们分配新的物理空间），而是仅仅复制页表中的内容呢？</p><p><img src="/2022/11/18/Lab6-COW/image-20230407152403851.png" alt="image-20230407152403851"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>上图给我们一种复制地址空间的思路，只复制映射而不去分配物理地址空间，当真正被访问时再去分配。那么如何实现这样的操作呢？我们可以结合lazy- allocation中的实验过程来完成这个lab</p><h4 id="修改uvmcopy"><a href="#修改uvmcopy" class="headerlink" title="修改uvmcopy"></a>修改uvmcopy</h4><p>对虚拟地址的操作免不了利用uvmcopy这个函数，我们使用这个函数进行地址空间的复制。在Lab3中我们介绍了这个函数，其中uvmcopy会在复制地址空间时eager的为子进程分配物理页面，尽然我们要lazy的处理这个问题，那么一定要对这个函数进行修改</p><img src="/2022/11/18/Lab6-COW/image-20230313085847793.png" alt="image-20230313085847793" style="zoom:50%;"><p>COW要求我们在此时将父子进程的页表项都标记为只读的，并为这些pte做好标记，当进程需要对页表内容进行修改时，我们能够识别出COW带来的问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// COW fault</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_COW (1L &lt;&lt; 8)</span><br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">uvmcopy</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> old, <span class="hljs-type">pagetable_t</span> new, uint64 sz)</span><br>&#123;<br>  <span class="hljs-type">pte_t</span> *pte;<br>  uint64 pa, i;<br>  uint flags;<br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; sz; i += PGSIZE)&#123;<br>    <span class="hljs-keyword">if</span>((pte = walk(old, i, <span class="hljs-number">0</span>)) == <span class="hljs-number">0</span>)<br>      panic(<span class="hljs-string">&quot;uvmcopy: pte should exist&quot;</span>);<br>    <span class="hljs-keyword">if</span>((*pte &amp; PTE_V) == <span class="hljs-number">0</span>)<br>      panic(<span class="hljs-string">&quot;uvmcopy: page not present&quot;</span>);<br>    pa = PTE2PA(*pte);<br>    flags = PTE_FLAGS(*pte);<br>    <span class="hljs-comment">// 仅对可写页面设置COW标记</span><br>    <span class="hljs-keyword">if</span>(flags &amp; PTE_W) &#123;<br>      <span class="hljs-comment">// 禁用写并设置COW Fork标记</span><br>      flags = (flags | PTE_COW) &amp; ~PTE_W;<br>      *pte = PA2PTE(pa) | flags;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(mappages(new, i, PGSIZE, pa, flags) != <span class="hljs-number">0</span>) &#123;<br>      uvmunmap(new, <span class="hljs-number">0</span>, i / PGSIZE, <span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="应对COW-fault"><a href="#应对COW-fault" class="headerlink" title="应对COW fault"></a>应对COW fault</h4><p>既然父子进程都被我们修改为只读的，那么我们对子进程的任何修改都会触发page fault，于此同时我们还可以根据我们uvmcopy时的标记来判断这个page fault是否是cow fault，如果是一个cow fault我们便可以为其分配一块实际的物理页面</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64 cause = r_scause();<br><span class="hljs-keyword">if</span>(cause == <span class="hljs-number">13</span> || cause == <span class="hljs-number">15</span>) &#123;<br>  uint64 fault_va = r_stval();  <span class="hljs-comment">// 获取出错的虚拟地址</span><br>  <span class="hljs-keyword">if</span>(fault_va &gt;= sz)<br>    p-&gt;killed = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span>(fault_va &gt;= MAXVA)<br>    panic(<span class="hljs-string">&quot;MAXVA!&quot;</span>);<br>  <span class="hljs-type">pte_t</span>* pte = walk(pagetable, fault_va, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span>(pte == <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;pte is null!&quot;</span>);<br>  <span class="hljs-keyword">if</span>((*pte &amp; PTE_V) == <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;pte is not allow!&quot;</span>);<br>  <span class="hljs-keyword">if</span>(*pte &amp; PTE_F)&#123;<br>    <span class="hljs-comment">// is cow pagefault</span><br>    <span class="hljs-comment">// TODO alloc an phscial page just like kalloc</span><br>  &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  panic(<span class="hljs-string">&quot;not cow!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="释放地址空间"><a href="#释放地址空间" class="headerlink" title="释放地址空间"></a>释放地址空间</h4><p>通过以上的设计我们看似完成了COW机制，然而当进程释放地址空间时问题就发生了。父子进程中其中任何一个进程释放内存空间时，都会导致另一个进程的内存空间失效，因此我们不能随意的释放内存空间。</p><p>那么如何保证安全的释放呢？我们应该在复制页表时对页表中的每一个pte有一个计数器，通过计数器确定这个pte是否还被引用，若被引用那么只需要对计数器进行操作，若只剩一个引用，那么我们可以正常的释放pte的内容。（ std::shared_ptr ）</p><p><strong>初始化计数器</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">next</span>;</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">freelist</span>;</span><br>&#125; kmem;<br><br><span class="hljs-comment">// 只需要在freerange()时对数组进行初始化即可</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ref_stru</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>  <span class="hljs-type">int</span> cnt[PHYSTOP / PGSIZE];  <span class="hljs-comment">// 引用计数</span><br>&#125; ref;<br><br><span class="hljs-comment">// Free the page of physical memory pointed at by v,</span><br><span class="hljs-comment">// which normally should have been returned by a</span><br><span class="hljs-comment">// call to kalloc().  (The exception is when</span><br><span class="hljs-comment">// initializing the allocator; see kinit above.)</span><br><span class="hljs-type">void</span> *<br><span class="hljs-title function_">kalloc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span><br><br>  acquire(&amp;kmem.lock);<br>  r = kmem.freelist;<br>  <span class="hljs-keyword">if</span>(r) &#123;<br>    kmem.freelist = r-&gt;next;<br>    acquire(&amp;ref.lock);<br>    ref.cnt[(uint64)r / PGSIZE] = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 将引用计数初始化为1</span><br>    release(&amp;ref.lock);<br>  &#125;<br>  release(&amp;kmem.lock);<br><br>  <span class="hljs-keyword">if</span>(r)<br>    <span class="hljs-built_in">memset</span>((<span class="hljs-type">char</span>*)r, <span class="hljs-number">5</span>, PGSIZE); <span class="hljs-comment">// fill with junk</span><br>  <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span>*)r;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>释放页表</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">kfree</span><span class="hljs-params">(<span class="hljs-type">void</span> *pa)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span><br><br>  <span class="hljs-keyword">if</span>(((uint64)pa % PGSIZE) != <span class="hljs-number">0</span> || (<span class="hljs-type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)<br>    panic(<span class="hljs-string">&quot;kfree&quot;</span>);<br><br>  <span class="hljs-comment">// 只有当引用计数为0了才回收空间</span><br>  <span class="hljs-comment">// 否则只是将引用计数减1</span><br>  acquire(&amp;ref.lock);<br>  <span class="hljs-keyword">if</span>(--ref.cnt[(uint64)pa / PGSIZE] == <span class="hljs-number">0</span>) &#123;<br>    release(&amp;ref.lock);<br><br>    r = (<span class="hljs-keyword">struct</span> run*)pa;<br><br>    <span class="hljs-comment">// Fill with junk to catch dangling refs.</span><br>    <span class="hljs-built_in">memset</span>(pa, <span class="hljs-number">1</span>, PGSIZE);<br><br>    acquire(&amp;kmem.lock);<br>    r-&gt;next = kmem.freelist;<br>    kmem.freelist = r;<br>    release(&amp;kmem.lock);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    release(&amp;ref.lock);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>实验整体思路不是很难，但有很多细节需要处理。做完这个实验可以深入理解进程创建和执行的一个流程， 并且能够让我们充分理解计算机系统中一些lazy的思想</p>]]></content>
    
    
    
    <tags>
      
      <tag>xv6_riscv Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab5-Lazy Allocation</title>
    <link href="/2022/11/01/Lab5-Lazy-Allocation/"/>
    <url>/2022/11/01/Lab5-Lazy-Allocation/</url>
    
    <content type="html"><![CDATA[<h2 id="Lazy-Allocation"><a href="#Lazy-Allocation" class="headerlink" title="Lazy-Allocation"></a>Lazy-Allocation</h2><h3 id="什么是懒分配策略？"><a href="#什么是懒分配策略？" class="headerlink" title="什么是懒分配策略？"></a>什么是懒分配策略？</h3><p>操作系统可以使用页表硬件的技巧之一是延迟分配用户空间堆内存（lazy allocation of user-space heap memory）。Xv6应用程序使用<code>sbrk()</code>系统调用向内核请求堆内存。在我们给出的内核中，<code>sbrk()</code>分配物理内存并将其映射到进程的虚拟地址空间。内核为一个大请求分配和映射内存可能需要很长时间。例如，考虑由262144个4096字节的页组成的千兆字节；即使单独一个页面的分配开销很低，但合起来如此大的分配数量将不可忽视。此外，有些程序申请分配的内存比实际使用的要多（例如，实现稀疏数组），或者为了以后的不时之需而分配内存。为了让<code>sbrk()</code>在这些情况下更快地完成，复杂的内核会延迟分配用户内存。也就是说，<code>sbrk()</code>不分配物理内存，只是记住分配了哪些用户地址，并在用户页表中将这些地址标记为无效。当进程第一次尝试使用延迟分配中给定的页面时，CPU生成一个页面错误（page fault），内核通过分配物理内存、置零并添加映射来处理该错误。</p><p><strong>在我的理解中，懒分配或者懒机制是一种乐观的思想。如同乐观锁一般，我们会对系统做一个十分乐观的假设，设定当前状态不会被频繁的改动，我们只需要在真的需要改动时采取一些策略即可。</strong></p><p><img src="/2022/11/01/Lab5-Lazy-Allocation/image-20230407132602866.png" alt="image-20230407132602866"></p><ul><li>系统调用流程：<ul><li>陷入内核**&#x3D;&#x3D;&gt;<strong><code>usertrap</code>中<code>r_scause()==8</code>的分支</strong>&#x3D;&#x3D;&gt;<strong><code>syscall()</code></strong>&#x3D;&#x3D;&gt;**回到用户空间</li></ul></li><li>页面错误流程：<ul><li>陷入内核**&#x3D;&#x3D;&gt;<strong><code>usertrap</code>中<code>r_scause()==13||r_scause()==15</code>的分支</strong>&#x3D;&#x3D;&gt;<strong>分配内存</strong>&#x3D;&#x3D;&gt;**回到用户空间</li></ul></li></ul><p><u>由系统调用和pagefault的处理，我们都可以看出在xv6中针对于中断、异常、错误的处理方式是统一的，都是位于usertrap函数中</u></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p>按照提示注释掉实际分配物理地址空间的代码即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64<br><span class="hljs-title function_">sys_sbrk</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br> ...<br>  <span class="hljs-comment">// lazy allocation</span><br>  myproc()-&gt;sz += n;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>usertrap</p><p>保证发生pagefault的地址在新分配的地址空间内，若是超出了p-&gt;sz则是正常的OOM</p><p>首先要保证在sp之上，其次还要在sz之下同时还要有足够的内存空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">  uint64 cause = r_scause();<br>  <span class="hljs-keyword">if</span>(cause == <span class="hljs-number">8</span>) &#123;<span class="hljs-comment">// syscall handler</span><br>    ...<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((which_dev = devintr()) != <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// timer</span><br>    <span class="hljs-comment">// ok</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cause == <span class="hljs-number">13</span> || cause == <span class="hljs-number">15</span>) &#123;<br>    <span class="hljs-comment">// 处理页面错误</span><br>    uint64 fault_va = r_stval();  <span class="hljs-comment">// 产生页面错误的虚拟地址</span><br>    <span class="hljs-type">char</span>* pa;                     <span class="hljs-comment">// 分配的物理地址</span><br>    <span class="hljs-keyword">if</span>(PGROUNDUP(p-&gt;trapframe-&gt;sp) - <span class="hljs-number">1</span> &lt; fault_va &amp;&amp; fault_va &lt; p-&gt;sz &amp;&amp;(pa = kalloc()) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">memset</span>(pa, <span class="hljs-number">0</span>, PGSIZE);<br>    mappage(...);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      p-&gt;killed = <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>...<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="释放内存"><a href="#释放内存" class="headerlink" title="释放内存"></a>释放内存</h4><p>我们在进程中一旦启用了懒分配策略，我们在为进程释放内存时就要格外注意，毕竟我们不能释放还未分配物理地址空间的内存</p><blockquote><p>Frans : 因为对应的物理内存还没有分配，所以这部分新增加的内存的确没有映射关系。我们现在是lazy allocation，我们只会为需要的内存分配物理内存page。如果我们不需要这部分内存，那么就不会存在map关系，这非常的合理。相应的，我们对于这部分内存也不能释放，因为没有实际的物理内存可以释放，所以这里最好的处理方式就是continue，跳过并处理下一个page。</p></blockquote><p>uvmunmap</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(a = va; a &lt; va + npages*PGSIZE; a += PGSIZE)&#123;<br>  <span class="hljs-keyword">if</span>((pte = walk(pagetable, a, <span class="hljs-number">0</span>)) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">continue</span>;<br>  <span class="hljs-keyword">if</span>((*pte &amp; PTE_V) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">continue</span>;<br></code></pre></td></tr></table></figure><h4 id="处理系统调用时的lazy-allocation"><a href="#处理系统调用时的lazy-allocation" class="headerlink" title="处理系统调用时的lazy allocation"></a>处理系统调用时的lazy allocation</h4><p>如果在调用系统调用时发生了pagefault该怎么处理呢？</p><p>我们在执行syscall时都会从用户态捕获将要访问的地址，因此我们只需要在捕获地址时对地址进行判断即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">argaddr</span><span class="hljs-params">(<span class="hljs-type">int</span> n, uint64 *ip)</span><br>&#123;<br>  *ip = argraw(n);<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span>* <span class="hljs-title">p</span> =</span> myproc();<br><br>  <span class="hljs-comment">// 处理向系统调用传入lazy allocation地址的情况</span><br>  <span class="hljs-keyword">if</span>(walkaddr(p-&gt;pagetable, *ip) == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">if</span>(PGROUNDUP(p-&gt;trapframe-&gt;sp) - <span class="hljs-number">1</span> &lt; *ip &amp;&amp; *ip &lt; p-&gt;sz) &#123;<br>      <span class="hljs-type">char</span>* pa = kalloc();<br>      <span class="hljs-keyword">if</span>(pa == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>      <span class="hljs-built_in">memset</span>(pa, <span class="hljs-number">0</span>, PGSIZE);<br><br>      <span class="hljs-keyword">if</span>(mappages(p-&gt;pagetable, PGROUNDDOWN(*ip), PGSIZE, (uint64)pa, PTE_R | PTE_W | PTE_X | PTE_U) != <span class="hljs-number">0</span>) &#123;<br>        kfree(pa);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><blockquote><p>MIT 6.S081 课程记录 <a href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec08-page-faults-frans/8.2-lazy-page-allocation">https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec08-page-faults-frans/8.2-lazy-page-allocation</a></p><p>MIT6.S081 实验笔记 <a href="http://xv6.dgs.zone/labs/requirements/lab5.html">http://xv6.dgs.zone/labs/requirements/lab5.html</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>xv6_riscv Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MapReduce</title>
    <link href="/2022/10/15/MapReduce/"/>
    <url>/2022/10/15/MapReduce/</url>
    
    <content type="html"><![CDATA[<h2 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h2><h3 id="什么是MapReduce"><a href="#什么是MapReduce" class="headerlink" title="什么是MapReduce?"></a>什么是MapReduce?</h3><p>MapReduce是一种用来处理大规模数据的分布式计算框架。编程者只负责编写Map函数和Reduce函数，框架会将大型的数据处理任务切分成多个小型task，并将task分布式的处理。整个计算过程分为Map Phase和Reduce Phase，在Map阶段会将原始文件转化为intermediate kv pair，Reduce阶段则会将有关联的中间键合并。</p><p>在6.824的lab中，我们实现的MapReduce框架允许我们以加载.so文件的方式，实现相应的功能。例如wordcount、indexer、jobcount等工作。</p><ul><li>个人理解的MapReduce：一个divide and conquer 的大型计算模型</li></ul><p>（因为被Robert邮件提醒过，所以下面的代码均不是最后的正确结果，只是一个实例  :  ）</p><h3 id="MapReduce-的工作流程"><a href="#MapReduce-的工作流程" class="headerlink" title="MapReduce 的工作流程"></a>MapReduce 的工作流程</h3><p><img src="/2022/10/15/MapReduce/image-20221015140345802.png" alt="image-20221015140345802"></p><ol><li>MapReduce lib会将input file切片分成16MB或者64MB大小子文件split X，随后启动一系列进程。</li><li>从启动的这些进程选择一个作为mater，其余作为worker【master负责整个计算过程的调度与任务的分配，worker负责具体任务的执行】<ul><li>master会为worker创建一系列map_task和reduce_task（reduce task数量是用户指定的 n_Reduce）</li><li>一系列worker启动并向master发送rpc请求，表明worker节点当前的状态</li><li>master通过task_rpc返回给worker对应的task</li></ul></li><li>首先worker对master分配的task执行map func，将intermediate result写入<strong>本地</strong>，并通过rpc返回写入的位置</li><li>master在所有map task完成时进入Reduce阶段，分配reduce task</li><li>根据之前返回的地址读取中间文件，并执行reduce func，将结果存入GFS并等待下一次运算</li></ol><h4 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h4><ul><li>word count：Map函数会对将文件中的单词都转换为&lt;word, 1&gt;的形式，根据hash(word)的结果将单词分布到不同的中间文件中，随后通过Reduce函数对单词词频进行统计（相同的单词会因为同样的hash value存储在相同的中间文件）</li><li>indexer：Map函数将文件中的单词转换为&lt;word, filename&gt;的形式，Reduce函数对结果进行整理可以获取单词在那个文件中出现</li></ul><h4 id="一些数据结构和函数"><a href="#一些数据结构和函数" class="headerlink" title="一些数据结构和函数"></a>一些数据结构和函数</h4><p>以下定义的数据结构是master与worker在rpc通信过程中需要用到的数据结构，其中包含了task的定义等元数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Add your RPC definitions here.</span><br><span class="hljs-keyword">type</span> TaskReply <span class="hljs-keyword">struct</span> &#123; <span class="hljs-comment">// Coordinator返回给worker的信息</span><br>Task             *Task<br>NReduce          <span class="hljs-type">int</span><br>Coordinatorstate Coordinatorstate<br>&#125;<br><br><span class="hljs-keyword">type</span> Task <span class="hljs-keyword">struct</span> &#123;<br>Id        <span class="hljs-type">int</span>       <span class="hljs-comment">// 表示map任务号或者reduce任务号</span><br>TaskType  TaskType  <span class="hljs-comment">// 任务的类型</span><br>TaskState TaskState <span class="hljs-comment">// Task的执行状态</span><br>Filename  <span class="hljs-type">string</span>    <span class="hljs-comment">// map task需要读取的文件名称 reduce task需要的intermidiate files</span><br>StartTime time.Time <span class="hljs-comment">// task的起始时间</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Coordinatorstate <span class="hljs-type">int</span><br><span class="hljs-keyword">type</span> TaskType <span class="hljs-type">int</span><br><span class="hljs-keyword">type</span> TaskState <span class="hljs-type">int</span><br><br><span class="hljs-keyword">const</span> (<br>MapPhase Coordinatorstate = <span class="hljs-literal">iota</span><br>ReducePhase<br>AllDone<br>)<br><span class="hljs-keyword">const</span> (<br>Map TaskType = <span class="hljs-literal">iota</span><br>Reduce<br>Waiting<span class="hljs-comment">// task已经分配完毕，等待当前阶段task完成</span><br>Done<br>)<br><br><span class="hljs-keyword">const</span> (<br>Idle TaskState = <span class="hljs-literal">iota</span><span class="hljs-comment">// 暂未执行</span><br>InProgress<span class="hljs-comment">//</span><br>Completed<span class="hljs-comment">//</span><br>)<br><br><span class="hljs-comment">// files 表示所有文件名称</span><br><span class="hljs-comment">// nReduce 表示要执行多少次reduce</span><br><span class="hljs-comment">// MapReduce框架会为所有Map函数输出的每一个key，调用一次Reduce函数</span><br><span class="hljs-comment">//</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MakeCoordinator</span><span class="hljs-params">(files []<span class="hljs-type">string</span>, nReduce <span class="hljs-type">int</span>)</span></span> *Coordinator &#123;<br><br>c := Coordinator&#123;<br>filenames:     files,<br>nReduce:       nReduce,<br>taskId:        <span class="hljs-number">0</span>,<br>Phase:         MapPhase,<br>MapTasks:      <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Task, <span class="hljs-built_in">len</span>(files)),<br>ReduceTasks:   <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Task, nReduce),<br>ExcecuteState: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*TaskMeta, <span class="hljs-built_in">len</span>(files)+nReduce),<br>&#125;<br>c.MakeMapTask(c.filenames, c.MapTasks)<br>c.MakeReduceTask(c.ReduceTasks)<br><span class="hljs-comment">// go c.CrashTest()</span><br><span class="hljs-comment">// test</span><br>c.server()<br><span class="hljs-keyword">return</span> &amp;c<br>&#125;<br></code></pre></td></tr></table></figure><p>Coordinator中处理worker申请任务的函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 在这里为worker分配相应map task 返回对应文件名称，并且等待worker在规定时间完成</span><br><span class="hljs-comment">// worker完成后将结果返回至Coordinator，Coordinator整合结果后再分配Reduce task</span><br><span class="hljs-comment">// coordinator wait for ten seconds; after that the coordinator should assume the worker has died</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Coordinator)</span></span> RequestTask(args *TaskArgs, reply *TaskReply) <span class="hljs-type">error</span> &#123;<br>mutex.Lock()<br><span class="hljs-keyword">defer</span> mutex.Unlock()<br><br><span class="hljs-keyword">switch</span> c.Phase &#123;<br><span class="hljs-keyword">case</span> MapPhase:<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c.MapTasks) &gt; <span class="hljs-number">0</span> &#123;<br>reply.Task = &lt;-c.MapTasks<br>reply.Task.TaskState = InProgress<br>reply.Task.StartTime = time.Now()<br>reply.NReduce = c.nReduce<br>reply.Coordinatorstate = MapPhase<br><br><span class="hljs-comment">// c.ExcecuteState[reply.Task.Id].Task.TaskState = InProgress</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> c.IsAllDone() &#123;<br>fmt.Println(<span class="hljs-string">&quot;To the next Phase Reduce&quot;</span>)<br>c.NextPhase()<br>&#125;<br>reply.Task = &amp;Task&#123;&#125;<br>reply.Task.TaskType = Waiting<br>&#125;<br><span class="hljs-keyword">case</span> ReducePhase:<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c.ReduceTasks) &gt; <span class="hljs-number">0</span> &#123;<br>reply.Task = &lt;-c.ReduceTasks<br>reply.Task.TaskState = InProgress<br>reply.Task.StartTime = time.Now()<br>reply.NReduce = c.nReduce<br>reply.Coordinatorstate = ReducePhase<br><br><span class="hljs-comment">// c.ExcecuteState[reply.Task.Id].Task.TaskState = InProgress</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> c.IsAllDone() &#123;<br>fmt.Println(<span class="hljs-string">&quot;To the next Phase AllDone&quot;</span>)<br>c.NextPhase()<br>&#125;<br>reply.Task = &amp;Task&#123;&#125;<br>reply.Task.TaskType = Waiting<br>&#125;<br><span class="hljs-keyword">case</span> AllDone:<br><span class="hljs-keyword">if</span> c.IsAllDone() &#123;<br>reply.Coordinatorstate = AllDone<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="容错机制"><a href="#容错机制" class="headerlink" title="容错机制"></a>容错机制</h3><p>容错机制是分布式计算中一个很重要的功能，受限于各种因素，MapReduce中worker很有可能出现执行错误的问题，我们需要确保master能够一直与worker保持网络通信，worker返回给master的结果是正确的，并且在worker与master失联后能够将任务分配给其他的worker重新执行。因为master一般为单个机器，出现错误的可能性较小，暂不讨论。</p><h4 id="Worker-Failure"><a href="#Worker-Failure" class="headerlink" title="Worker Failure"></a>Worker Failure</h4><p>Master节点周期性的向worker节点发送Ping信号，若Worker节点长时间未恢复则默认节点不可用，将这个节点正在处理的任务标记为idle，并将这个task重新加入到等待队列中。下面是不同阶段出现worker failure的处理办法</p><ul><li>Map Task：无论Map task任务是否完成，Master都需要将重新分配给其他worker。并且worker失效意味着存储在本地的中间结果也是不可用的。若此时已经进入到Reduce阶段，那么Master还需要通知所有Reducer无法从过去的Mapper上读取中间结果，要从新的Mapper上获取数据。</li></ul><p>若一个map task 先被 Worker A执行，随后又被worker B执行，那么其他的reduce会被提示到此map task已被重新执行，读取中间结果将从B的地址读取。</p><ul><li>Reduce Task：已经完成的Reduce无需过多处理，因为Reduce的结果存储在GFS上；</li></ul><h4 id="hints"><a href="#hints" class="headerlink" title="hints"></a>hints</h4><p>map和reduce阶段必须是有严格的先后顺序的，可以使用<code>sync.Cond</code>解决，就是worker去要任务的时候，如果没有空闲的并且还有正在running的，就陷入沉睡，之后被<code>broadcast</code>唤醒然后返回。但这样做在no crash 下是可行的，如果有crash，就会发生这样的情况：几个worker在沉睡，正在运行的那个worker崩了，但没有worker能够调度去解决。 因此作如下改进：每次发现有worker failure，就随机唤醒单个worker，被唤醒的worker重新检查一下是否有任务；在所有任务完成时，将沉睡的worker全唤醒。</p><h4 id="Backup"><a href="#Backup" class="headerlink" title="Backup"></a>Backup</h4><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><h4 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h4><p>阿里CTO线面试：你做的MapReduce应用在实际生产中会存在什么问题？怎么解决这些问题？</p><ul><li>有可能存在一个worker节点，不停的向Master申请任务，并返回错误的执行结果</li></ul><p>解决方法：对worker节点做一些标记，一旦返回了错误的结果，悲观的认为这个节点以后也无法正确的执行，Master不再优先给这个节点分配任务</p><ul><li>落伍者(Stragglers)，有一个节点执行任务速度较慢，导致Master无法进入下一个阶段，所有节点阻塞等待</li></ul><p>解决方法：通过备用任务来处理执行较慢的任务，或者调用被sync.Cond睡眠的任务来代替</p><ul><li>重复执行？（节点失联后重新和master取得联系，之前的执行结果怎么办）</li></ul><p>解决办法：</p><ul><li>热点问题shuffle（例如map阶段将很多相同的单词都放入同一个中间结果，导致针对某一个reduce节点的执行速度过慢）</li></ul><p>解决办法：计算word的哈希值时加salt，让pair尽量分散到不同的hash bucket中，防止聚集现象</p><h4 id="实际情况"><a href="#实际情况" class="headerlink" title="实际情况"></a>实际情况</h4><ul><li>如何对数据进行分片？</li></ul><p>最好将Task读取的文件大小设定为128MB，接近HDFS中块的大小</p><ul><li>map阶段会存在缓冲区，不会让数据直接写入本地（防止频繁的IO）</li></ul><p>第一步对输入的数据进行切片，每个切片分配一个map()任务，map()对其中的数据进行计算，对每个数据用键值对的形式记录，然后输出到环形缓冲区map（）中输出的数据在环形缓冲区内进行快排，每个环形缓冲区默认大小100M，当数据达到80M时（默认），锁定这80M的数据并对其排序，分别按照partition和key排序（同一partition内key有序）</p><ul><li><p>如何做到负载均衡？</p></li><li><p>如何保证执行结果的正确性？</p></li><li><p>扩展性？</p></li></ul><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><blockquote><p>MapReduce Paper <a href="https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf">https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf</a></p><p>知乎 <a href="https://zhuanlan.zhihu.com/p/55884610">https://zhuanlan.zhihu.com/p/55884610</a></p><p>shuffle 过程 知乎  <a href="https://zhuanlan.zhihu.com/p/350428188">https://zhuanlan.zhihu.com/p/350428188</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Distributed System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GFS</title>
    <link href="/2022/09/29/GFS/"/>
    <url>/2022/09/29/GFS/</url>
    
    <content type="html"><![CDATA[<h2 id="Google-File-System"><a href="#Google-File-System" class="headerlink" title="Google File System"></a>Google File System</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>Linux中的file system能够将数据持久化并以文件的形式存储在磁盘上，以供操作系统使用。File system具备一些验证机制来保证用户态传入的数据是正确合法的，有一些文件系统还拥有备份机制以确保数据不会轻易丢失。</p><p>GFS是一个分布式的文件系统，与普通操作系统上的文件系统不同，它能够支持大型文件【TB级别】的一系列操作。GFS还提供了容错机制等，保证在多物理机条件下数据的正确性。GFS对外提供一系列与普通文件系统一致的接口，例如open close create delete write read，GFS底层的工作流程对使用者完全透明。</p><h3 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h3><p>A GFS cluster consists of a single master and multiple chunkservers and is accessed by multiple clients.</p><p>GFS将所有大型文件划分成无数个chunk，并在创建时用一个64bit的chunk handle来唯一标识，GFS通常会为每个chunk创建三个副本，以保证系统的健壮性。</p><p>GFS的single master结构使得master掌握了所有文件的meta data，其中包括了filenamespace，file所拥有的所有chunk id，以及chunk的位置（primary chunk, 租约, 孤儿chunk的垃圾回收机制, <strong>chunkserver间chunk的迁移</strong>）</p><p><img src="https://pic3.zhimg.com/v2-75851b9c18c4b4b4b84507a9122129fa_b.jpg" alt="img"></p><p>GFS client:负责接受应用程序传来的参数，是GFS唯一暴露给用户的地方，并且在client中缓存了许多master节点中保留的文件元数据，这样可以减少对single master的访问</p><p><img src="/2022/09/29/GFS/image-20220929224411327.png" alt="image-20220929224411327"></p><h3 id="Master-数据结构"><a href="#Master-数据结构" class="headerlink" title="Master 数据结构"></a>Master 数据结构</h3><p>包含的内容： </p><ul><li>file namespace (nv) , </li><li>filename  -  array of chunk handle (nv) ,  </li><li>chunk handle  -  version (nv) , list of chunk server, lease(租约)</li></ul><h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><ul><li>GFS append数据<ul><li>数据写入只能在primary chunk中写入<ul><li>若primary chunk不存在怎么办？</li><li>若primary版本与master中版本不一致怎么办</li></ul></li></ul></li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 并且在将版本号更新到Primary和Secondary服务器之后，如果Master节点故障重启，还是可以在相同的Primary和Secondary服务器上继续更新Chunk。<br><br>更新内容和传递日志操作被分离开<br><br><span class="hljs-bullet">2.</span> 版本号只会在Master指定一个新Primary时才会改变<br><span class="hljs-bullet">3.</span> <br></code></pre></td></tr></table></figure><h3 id="三写一读"><a href="#三写一读" class="headerlink" title="三写一读"></a>三写一读</h3><h3 id="GFS-的一致性模型"><a href="#GFS-的一致性模型" class="headerlink" title="GFS 的一致性模型"></a>GFS 的一致性模型</h3><p>GFS系统推荐append而不推荐modified</p><ul><li>append单次操作不能超过64MB即一个chunk的大小，若当前chunk剩余的空间不够存储append的内容，则padding当前chunk并写入一个新的chunk中<ul><li>每次的append操作都是在一个chunk上，所以可以保证一致性</li></ul></li></ul><p>重复追加的问题：ABCDEF ABCBCDEF?  记录文件长度和各副本定期检验</p>]]></content>
    
    
    
    <tags>
      
      <tag>Distributed System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab8-lock</title>
    <link href="/2022/03/17/Lab8-lock/"/>
    <url>/2022/03/17/Lab8-lock/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>xv6_riscv Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Boot</title>
    <link href="/2022/03/12/Boot/"/>
    <url>/2022/03/12/Boot/</url>
    
    <content type="html"><![CDATA[<h2 id="Boot"><a href="#Boot" class="headerlink" title="Boot"></a>Boot</h2><p>x86为例：</p><ol><li>加电后，CS&#x3D;0xF000 EIP&#x3D;0xFFF0 在CS寄存器中隐含的一个基址BASE&#x3D;FFFF0000，80386中实际地址是BASE+EIP&#x3D;FFFF0000h+0000FFF0h&#x3D;0xFFFFFFF0h（在8086中最初执行的地址是PC&#x3D;16×CS+IP，其实在GDB下调试ffffffff0h地址下的命令和ffff0地址处的命令相同，可能这就是8086架构的兼容）</li><li>这是<strong>BIOS的EPROM所在地（只读）</strong>，从该地址中读取第一条指令，一般为长跳转指令，跳转到真正的BIOS中去执行即跳转到可以被访问的1M的内存空间中（在实模式下只能访问1M空间）。在实模式下寻址为PC&#x3D;16×CS+IP。BIOS先做初始化工作（初始化底层硬件），然后加载存储设备（硬盘，光盘，优盘）上的第一个扇区（主引导扇区）的512字节到内存的0x7c00,cpu执行0x7c00的指令开始执行，也就是bootloader。</li><li>主引导扇区位于整个硬盘的 0 磁头 0 柱面 1 扇区，包括硬盘主引导记录 MBR （ MasterBootRecord ）和分区表 DPT （ DiskPartitionTable ）。规范的主引导扇区特征如下：<br>[1] 总大小为 512 字节，由主引导程序、分区表、结束标志三部分构成；<br>[2] 引导程序，从 0x0 位置起共 446 字节（隐含 windows 磁盘签名）；<br>[3] 分区表，占用 64 字节，是 MBR 中的重要结构；<br>[4] 结束标志，扇区的最后两个字节 “55AA” 是 MBR 的结束标志。</li><li></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Operating System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>希罗多德HISTORIAE读书笔记</title>
    <link href="/2022/03/10/%E5%B8%8C%E7%BD%97%E5%A4%9A%E5%BE%B7HISTORIAE%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/03/10/%E5%B8%8C%E7%BD%97%E5%A4%9A%E5%BE%B7HISTORIAE%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>巨大的繁荣是一个很不可靠的东西，它会导致衰落</strong></p><p>希罗多德出生于波斯治下的希腊城市哈利卡纳苏斯，是波斯帝国的第一省区，本书的内容也是围绕波斯战争所展开的，所以希罗多德既可以被称作希腊史学家，也可以被称作波斯史学家。公元前443年，他移居雅典在意大利的殖民城邦图里伊，后来也被称作图里伊的希罗多德。</p><p>从公元前六世纪，希腊人的思想方式逐渐从神话方式转向理性方式，其重要的标志就是哲学的兴起。人们逐渐意识到自己的认知能力的无限潜力以及自我感受的 重要性，以自身的任直隶和自我感受来理解和把握。《历史》及带有一点旧时代特色，又有许多创新。</p><p><img src="/2022/03/10/%E5%B8%8C%E7%BD%97%E5%A4%9A%E5%BE%B7HISTORIAE%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E4%BD%93%E5%9C%B0%E5%9B%BE.png" alt="image-20220310233126287"></p><hr><p>希罗多德出生在小亚细亚西部，这是当时整个东地中海地区经济文化最发达的地方。随着波斯帝国的崛起，其征服西亚、北非等地区导致了经济文化的大融合。爱琴海东岸，小亚细亚西部沿海地区在吸收古代优秀成果发展成希腊世界经济文化最先进的地区，大多哲学家文学家都出生于此。</p><p><img src="/2022/03/10/%E5%B8%8C%E7%BD%97%E5%A4%9A%E5%BE%B7HISTORIAE%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B3%A2%E6%96%AF%E5%B8%9D%E5%9B%BD.png" alt="image-20220310234432040"></p><p>波斯帝国（公元前550年—公元前330年），伊朗伊斯兰共和国历史政权，又称阿契美尼德王朝。公元前6世纪，波斯人被米底王国统治，后在居鲁士二世的领导下反抗米底，公元前550年灭掉米底王国，建立波斯帝国。此后，居鲁士二世和儿子冈比西斯二世又先后攻灭吕底亚王国、新巴比伦王国和埃及王国，扩大了波斯帝国疆域。公元前513年，大流士一世攻占色雷斯，波斯帝国疆域横跨亚细亚洲、阿非利加洲、欧罗巴洲三大洲。大流士一世统治时期，采取一系列改革，波斯帝国达到鼎盛。<br>大流士一世、薛西斯一世和阿尔塔薛西斯一世统治时期，波斯帝国为征服希腊城邦，发动了波希战争，最终失败，消耗了波斯帝国综合国力，波斯帝国从此衰落。公元前334年，马其顿王国国王亚历山大三世东征，进攻波斯帝国。衰败的波斯帝国一溃千里，丢失大片领土。公元前330年，波斯帝国末代国王大流士三世被杀，波斯帝国灭亡。</p><hr><p>希罗多德试图以一种批判的态度探索人类的过去和未来，在那个时代历史是探究未知领域，未知的世界，这与哲学和科学可谓殊途同归。</p><p>根据上面的简述，我们知道波斯人为了击溃希腊花费了大量的兵力，但事与愿违，希腊人赢得了这场不可思议的胜利，这也促使人们去探究：波斯人是如何兴起以及扩张？希腊人和异族人的冲突的原因究竟是什么？他们是如何战胜波斯人的？所以本书以波斯战争为主线进行探究。</p>]]></content>
    
    
    
    <tags>
      
      <tag>HISTORIAE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab9</title>
    <link href="/2022/03/10/Lab9-filesystem/"/>
    <url>/2022/03/10/Lab9-filesystem/</url>
    
    <content type="html"><![CDATA[<h2 id="FileSystem"><a href="#FileSystem" class="headerlink" title="FileSystem"></a>FileSystem</h2><p><img src="/2022/03/10/Lab9-filesystem/layer.png" alt="image-20220413195444033"></p><p>xv6中文件系统分为七层</p><ol><li>Disk ：SSD HDD 主要是硬件层次，负责将硬件资源加载入内存（Sectors）</li><li>Buffer Cache : 一般是对常用的内存块进行缓存，一般是一个buf是1024</li><li>Logging : 是日志层，主要负责记录日志</li><li>Inode : 每个inode节点指示了一个文件，inode的编号也是文件的唯一标识</li><li>Dir : 目录</li><li>PathName : 路径名</li><li>file descriptor：文件描述符，指向了一个inode，但不同的fd可以指向同一个inode</li></ol><hr><h3 id="一些重要的函数"><a href="#一些重要的函数" class="headerlink" title="一些重要的函数"></a>一些重要的函数</h3><p><strong>bget()</strong> 根据扇区号返回一个buf的地址，若buffer cache中没有对应的扇区，则利用LRU算法从bcache的头部开始找到一个空闲的buf分配出去；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Look through buffer cache for block on device dev.</span><br><span class="hljs-comment">// If not found, allocate a buffer.</span><br><span class="hljs-comment">// In either case, return locked buffer.</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> buf*<br><span class="hljs-title function_">bget</span><span class="hljs-params">(uint dev, uint blockno)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">b</span>;</span><br><br>  acquire(&amp;bcache.lock);<br><br>  <span class="hljs-comment">// Is the block already cached?</span><br>  <span class="hljs-keyword">for</span>(b = bcache.head.next; b != &amp;bcache.head; b = b-&gt;next)&#123;<br>    <span class="hljs-keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;<br>      b-&gt;refcnt++;<br>      release(&amp;bcache.lock);<br>      acquiresleep(&amp;b-&gt;lock);<br>      <span class="hljs-keyword">return</span> b;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// Not cached.</span><br>  <span class="hljs-comment">// Recycle the least recently used (LRU) unused buffer.</span><br>  <span class="hljs-keyword">for</span>(b = bcache.head.prev; b != &amp;bcache.head; b = b-&gt;prev)&#123;<br>    <span class="hljs-keyword">if</span>(b-&gt;refcnt == <span class="hljs-number">0</span>) &#123;<br>      b-&gt;dev = dev;<br>      b-&gt;blockno = blockno;<br>      b-&gt;valid = <span class="hljs-number">0</span>;<br>      b-&gt;refcnt = <span class="hljs-number">1</span>;<br>      release(&amp;bcache.lock);<br>      acquiresleep(&amp;b-&gt;lock);<br>      <span class="hljs-keyword">return</span> b;<br>    &#125;<br>  &#125;<br>  panic(<span class="hljs-string">&quot;bget: no buffers&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>bread()</strong> 调用<code>bget</code>为给定扇区（*<strong>kernel&#x2F;bio.c*</strong>:97）获取缓冲区。如果缓冲区需要从磁盘进行读取，<code>bread</code>会在返回缓冲区之前调用<code>virtio_disk_rw</code>来执行此操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Return a locked buf with the contents of the indicated block.</span><br><span class="hljs-keyword">struct</span> buf*<br><span class="hljs-title function_">bread</span><span class="hljs-params">(uint dev, uint blockno)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">b</span>;</span><br>  <span class="hljs-comment">// 返回了buf的地址</span><br>  b = bget(dev, blockno);<br>  <span class="hljs-keyword">if</span>(!b-&gt;valid) &#123;<br>    <span class="hljs-comment">// 以buf为单位读写</span><br>    virtio_disk_rw(b, <span class="hljs-number">0</span>);<br>    b-&gt;valid = <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> b;<br>&#125;<br></code></pre></td></tr></table></figure><p>**bread()<strong>和</strong>bget()**的区别：</p><p><strong>bget</strong>只负责在缓冲区中寻找合适的buf，如果不存在cache中，则要通过bread中的函数从磁盘读写</p><hr><p><strong>bmap()</strong> 负责根据逻辑块号，定位物理块号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Inode content</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The content (data) associated with each inode is stored</span><br><span class="hljs-comment">// in blocks on the disk. The first NDIRECT block numbers</span><br><span class="hljs-comment">// are listed in ip-&gt;addrs[].  The next NINDIRECT blocks are</span><br><span class="hljs-comment">// listed in block ip-&gt;addrs[NDIRECT].</span><br><br><span class="hljs-comment">// Return the disk block address of the nth block in inode ip.</span><br><span class="hljs-comment">// If there is no such block, bmap allocates one.</span><br><span class="hljs-type">static</span> uint<br><span class="hljs-title function_">bmap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *ip, uint bn)</span><br>&#123;<br>  uint addr, *a;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br><br>  <span class="hljs-keyword">if</span>(bn &lt; NDIRECT)&#123;<br>    <span class="hljs-keyword">if</span>((addr = ip-&gt;addrs[bn]) == <span class="hljs-number">0</span>)<br>      ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);<br>    <span class="hljs-keyword">return</span> addr;<br>  &#125;<br>  bn -= NDIRECT;<br><br>  <span class="hljs-keyword">if</span>(bn &lt; NINDIRECT)&#123;<br>    <span class="hljs-comment">// Load indirect block, allocating if necessary.</span><br>    <span class="hljs-keyword">if</span>((addr = ip-&gt;addrs[NDIRECT]) == <span class="hljs-number">0</span>)<br>      ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);<br>    bp = bread(ip-&gt;dev, addr);<br>    a = (uint*)bp-&gt;data;<br>    <span class="hljs-keyword">if</span>((addr = a[bn]) == <span class="hljs-number">0</span>)&#123;<br>      a[bn] = addr = balloc(ip-&gt;dev);<br>      log_write(bp);<br>    &#125;<br>    brelse(bp);<br>    <span class="hljs-keyword">return</span> addr;<br>  &#125;<br>  bn -= NINDIRECT;<br><br>  <span class="hljs-keyword">if</span>(bn &lt; NINDIRECT_LEVEL2)&#123;<br>    <span class="hljs-comment">// Load indirect_level2 block, allocating if necessary.</span><br>    <span class="hljs-keyword">if</span>((addr = ip-&gt;addrs[NDIRECT+<span class="hljs-number">1</span>]) == <span class="hljs-number">0</span>)<br>      ip-&gt;addrs[NDIRECT+<span class="hljs-number">1</span>] = addr = balloc(ip-&gt;dev);<br>    bp = bread(ip-&gt;dev, addr);<br>    a = (uint*)bp-&gt;data;<br>    <span class="hljs-comment">// 一级块号</span><br>    <span class="hljs-type">int</span> num = bn / NINDIRECT;<br>    <span class="hljs-comment">// 二级块号</span><br>    <span class="hljs-type">int</span> n = bn % NINDIRECT;<br><br>    <span class="hljs-keyword">if</span>((addr = a[num]) == <span class="hljs-number">0</span>)&#123;<br>      a[num] = addr = balloc(ip-&gt;dev);<br>      log_write(bp);<br>    &#125;<br>    brelse(bp);<br>    <span class="hljs-comment">//  这个锁的问题需要注意释放原因：bread和bwrite时都申请了睡眠锁，需brelease</span><br>    <span class="hljs-comment">//  ---------------------------------------------</span><br>    bp = bread(ip-&gt;dev, addr);<br>    a = (uint*)bp-&gt;data;<br>    <span class="hljs-keyword">if</span>((addr = a[n]) == <span class="hljs-number">0</span>)&#123;<br>      a[n] = addr = balloc(ip-&gt;dev);<br>      log_write(bp);<br>    &#125;<br>    brelse(bp);<br>    <span class="hljs-keyword">return</span> addr;<br>  &#125;<br><br>  panic(<span class="hljs-string">&quot;bmap: out of range&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>iget()</p><p>iput()</p><p><a href="https://www.cnblogs.com/charlesblc/p/6263665.html">https://www.cnblogs.com/charlesblc/p/6263665.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>xv6_riscv Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab4-trap</title>
    <link href="/2022/03/08/Lab4-trap/"/>
    <url>/2022/03/08/Lab4-trap/</url>
    
    <content type="html"><![CDATA[<h2 id="Trap"><a href="#Trap" class="headerlink" title="Trap"></a>Trap</h2><h3 id="RISC-V-assembly-easy"><a href="#RISC-V-assembly-easy" class="headerlink" title="RISC-V assembly (easy)"></a>RISC-V assembly (easy)</h3><ul><li>caller saved register</li></ul><p>​函数调用时无需关注的寄存器就是caller saved register，<u>例如return address 则是caller saved register地址，既subfuction调用完毕后应当回到的地址。当函数调用结束时ra寄存器一定会被改写，所以要将call指令所在的地址+1作为ra并存储在某处</u></p><ol><li>哪些寄存器保存函数的参数？例如，在<code>main</code>对<code>printf</code>的调用中，哪个寄存器保存13？</li></ol><ul><li>riscv中通过a0-a7八个寄存器传递参数，如果参数多余8个则通过栈帧传递。</li></ul><p><img src="/2022/03/08/Lab4-trap/image-20221028145622994.png" alt="image-20221028145622994"></p><p><img src="/2022/03/08/Lab4-trap/image-20221028145016637.png" alt="image-20221028145016637"></p><ol><li><code>main</code>的汇编代码中对函数<code>f</code>的调用在哪里？对<code>g</code>的调用在哪里(提示：编译器可能会将函数内联）</li></ol><ul><li>编译器在此处做了编译优化，直接传递g和f的结果给printf</li></ul><ol start="2"><li><code>printf</code>函数位于哪个地址？</li></ol><ul><li>65a</li></ul><ol start="3"><li>在<code>main</code>中<code>printf</code>的<code>jalr</code>之后的寄存器<code>ra</code>中有什么值？</li></ol><ul><li>ra保存的调用结束后返回的地址，即34的下一条指令的地址38</li></ul><ol start="4"><li>运行以下代码。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0x00646c72</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;H%x Wo%s&quot;</span>, <span class="hljs-number">57616</span>, &amp;i);<br></code></pre></td></tr></table></figure><p>执行结果 HE110 World</p><ul><li>57616换算成16进制的结果是E110，%x则是直接打印16进制结果，%s则是以字符串（一个字符1一个字节8位）的形式打印，RISCV是小端存储低位字序排在低字节端，因此i的0x72（114）会被优先打印出来一次类推</li></ul><h3 id="Backtrace-moderate"><a href="#Backtrace-moderate" class="headerlink" title="Backtrace(moderate)"></a>Backtrace(moderate)</h3><p>函数调用栈帧如下图所示，每个stackframe都有一些固定的结构，这些stackframe固定在用户栈下，用户栈的大小固定为一个PGSIZE。<strong>因此当我们无限调用递归函数时，可能出现栈溢出的情况。</strong></p><ul><li>由下图我们就知道无限的递归为什么会造成OOM问题了（doge）</li></ul><p>fp(或叫s0寄存器)表示调用栈的最高位，sp表示调用栈的最底部，fp - sp 则是生成栈的长度,一般会通过prologue阶段生成。</p><p>在fp(0)的位置存储着调用结束后的return address，调用阶段结束会将这个值重新赋给ra寄存器。fp(-8)的位置存储着上一个栈帧的fp，在所有寄存器现场恢复后会修改取出fp并修改当前fp。</p><p><img src="/2022/03/08/Lab4-trap/image-20221028151232243.png" alt="image-20221028151232243"></p><p><img src="/2022/03/08/Lab4-trap/image-20221028152230459.png" alt="image-20221028152230459"></p><ul><li>question fp中读取的为什么是地址？</li></ul><h3 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h3><h4 id="trap-机制"><a href="#trap-机制" class="headerlink" title="trap 机制"></a>trap 机制</h4><img src="/2022/03/08/Lab4-trap/image-20221101183358245.png" alt="image-20221101183358245" style="zoom:67%;"><p>ecall：由于RISCV将<strong>系统调用、异常、中断</strong>都归纳为trap，所以ecall指令在RISCV中会被频繁的调用，为了减少trap机制的开销，ecall所能提供的功能非常有限。ecall的功能有如下几点</p><ul><li><p>将xv6由用户态切换至内核态， user mode &#x3D;&gt; supervisor mode</p></li><li><p>将pc保存至sepc寄存器</p></li><li><p>pc指针切换至stvec的内容（即trampoline的起始位置</p></li><li><p>保存32个用户寄存器的内容，这样当我们想要恢复用户代码执行时，我们才能恢复这些寄存器的内容。</p></li><li><p>ecall指令刚开始satp指向user page table，trampoline执行会切换到kernel page table</p></li><li><p>我们需要创建或者找到一个kernel stack，并将Stack Pointer寄存器的内容指向那个kernel stack。这样才能给C代码提供栈</p></li><li><p>我们还需要跳转到内核中C代码的某些合理的位置</p></li></ul><p>uservec：</p><ul><li>在trampoline中保存了CPU当前的现场（32个通用寄存器以及），并恢复内核态的寄存器状态</li></ul><p>usertrap:</p><ul><li>xv6会在usertrap中判断trap是系统调用还是异常或中断，并根据trap类型执行对应函数</li></ul><h4 id="Alarm-1"><a href="#Alarm-1" class="headerlink" title="Alarm"></a>Alarm</h4><p>您需要修改<code>usertrap()</code>，以便当进程的报警间隔期满时，用户进程执行处理程序函数。当RISC-V上的陷阱返回到用户空间时，什么决定了用户空间代码恢复执行的指令地址？</p><p><strong>本实验的一个目的在于，实现某种能够在用户态处理中断或故障的机制</strong></p><p>trap的过程简述：</p><ol><li><code>ecall</code>指令中将PC保存到SEPC</li><li>在<code>usertrap</code>中将SEPC保存到<code>p-&gt;trapframe-&gt;epc</code></li><li><code>p-&gt;trapframe-&gt;epc</code>加4指向下一条指令</li><li>执行系统调用</li><li>在<code>usertrapret</code>中将SEPC改写为<code>p-&gt;trapframe-&gt;epc</code>中的值</li><li>在<code>sret</code>中将PC设置为SEPC的值</li></ol><ul><li>在usertrap中若要执行报警函数，并不是直接将pc的内容改为报警函数的地址，而是在修改trampframe中的epc，在trap返回时会将pc的值修改为报警函数的地址</li></ul><p>我们还要确保报警函数执行完毕后能恢复报警函数执行前CPU的状态，因此在这之前要保存当时的所有寄存器，在sigreturn中恢复即可。</p><h5 id="修改proc"><a href="#修改proc" class="headerlink" title="修改proc"></a>修改proc</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> strcut proc&#123;<br>...<br><span class="hljs-type">int</span> interval;          <span class="hljs-comment">// 触发间隔</span><br><span class="hljs-type">void</span> (*alarm_handler)();     <span class="hljs-comment">// 用户态处理函数</span><br><span class="hljs-type">int</span> count;             <span class="hljs-comment">// 触发计数器</span><br>  <span class="hljs-type">int</span> is_alarming;                    <span class="hljs-comment">// 是否正在调用alarm_handler</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span>* <span class="hljs-title">alarm_trapframe</span>;</span> <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>为什么需要一个alarm_trapframe和is_alarming？</li></ul><p>首先我们要确保我们进入alarmhandler之后还能正确的还原trap之前的状态，alarm_handler有可能更改用户寄存器的内容，因此我们要在进入handler之前保存好用户寄存器的状态，在handler结束时恢复这个状态；is_alarming是为了防止重复陷入（大佬说的。。）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// give up the CPU if this is a timer interrupt.</span><br><span class="hljs-keyword">if</span>(which_dev == <span class="hljs-number">2</span>) &#123;<br>  <span class="hljs-keyword">if</span>(p-&gt;alarm_interval != <span class="hljs-number">0</span> &amp;&amp; ++p-&gt;ticks_count == p-&gt;alarm_interval &amp;&amp; p-&gt;is_alarming == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 保存寄存器内容</span><br>    memmove(p-&gt;alarm_trapframe, p-&gt;trapframe, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> trapframe));<br>    <span class="hljs-comment">// 更改陷阱帧中保留的程序计数器，注意一定要在保存寄存器内容后再设置epc</span><br>    p-&gt;trapframe-&gt;epc = (uint64)p-&gt;alarm_handler;<br>    p-&gt;ticks_count = <span class="hljs-number">0</span>;<br>    p-&gt;is_alarming = <span class="hljs-number">1</span>;<br>  &#125;<br>  yield();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>这个lab本身难度不大，主要是让我们熟悉一下xv6 trap机制，并利用trap设计一些有意思的函数，比如通过改变epc的值能够使用用户指定的函数来处理中断</p>]]></content>
    
    
    
    <tags>
      
      <tag>xv6_riscv Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode</title>
    <link href="/2022/02/26/leetcode/"/>
    <url>/2022/02/26/leetcode/</url>
    
    <content type="html"><![CDATA[<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p><strong>算法的核心就是穷举所有可能的结果，并从这些结果中找到符合要求的一项。所以在我们解决问题时需要对问题进行拆解，将问题放入我们已经熟悉的模版中，利用模版并对当前条件进行调整从而解决问题</strong></p><h3 id="双指针-数组-链表"><a href="#双指针-数组-链表" class="headerlink" title="双指针 数组 链表"></a>双指针 数组 链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// array</span><br><span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> fast = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// linklist 链表有时还会用到dummy节点</span><br>ListNode *slow = head;<span class="hljs-comment">// ListNode* dummy = new ListNode();</span><br>ListNode *fast = slow;<br></code></pre></td></tr></table></figure><p>  主要用来处理数组和链表问题，主要有快慢指针和双指针两种。快慢指针一般是通向，一块一慢；双指针一般是相向相背前进。</p><h4 id="快慢指针（滑动窗口）"><a href="#快慢指针（滑动窗口）" class="headerlink" title="快慢指针（滑动窗口）"></a>快慢指针（滑动窗口）</h4><ol><li>一般用nums[slow…fast]代表结果串，fast作为索引去处理或判断节点是否符合题意</li><li></li></ol><h5 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26. 删除有序数组中的重复项"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/">26. 删除有序数组中的重复项</a></h5><h5 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a><a href="https://leetcode.cn/problems/remove-element/description/">27. 移除元素</a></h5><h5 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></h5><p><strong>子数组问题</strong>，为了保持数组连续，可以选择使用滑动窗口的方法，但是要控制好窗口的移动</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>  <span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> fast = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span>(fast &lt; nums.<span class="hljs-built_in">size</span>())&#123;<br>    sum += nums[fast];<br>    <span class="hljs-keyword">while</span>(sum &gt;= target)&#123;<br>      <span class="hljs-keyword">if</span>(sum == target)&#123;<br><span class="hljs-comment">// to do for result</span><br>      &#125;<br>      sum -= nums[slow];<br>      slow++;<br>    &#125;<br>    fast++;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>对一段子数组或区间（可以是一维可以是二维）求和都可以使用<strong>前缀和数组</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 用来求i到j之间的和</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; nums)</span></span>&#123;<br><span class="hljs-type">int</span> size = nums.<span class="hljs-built_in">size</span>();<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preSum</span><span class="hljs-params">(size, <span class="hljs-number">0</span>)</span></span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; sz; i++)&#123;<br>    preSum[i] = preSum[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">preSum</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; nums)&#123;<br><span class="hljs-comment">// 矩形算面积的方法构建preSum</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>前缀和 + 哈希表</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 用来求i到j之间的和</span><br><span class="hljs-comment">// 找到和为k的子数组  </span><br><span class="hljs-comment">// preSum[i] - preSum[j] == k ===&gt; preSum[j] == preSum[i] - k</span><br><span class="hljs-comment">// preSum[j] 就是我们要找的前缀和，只需要在哈希表中判断是否存在这样一个前缀和为preSum[i] - k的值即可</span><br><span class="hljs-comment">// 找到平局值为k的字数组</span><br><span class="hljs-comment">// preSum[i] - preSum[j] = k*(i - j)</span><br><span class="hljs-comment">// preSum[j] - k * j = preSum[i] - k * i</span><br><span class="hljs-comment">// preSum[j] - k * j 就是我们要找的前缀和，只需要在哈希表中判断是否存在这样一个前缀和为preSum[i] - k * i的值即可</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">findSubArr</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; nums, <span class="hljs-type">int</span> k)</span></span>&#123;<br><span class="hljs-comment">//nums     1 3 2  4  1 </span><br><span class="hljs-comment">//preSum 0 1 4 6 10 11 </span><br><span class="hljs-type">int</span> size = nums.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>;<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preSum</span><span class="hljs-params">(size, <span class="hljs-number">0</span>)</span></span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; sz; i++)&#123;<br>    preSum[i] = preSum[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br>  &#125;<br>  <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>  map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; subArr_map;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)&#123;<br>    <span class="hljs-keyword">if</span>(subArr_map.<span class="hljs-built_in">count</span>(preSum[i] - k) != <span class="hljs-number">0</span>)&#123;<br>      result = subArr_map[preSum[i] - k];<br>      subArr_map[preSum[i]] = subArr_map[preSum[i] - k] + <span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      subArr_map[preSum[i]] = <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>对一段子数组或区间，进行增减或者操作，可以使用差分数组</li></ul><h4 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a>回文子串</h4><h5 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串</a></h5><ol><li>奇数长度的回文串 奇数长度时left &#x3D;&#x3D; right向外扩散</li><li>偶数长度的回文串 偶数长度时正常向外扩散</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">judge</span><span class="hljs-params">(string str, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span>&#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-number">0</span> &lt;= left &amp;&amp; right &lt; str.<span class="hljs-built_in">size</span>() &amp;&amp; str[left] == str[right])&#123;<br>    left++;<br>    right--;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(left+<span class="hljs-number">1</span>&gt;right)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-keyword">return</span>  s.<span class="hljs-built_in">substr</span>(left+<span class="hljs-number">1</span>, right-left<span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二叉树专题"><a href="#二叉树专题" class="headerlink" title="二叉树专题"></a>二叉树专题</h3><h4 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h4><p>二叉树的题目以二叉树的遍历为核心，通过不同的遍历顺序对树种节点操作，并返回结果。</p><p>pre_order:先序遍历会在进入节点的时候对节点进行操作</p><p>in_order:中序遍历是二叉树所特有的遍历方式，一般用在二叉搜索树中</p><p>post_order:后序遍历会在离开当前节点时对节点进行操作，<strong>离开节点时意味着已经拥有了左右子树的相关信息</strong></p><ul><li><strong>后序遍历有分而治之的思想，即先将问题划分成两个小问题，合并后大问题自然就解决了</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">order</span><span class="hljs-params">(TreeNode* root)</span>&#123;<span class="hljs-comment">// 1. 首先确定传入参数与返回值</span><br>    <span class="hljs-keyword">if</span>(root == null)<span class="hljs-comment">// 2. 确定如何结束，二叉树一般是遍历到底层的叶子节点</span><br>        <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-comment">// pre_order// 3. 确定何时对节点进行操作以及操作细节</span><br>    order(root-&gt;left);<br>    <span class="hljs-comment">// in_order</span><br>    order(root-&gt;right);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a><a href="https://leetcode.cn/problems/merge-two-binary-trees/solutions/">617. 合并二叉树</a></h5><p>思路: 如果节点的左子树和右子树都被合并了，那只需要将当前节点合并即可</p><ol><li>传入参数：两个树的节点</li><li>返回值：合并后的二叉树根节点 root1</li><li>暂停条件：若root1为nullptr，返回root2；若root2为nullptr同理</li></ol><h5 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h5><p>思路：如果我们知道左子树和右子树的高度，只需取二者的最大值并+1即可</p><ol><li>返回值：子树高度</li></ol><h5 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h5><p>思路：如果我们知道从左子树出发到最近叶子节点的距离和右子树出发到最近叶子节点的距离，只需取二者的最小值并+1即可</p><ol><li>返回值：距离叶子节点最近的距离</li><li>操作：<strong>判断返回的距离是否是到达叶子节点的距离</strong></li></ol><ul><li>如果左右子树返回均为0，则证明当前节点为叶子节点；若左右子树有任一节点返回不为0，则证明当前节点并非叶子节点</li></ul><h5 id="110-平衡二叉树判断它是否是高度平衡的二叉树。"><a href="#110-平衡二叉树判断它是否是高度平衡的二叉树。" class="headerlink" title="110. 平衡二叉树判断它是否是高度平衡的二叉树。"></a><a href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树</a>判断它是否是高度平衡的二叉树。</h5><p>思路：高度平衡表示左右子树高度差不大于1</p><ol><li>返回值：是否是高度平衡的二叉树</li></ol><h5 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h5><p>思路：后续或者前序确定root，中序确定左右子树的范围</p><ol><li><p>返回值：返回构造的二叉树</p></li><li><p>参数：后序、中序遍历的数组范围  </p></li><li><p>终止：</p></li></ol><h5 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501. 二叉搜索树中的众数"></a><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/description/">501. 二叉搜索树中的众数</a></h5><h5 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450. 删除二叉搜索树中的节点"></a><a href="https://leetcode.cn/problems/delete-node-in-a-bst/description/">450. 删除二叉搜索树中的节点</a></h5><h5 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></h5><p>思路：二叉树的问题可以被拆解为每一个字节点的任务，我们只需根据函数定义处理一个节点上的情况即可递归的得到全部的结果。本题目如果只依赖一个节点肯定无法实现跨节点的连接，因此我们需要传入两个参数，即传入两个相邻的节点。</p><h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><p><strong>你甚至可以这样理解：快速排序的过程是一个构造二叉搜索树的过程(基本就是一个前序遍历，先将一个元素的位置确定，再确定左右两侧元素的顺序)</strong></p><h5 id="215-TopK-数组中最大的第k个元素"><a href="#215-TopK-数组中最大的第k个元素" class="headerlink" title="215.TopK, 数组中最大的第k个元素"></a><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/submissions/400771309/">215.TopK, 数组中最大的第k个元素</a></h5><p>快速排序可以理解为某中意义上的前序排序。quicksort  每次排序会先确定一个数的位置并确保这个数之前的都是小于它的，之后的数都是大于它的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;num, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high, <span class="hljs-type">int</span> k)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(low &lt; high)&#123;<br>      <span class="hljs-type">int</span> pos = <span class="hljs-built_in">partation</span>(num, low, high);<br>      <span class="hljs-keyword">if</span>(pos &lt; k)&#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-built_in">sort</span>(num, pos + <span class="hljs-number">1</span>, high, k);<br>      &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pos == k)&#123;<br>          <span class="hljs-keyword">return</span> num[k];<br>      &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k &lt; pos)&#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-built_in">sort</span>(num, low, pos - <span class="hljs-number">1</span>, k);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> num[low];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partation</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;num, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span>&#123;<br>    <span class="hljs-type">int</span> pivot = num[low];<br>    <span class="hljs-keyword">while</span>(low &lt; high)&#123;<br>        <span class="hljs-keyword">while</span>(low &lt; high &amp;&amp; pivot &lt;= num[high])&#123;<br>            high--;<br>        &#125;<br>        num[low] = num[high];<br>        <span class="hljs-keyword">while</span>(low &lt; high &amp;&amp; num[low] &lt;= pivot)&#123;<br>            low++;<br>        &#125;<br>        num[high] = num[low];<br>    &#125;<br>    num[low] = pivot;<br>    <span class="hljs-keyword">return</span> low;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h3><p>反转链表:主要还是围绕递归，所以关于链表的题目我们要明确递归函数的定义（递归函数的输入是什么，输出是什么，中间做了什么）</p><ul><li>反转链表</li></ul><p>reverse(ListNode* head)函数表示反转从head开始的链表，并返回新的头节点，因此我们只需要接受新的头节点并作为最终头节点，并反转当前节点即可（当前节点的next指针还连接着一个节点）</p><p><strong>有点像是把当前节点重新插入一个链表的尾部</strong></p><ul><li>反转链表中前N个数</li></ul><p>reverse(ListNode* head, int n)函数表示反转从head开始的N个数，并返回新的头节点，因此我们只需要接受新的头节点并作为最终头节点，并把当前节点插入已经反转的链表中（这时需要注意要存下来第N + 1个节点，并让当前节点指向N+1个节点 ）</p><ul><li>两两交换反转链表</li></ul><p>ListNode* swapPairs(ListNode* head) 函数表示反转head开始的两个节点，并返回新的头节点；我们可以先反转两个节点，并接着反转后面的节点，也可以先接收后面已经反转成功的链表。再反转head和head-&gt;next</p><ul><li>反转left到right之间的数</li></ul><p>利用反转前N个数的函数定义</p><ul><li>K个一组反转链表</li></ul><p>和两个一组交换节点的感觉差不多，先反转k个节点，再接收后面已经反转好的链表</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p><strong>我们一般用动态规划求解最值问题，例如fib，如何爬楼梯，零钱兑换等问题，一般不需要具体的例子，只需要一个结果即可</strong></p><ul><li><p>dp数组负责记录过去某一时刻的状态，动态规划则是构造dp数组并找到合适的结果，所以动态规划可以解决子数组或者子序列等问题（其中dp[i]表示第i个字符状态为截止的状态，最长递增子序列，最大子数组之和），<strong>所以动态规划的题目要明确dp数组的含义</strong></p></li><li><p>所有设计到递归函数的问题我们都需要确定函数的定义，根据函数的定义进出递归函数</p></li><li><p>动态规划的核心是<strong>穷举</strong>，从所有可行答案中找出最值。</p></li></ul><ol><li><strong>列出正确的状态转移方程</strong></li><li>判断是否具有<strong>最优子结构</strong>，能否通过子问题的最值得到原问题的最值</li><li>判断重叠子问题</li></ol><p><strong>明确 base case -&gt; 明确「状态」-&gt; 明确「选择」 -&gt; 定义 <code>dp</code> 数组&#x2F;函数的含义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 自顶向下递归的动态规划</span><br>def <span class="hljs-title function_">dp</span><span class="hljs-params">(状态<span class="hljs-number">1</span>, 状态<span class="hljs-number">2</span>, ...)</span>:<br>    <span class="hljs-keyword">for</span> 选择 in 所有可能的选择:<br>        # 此时的状态已经因为做了选择而改变<br>        result = 求最值(result, dp(状态<span class="hljs-number">1</span>, 状态<span class="hljs-number">2</span>, ...))<br>    <span class="hljs-keyword">return</span> result<br><br><span class="hljs-comment">// 自底向上迭代的动态规划  // 爬楼梯 fib</span><br><span class="hljs-comment">// 初始化 base case</span><br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][...] = base <span class="hljs-keyword">case</span><br><span class="hljs-comment">// 进行状态转移</span><br><span class="hljs-keyword">for</span> 状态<span class="hljs-number">1</span> in 状态<span class="hljs-number">1</span>的所有取值：<br>    <span class="hljs-keyword">for</span> 状态<span class="hljs-number">2</span> in 状态<span class="hljs-number">2</span>的所有取值：<br>        <span class="hljs-keyword">for</span> ...<br>            dp[状态<span class="hljs-number">1</span>][状态<span class="hljs-number">2</span>][...] = 求最值(选择<span class="hljs-number">1</span>，选择<span class="hljs-number">2.</span>..)<br></code></pre></td></tr></table></figure><p><strong>最优子结构</strong></p><p><strong>状态</strong></p><p><strong>选择</strong></p><p>base case</p><h3 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h3><p>回溯算法和 DFS 算法的细微差别是：<strong>回溯算法是在遍历「树枝」，DFS 算法是在遍历「节点」</strong>，</p><ul><li><strong>形式一、元素无重不可复选，即 <code>nums</code> 中的元素都是唯一的，每个元素最多只能被使用一次，这也是最基本的形式</strong>。</li></ul><p>以组合为例，如果输入 <code>nums = [2,3,6,7]</code>，和为 7 的组合应该只有 <code>[7]</code>。</p><ul><li><strong>形式二、元素可重不可复选，即 <code>nums</code> 中的元素可以存在重复，每个元素最多只能被使用一次</strong>。</li></ul><p>以组合为例，如果输入 <code>nums = [2,5,2,1,2]</code>，和为 7 的组合应该有两种 <code>[2,2,2,1]</code> 和 <code>[5,2]</code>。</p><ul><li><strong>形式三、元素无重可复选，即 <code>nums</code> 中的元素都是唯一的，每个元素可以被使用若干次</strong>。</li></ul><p>以组合为例，如果输入 <code>nums = [2,3,6,7]</code>，和为 7 的组合应该有两种 <code>[2,2,3]</code> 和 <code>[7]</code></p><h3 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h3><ol><li>素数筛</li></ol><ul><li>思路：fork() and pipe()  </li><li>每个线程从标准输入中获取n个数，第一个数作为start必定是素数，随后遍历其余数字，若能被start整除则一定不是素数，因此把不能整除的数输入到标准输出给子进程。</li></ul><p>fd[0] 读出端；fd[1]写入端</p><ol start="2"><li>交替打印a b 100 次</li></ol><ul><li>思路：conditional_variable and unique_lock</li></ul><ol start="3"><li>交替打印a b c 100 次</li></ol><ul><li>思路：conditional_variable and unique_lock</li></ul><h3 id="只出现一次的元素"><a href="#只出现一次的元素" class="headerlink" title="只出现一次的元素"></a>只出现一次的元素</h3><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">全部元素进行异或操作，得到结果就是只出现一次的数</span><br><br><span class="hljs-string">解释：</span><br><span class="hljs-string">相同的两个数进行异或结果为0，0与另一个数异或结果为另一个数</span><br><span class="hljs-number">1111</span> <span class="hljs-string">^</span> <span class="hljs-number">1100</span> <span class="hljs-string">=</span> <span class="hljs-number">0011</span> <span class="hljs-string">;</span> <span class="hljs-number">0000</span> <span class="hljs-string">^</span> <span class="hljs-number">1100</span> <span class="hljs-string">=</span> <span class="hljs-number">1100</span><br></code></pre></td></tr></table></figure><h3 id="搜索二维矩阵"><a href="#搜索二维矩阵" class="headerlink" title="搜索二维矩阵"></a>搜索二维矩阵</h3><p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：</p><ul><li>每行的元素从左到右升序排列。</li><li>每列的元素从上到下升序排列。</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">解释：<br>从数组的左下角或者右上角开始遍历，因为左下角的元素比其上方的任意一个元素都大，比起右边的任意一个元素都小<br>如果此图形为方阵，可以从主对角线开始遍历；<br></code></pre></td></tr></table></figure><h3 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h3><p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p><p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p><p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3<br>输出：[1,2,2,3,5,6]<br>解释：需要合并 [1,2,3] 和 [2,5,6] 。<br>合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab3-pagetable</title>
    <link href="/2022/02/26/Lab3-pagetable/"/>
    <url>/2022/02/26/Lab3-pagetable/</url>
    
    <content type="html"><![CDATA[<h2 id="Virtual-Memory"><a href="#Virtual-Memory" class="headerlink" title="Virtual Memory"></a>Virtual Memory</h2><p>虚拟内存提供了一种映射，将进程的内存映射到物理内存上，并提供进程之间的保护与隔离。RISC-V的映射以块为单位，在后续的介绍中我们会了解到以块为单位映射带来的好处。</p><ul><li>为什么需要虚拟内存？</li></ul><ol><li>每个进程可以使用更大的地址空间</li><li>进程与进程之间相互隔离，不会干扰</li><li>共享内存，在xv6中我们发现进程之间可以通过pte共享某些页面的内容</li><li>保护，对pte的标志位做一下操作就可以对进程的访问做限制</li></ol><h3 id="Kernel-Page"><a href="#Kernel-Page" class="headerlink" title="Kernel Page"></a>Kernel Page</h3><p>地址0x1000是boot ROM的物理地址，当你对主板上电，主板做的第一件事情就是运行存储在boot ROM中的代码，当boot完成之后，会跳转到地址0x80000000，操作系统需要确保那个地址有一些数据能够接着启动操作系统。</p><ul><li>PLIC是中断控制器（Platform-Level Interrupt Controller）我们下周的课会讲。</li><li>CLINT（Core Local Interruptor）也是中断的一部分。所以多个设备都能产生中断，需要中断控制器来将这些中断路由到合适的处理函数。</li><li>UART0（Universal Asynchronous Receiver&#x2F;Transmitter）负责与Console和显示器交互。</li><li>VIRTIO disk，与磁盘进行交互</li></ul><h3 id="core-struct"><a href="#core-struct" class="headerlink" title="core struct"></a>core struct</h3><ul><li>pte：page table entry 中存储的内容可以转化为实际物理地址  PTE2PA(pte)</li><li>pa：physical address 实际物理地址，由freelist分配</li></ul><h3 id="walk"><a href="#walk" class="headerlink" title="walk"></a>walk</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Return</span> the address of the PTE in page table pagetable that corresponds to virtual address va.  <br><span class="hljs-attribute">If</span> alloc!=<span class="hljs-number">0</span>,create any required page-table pages.<br> <span class="hljs-attribute">The</span> risc-v Sv39 scheme has three levels of page-table<br> <span class="hljs-attribute">pages</span>. A page-table page contains <span class="hljs-number">512</span> <span class="hljs-number">64</span>-bit PTEs.<br> <span class="hljs-attribute">A</span> <span class="hljs-number">64</span>-bit virtual address is split into five fields:<br>   <span class="hljs-attribute">39</span>..<span class="hljs-number">63</span> -- must be zero.<br>   <span class="hljs-attribute">30</span>..<span class="hljs-number">38</span> -- <span class="hljs-number">9</span> bits of level-<span class="hljs-number">2</span> index.<br>   <span class="hljs-attribute">21</span>..<span class="hljs-number">29</span> -- <span class="hljs-number">9</span> bits of level-<span class="hljs-number">1</span> index.<br>   <span class="hljs-attribute">12</span>..<span class="hljs-number">20</span> -- <span class="hljs-number">9</span> bits of level-<span class="hljs-number">0</span> index.<br><span class="hljs-attribute">0</span>..<span class="hljs-number">11</span> -- <span class="hljs-number">12</span> bits of byte offset within the page.<br></code></pre></td></tr></table></figure><p>walk函数会递归的将sv39的三级页表页表项取出，其中PX(level, va)会根据页表的级数取出对应的pte。如果当前页表项为空且允许为其分配新的页面地址，则调用kalloc分配一个页面，并将地址存入此pte中；如果不为空，则递归进入下一级页表。</p><p>最终结果返回三级页表的某个地址，可用来查看内容也可以用来插入内容；</p><p><img src="/2022/02/26/Lab3-pagetable/image-20220310100802814.png" alt="image-20220310100802814"></p><h3 id="mappages"><a href="#mappages" class="headerlink" title="mappages"></a>mappages</h3><p>函数的作用是将va映射到pa上去，并将pte存入pagetable</p><ul><li>a ：va向4k对齐的基地址</li><li>last ：映射区域向4k对齐的最后一个页面的基地址</li><li><strong>walk函数则从pagetable中找到合适的 pte ，如果不存在会，会根据alloc参数决定是否分配页面</strong></li></ul><p><img src="/2022/02/26/Lab3-pagetable/image-20220228121327909.png" alt="image-20220228121327909"></p><h3 id="uvmcopy"><a href="#uvmcopy" class="headerlink" title="uvmcopy()"></a>uvmcopy()</h3><p>函数会将父进程的页表内容复制到子进程的页表中，第一步先从0地址开始按页查找对应pte，并根据pte找到对应的pa，随后将pa为起始地址的PGSIZE内容复制到kalloc新分配的页中，随后将老的虚拟地址和新分配的物理地址相互映射。</p><p>所以调用uvmcopy在用户态复制页表，只会复制页表的内容，而具体指向的物理地址并不一样。【fork系统调用会创建一个新的页表】</p><p><u>uvmcopy会复制oldpagetable中va对应pa所属页的内容到kalloc()新分配的pa上，并将新的pa映射到new pagetable</u></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Given a parent process&#x27;s page table, copy</span><br><span class="hljs-comment">// its memory into a child&#x27;s page table.</span><br><span class="hljs-comment">// Copies both the page table and the</span><br><span class="hljs-comment">// physical memory.</span><br><span class="hljs-comment">// returns 0 on success, -1 on failure.</span><br><span class="hljs-comment">// frees any allocated pages on failure.</span><br></code></pre></td></tr></table></figure><img src="/2022/02/26/Lab3-pagetable/image-20230313085847793.png" alt="image-20230313085847793" style="zoom:50%;"><h3 id="创建一个地址空间"><a href="#创建一个地址空间" class="headerlink" title="创建一个地址空间"></a>创建一个地址空间</h3><ol><li>freearange(end, PYHSTOP) 会将物理内存空间挂载到 <strong>freemem</strong> 这样一个list上，因为xv6中采用头插法，因此freemem指向的是高空闲地址空间</li><li>kinit() <code>physical page allocator</code>; kinit会初始化内存操作的自旋锁，并且根据kernel.ld提供的地址信息初始化物理内存空间</li><li>kvminit() <code>Initialize the one kernel_pagetable</code>; 创建内核页表，将内核数据（I&#x2F;O PLIC等映射到0-0x80000000）内核页表将会被分配到物理内存最顶端的page中</li><li>exec</li><li>xv6支持内核线程的概念，每个用户进程都由一个内核线程执行。并且xv6通过共享内存的方式进行多线程的通信。</li></ol><p><img src="/2022/02/26/Lab3-pagetable/image-20220228215322380.png" alt="image-20220228215322380"></p><hr><h3 id="打印第一个进程的页表"><a href="#打印第一个进程的页表" class="headerlink" title="打印第一个进程的页表"></a>打印第一个进程的页表</h3><p>如何打印进程的页表呢？首先我们要明确页表什么时候被建立，并被存储到什么地方</p><p>要回答第一个问题，最好的方式就是使用gdb跟踪initproc，追踪第一个用户进程的分配过程一定能够告诉我们页表建立的过程。</p><p><img src="/2022/02/26/Lab3-pagetable/image-20220307134228420.png" alt="image-20220307134228420"></p><p>上图展示的是xv6中的三级页表，在sv39中我们只用到了低39位，其中低12位为page offset，其余27位负责对三级页表进行索引，其中Page Directory 的首地址被存储在satp寄存器中，satp只有在陷入内核时或继承切换时能够被os修改，它对用户透明；</p><p>打印页表结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">page table 0x0000000087f6e000<br>..0: pte 0x0000000021fda801 pa 0x0000000087f6a000<br>.. ..0: pte 0x0000000021fda401 pa 0x0000000087f69000<br>.. .. ..0: pte 0x0000000021fdac1f pa 0x0000000087f6b000<br>.. .. ..1: pte 0x0000000021fda00f pa 0x0000000087f68000<br>.. .. ..2: pte 0x0000000021fd9c1f pa 0x0000000087f67000<br>..255: pte 0x0000000021fdb401 pa 0x0000000087f6d000<br>.. ..511: pte 0x0000000021fdb001 pa 0x0000000087f6c000<br>.. .. ..510: pte 0x0000000021fdd807 pa 0x0000000087f76000<br>.. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000<br></code></pre></td></tr></table></figure><p>递归的遍历页表；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Recursively free page-table pages.</span><br><span class="hljs-comment">// just like function freewalk</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">vmprint</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, <span class="hljs-type">int</span> level)</span>&#123;<br>  <span class="hljs-keyword">if</span>(level == <span class="hljs-number">2</span>)<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;page table %p\n&quot;</span>, pagetable);<br>  <span class="hljs-comment">// there are 2^9 = 512 PTEs in a page table.</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">512</span>; i++)&#123;<br>    <span class="hljs-type">pte_t</span> pte = pagetable[i];<br>    <span class="hljs-keyword">if</span>((pte &amp; PTE_V) &amp;&amp; level &gt; <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-comment">// this PTE points to a lower-level page table.</span><br>      <span class="hljs-keyword">if</span>(level == <span class="hljs-number">2</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;..%d: pte %p pa %p\n&quot;</span>, i, pte, PTE2PA(pte));<br>      <span class="hljs-keyword">if</span>(level == <span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;.. ..%d: pte %p pa %p\n&quot;</span>, i, pte, PTE2PA(pte));  <br>      uint64 child = PTE2PA(pte);<br>      vmprint((<span class="hljs-type">pagetable_t</span>)child, level<span class="hljs-number">-1</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((pte &amp; PTE_V) &amp;&amp; level == <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;.. .. ..%d: pte %p pa %p\n&quot;</span>, i, pte, PTE2PA(pte));<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pte &amp; PTE_V)&#123;<br>      panic(<span class="hljs-string">&quot;vmprint: leaf&quot;</span>);<br>    &#125; <br>  &#125;<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">//会发生panic init exiting 因为退出时p = initproc</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="A-kernel-page-table-for-per-process"><a href="#A-kernel-page-table-for-per-process" class="headerlink" title="A kernel page table for per process"></a>A kernel page table for per process</h3><p>本次实验的目的是为每一个进程创建一个专属的kernel pagetable。xv6的基础代码里只在内核中维护了一个内核页表，且内核页表被全部进程所共享，首先单一的内核栈很难允许多核并发的执行，<strong>其次专属的内核页表更有利于操作系统解引用？</strong></p><ol><li>当我们需要为进程增加一个属性时，首先需要做的就是在其结构体中增加一个属性，在这里我们添加一个pagetable_t kpagetable，表明每个进程都要维护了一个内核页表。</li><li>其次我们需要在创建用户进程时初始化内核页表，其次每个内核空间都要维护一个内核栈kernel stack，我们还要想办法初始化内核栈；</li><li>最后我们需要在进程切换时切换内核页表，在陷入时切换到进程所属的内核页表……</li></ol><h4 id="初始化进程的内核页表"><a href="#初始化进程的内核页表" class="headerlink" title="初始化进程的内核页表"></a>初始化进程的内核页表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>            <span class="hljs-title function_">proc_free_kpagetable</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span>, uint64)</span>;<br><span class="hljs-type">pagetable_t</span>     <span class="hljs-title function_">kpagetableinit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span>            <span class="hljs-title function_">kpagetable_map</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable ,uint64 va, uint64 pa, uint64 sz, <span class="hljs-type">int</span> perm)</span>;<br><br><span class="hljs-type">pagetable_t</span><br><span class="hljs-title function_">kpagetableinit</span><span class="hljs-params">()</span>&#123;<br><br>  <span class="hljs-type">pagetable_t</span> k_pagetable;<br>  k_pagetable = (<span class="hljs-type">pagetable_t</span>) kalloc();<br>  <span class="hljs-built_in">memset</span>(k_pagetable, <span class="hljs-number">0</span>, PGSIZE);<br>  <span class="hljs-comment">// uart registers</span><br>  kpagetable_map(k_pagetable, UART0, UART0, PGSIZE, PTE_R | PTE_W);<br>  <span class="hljs-comment">// virtio mmio disk interface</span><br>  kpagetable_map(k_pagetable, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);<br>  <span class="hljs-comment">// CLINT</span><br>  kpagetable_map(k_pagetable, CLINT, CLINT, <span class="hljs-number">0x10000</span>, PTE_R | PTE_W);<br>  <span class="hljs-comment">// PLIC</span><br>  kpagetable_map(k_pagetable, PLIC, PLIC, <span class="hljs-number">0x400000</span>, PTE_R | PTE_W);<br>  <span class="hljs-comment">// map kernel text executable and read-only.</span><br>  kpagetable_map(k_pagetable, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);<br>  <span class="hljs-comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span><br>  kpagetable_map(k_pagetable, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);<br>  <span class="hljs-comment">// map the trampoline for trap entry/exit to</span><br>  <span class="hljs-comment">// the highest virtual address in the kernel.</span><br>  kpagetable_map(k_pagetable, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);<br>  <span class="hljs-keyword">return</span> k_pagetable;<br>&#125;<br><span class="hljs-type">void</span> <br><span class="hljs-title function_">kpagetable_map</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable ,uint64 va, uint64 pa, uint64 sz, <span class="hljs-type">int</span> perm)</span>&#123;<br>  <span class="hljs-keyword">if</span>(mappages(pagetable, va, sz, pa, perm) != <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;kpagetable_map&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="映射内核栈"><a href="#映射内核栈" class="headerlink" title="映射内核栈"></a>映射内核栈</h4><p>在这个实验中，我们要把进程的内核栈映射到自己专属的内核页表中。如何做到这一点呢？其实就是将proc中的kstack映射到内核页表中，那么何时映射就是这个问题的关键。lab中提示我们将这个操作推迟到allocproc中，可以思考一下为什么</p><ul><li>很显然因为我们在allocproc中才有内核页表 （doge）</li><li>实际上我们应该思考为什么不能在procinit中为每个进程初始化内核页表并映射内核栈？我的理解是这样os启动的速度会很慢，而且页没有必要，毕竟不是所有进程都会被分配出去，只有当真的需要使用它们时我们再去为proc映射内核栈也完全来得及</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在allocproc中调用相关函数</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">allocproc</span><span class="hljs-params">()</span>&#123;<br>...<br><span class="hljs-comment">// Init the kernal page table</span><br>  <span class="hljs-comment">// An empty kernal page table</span><br>  p-&gt;k_pagetable = kpagetableinit();<br>  <span class="hljs-keyword">if</span>(p-&gt;k_pagetable == <span class="hljs-number">0</span>)&#123;<br>    freeproc(p-&gt;k_pagetable);<br>    release(&amp;p-&gt;lock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-type">char</span> *pa = kalloc();<br>  <span class="hljs-keyword">if</span>(pa == <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;kalloc&quot;</span>);<br>  uint64 va = KSTACK((<span class="hljs-type">int</span>) (p - proc));<br>  kvmmap(va, (uint64)pa, PGSIZE, PTE_R | PTE_W);<br>  p-&gt;kstack = va;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">freeproc</span><span class="hljs-params">()</span>&#123;<br>  uvmunmap(p-&gt;k_pagetable, p-&gt;kstack, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>  p-&gt;kstack = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span>(p-&gt;k_pagetable)<br>    proc_free_kpagetable(p-&gt;k_pagetable, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <br><span class="hljs-title function_">proc_free_kpagetable</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 depth)</span>&#123;<br>  <span class="hljs-comment">// there are 2^9 = 512 PTEs in a page table.</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">512</span>; i++)&#123;<br>    <span class="hljs-type">pte_t</span> pte = pagetable[i];<br>    <span class="hljs-keyword">if</span>((pte &amp; PTE_V))&#123;<br>      uint64 child = PTE2PA(pte);<br>      <span class="hljs-keyword">if</span>(depth &lt; <span class="hljs-number">2</span> &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="hljs-number">0</span>)&#123;<br>        proc_free_kpagetable((<span class="hljs-type">pagetable_t</span>)child, depth+<span class="hljs-number">1</span>);<br>      &#125;<br>      pagetable[i] = <span class="hljs-number">0</span>;<br>    &#125; <br>  &#125;<br>  kfree((<span class="hljs-type">void</span>*)pagetable);<br>&#125;<br></code></pre></td></tr></table></figure><p>调度上的切换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">w_satp(MAKE_SATP(p-&gt;k_pagetable));<br>sfence_vma();<br>swtch(&amp;c-&gt;context, &amp;p-&gt;context);<br>kvminithart();<br></code></pre></td></tr></table></figure><h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><p>我们还需要修改scheduler中的一些细节，比如在进程切换时我们要切换进程所属的内核页表，在释放进程空间时，我们需要释放kpagetable和内核栈</p><h3 id="copyin-copyinstr"><a href="#copyin-copyinstr" class="headerlink" title="copyin copyinstr"></a>copyin copyinstr</h3><p>本实验的目的是为了让内核页表拥有用户空间的映射关系，这样我们就可以在内核空间对用户地址进行操作了</p><p>内核的<code>copyin</code>函数读取用户指针指向的内存。它通过将用户指针转换为内核可以直接解引用的物理地址来实现这一点。这个转换是通过在软件中遍历进程页表来执行的。在本部分的实验中，您的工作是将用户空间的映射添加到每个进程的内核页表（上一节中创建），以允许<code>copyin</code>（和相关的字符串函数<code>copyinstr</code>）直接解引用用户指针。</p><h4 id="复制用户页表到内核页表"><a href="#复制用户页表到内核页表" class="headerlink" title="复制用户页表到内核页表"></a>复制用户页表到内核页表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">u2kvmcopy</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, <span class="hljs-type">pagetable_t</span> kpagetable, uint64 oldsz, uint64 newsz)</span>&#123;<br>  <span class="hljs-type">pte_t</span> *pte_from, *pte_to;<br>  oldsz = PGROUNDUP(oldsz);<br>  <span class="hljs-keyword">for</span> (uint64 i = oldsz; i &lt; newsz; i += PGSIZE)&#123;<br>    <span class="hljs-keyword">if</span>((pte_from = walk(pagetable, i, <span class="hljs-number">0</span>)) == <span class="hljs-number">0</span>)<br>      panic(<span class="hljs-string">&quot;u2kvmcopy: src pte does not exist&quot;</span>);<br>    <span class="hljs-keyword">if</span>((pte_to = walk(kpagetable, i, <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>)<br>      panic(<span class="hljs-string">&quot;u2kvmcopy: pte walk failed&quot;</span>);<br>    uint64 pa = PTE2PA(*pte_from);<br>    uint flags = (PTE_FLAGS(*pte_from)) &amp; (~PTE_U);<br>    *pte_to = PA2PTE(pa) | flags;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>除此之外，每次用户页表可能发生改变的时候我们都要对内核页表上的这部分进行修改，那么有哪些函数可能对用户页表进行操作呢？</li></ul><p>exec 时也会需要对内核页表进行操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">exec</span><span class="hljs-params">(<span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> **argv)</span>&#123;<br>  ...<br>  sp = sz;<br>  stackbase = sp - PGSIZE;<br>  <span class="hljs-comment">// 添加复制逻辑</span><br>  u2kvmcopy(pagetable, p-&gt;kpagetable, <span class="hljs-number">0</span>, sz);<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>fork 需要把parent的内核页表复制到child的内核页表中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>  ...<br>  <span class="hljs-comment">// Copy user memory from parent to child.</span><br>  <span class="hljs-keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="hljs-number">0</span>)&#123;<br>    freeproc(np);<br>    release(&amp;np-&gt;lock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  np-&gt;sz = p-&gt;sz;<br>  ...<br>  <span class="hljs-comment">// 复制到新进程的内核页表</span><br>  u2kvmcopy(np-&gt;pagetable, np-&gt;kernelpt, <span class="hljs-number">0</span>, np-&gt;sz);<br>  ...<br>&#125;<br><br></code></pre></td></tr></table></figure><p>sbrk &#x3D;&gt; growproc</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">growproc</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br>  uint sz;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  sz = p-&gt;sz;<br>  <span class="hljs-keyword">if</span>(n &gt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">// 加上PLIC限制</span><br>    <span class="hljs-keyword">if</span> (PGROUNDUP(sz + n) &gt;= PLIC)&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>((sz = uvmalloc(p-&gt;pagetable, sz, sz + n)) == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 复制一份到内核页表</span><br>    u2kvmcopy(p-&gt;pagetable, p-&gt;kpagetable, sz - n, sz);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">0</span>)&#123;<br>    sz = uvmdealloc(p-&gt;pagetable, sz, sz + n);<br>  &#125;<br>  p-&gt;sz = sz;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>xv6_riscv Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab2-syscall</title>
    <link href="/2022/02/26/Lab2-syscall/"/>
    <url>/2022/02/26/Lab2-syscall/</url>
    
    <content type="html"><![CDATA[<h2 id="sys-call"><a href="#sys-call" class="headerlink" title="sys_call"></a>sys_call</h2><p>产生系统调用时，用户会将需要的参数放在a0,a1中，将系统调用编号放在a7中。系统调用号与syscalls数组进行匹配。执行ecall会trap进</p><p>内核，执行<code>uservec</code>、<code>usertrap</code>和<code>syscall</code>，和我们之前看到的一样。</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smali">任何的系统调用都是将参数传递给ecall，然后通过ecall陷入内核执行对应的系统调用，内核会对用户态传入的参数进行检查，<br>xv6中例如fetchstr fetchadd这种？并且决定是否要执行系统调用。ecall将我们的控制权从用户程序转移到内核。<br></code></pre></td></tr></table></figure><p><code>syscall</code>（<em><strong>kernel&#x2F;syscall.c*</strong>:133）从陷阱帧（trapframe）中保存的<code>a7</code>中检索系统调用号（<code>p-&gt;trapframe-&gt;a7</code>），并用它索引到<code>syscalls</code>中，对于第一次系统调用，<code>a7</code>中的内容是<code>SYS_exec</code>（</em><strong>kernel&#x2F;syscall. h*</strong>:8），导致了对系统调用接口函数<code>sys_exec</code>的调用。</p><p>当系统调用接口函数返回时，<code>syscall</code>将其返回值记录在<code>p-&gt;trapframe-&gt;a0</code>中。这将导致原始用户空间对<code>exec()</code>的调用返回该值，因为RISC-V上的C调用约定将返回值放在<code>a0</code>中。系统调用通常返回负数表示错误，返回零或正数表示成功。如果系统调用号无效，<code>syscall</code>打印错误并返回-1。</p><hr><p>为内核添加系统调用流程：</p><ol><li>创建对应user目录下的接口，并在Makefile中注册 $U&#x2F;_sysinfotest</li><li>在user&#x2F;user.h中声明sysinfo()的原型；user.h是对用户的接口</li><li>在user&#x2F;user.pl中声明sysinfo的存根 entry</li><li>在syscall.h中声明trap num</li><li>在syscall.c中写出内核原型</li><li>在sysproc.c中写出内核实现</li></ol><hr><p>Lab2 主要让我们熟悉了如何向内核中添加系统调用，而不仅仅是写出用户态的接口，大体只需按照上述顺序一步一步实现即可，下面是对实验过程中一些函数的解读，以便复习</p><hr><h3 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h3><p>xv6将所有系统调用所对应的编号（Syscall Number）声明在syscall.h中，在syscall.c中给出了函数原型以及<em>表驱动函数？</em> 总之只需按照xv6源码中给出的代码照葫芦画瓢即可完成系统调用的一些初试工作。</p><p>在syscall.c中实现了一些获取系统调用参数的函数，例如argint(int nth, int *ip)其功能是将第n+1个参数以int类型赋予ip所在地址的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hint">xv6中将与进程相关的系统调用实现在sysproc.c中，文件相关的系统调用实现在sysfile.c中.....<br></code></pre></td></tr></table></figure><p>基础工作完成后，本次实验只需将系统调用参数传递给当前进程即可，当前进程会在执行系统调用时判断是否需要打印信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">syscall</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> num;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  <span class="hljs-type">int</span> trace_mask = p-&gt;trace_mask;<br>  <span class="hljs-comment">// a7 保存系统调用参数</span><br>  num = p-&gt;trapframe-&gt;a7;<br>  <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;<br>    p-&gt;trapframe-&gt;a0 = syscalls[num]();<br>    <span class="hljs-comment">// a0 -- ra 寄存器  负责保存返回值</span><br>    <span class="hljs-keyword">if</span>((trace_mask &gt;&gt; num) &amp; <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d syscall %s-&gt; %d\n&quot;</span>, p-&gt;pid, syscall_names[num<span class="hljs-number">-1</span>], p-&gt;trapframe-&gt;a0);<br>    &#125;<br>  <br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %s: unknown sys call %d\n&quot;</span>,<br>            p-&gt;pid, p-&gt;name, num);<br>    p-&gt;trapframe-&gt;a0 = <span class="hljs-number">-1</span>;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h3 id="sysinfo"><a href="#sysinfo" class="headerlink" title="sysinfo"></a>sysinfo</h3><p>sysinfo是一个记录当前进程信息的结构体，它保存在用户态下，我们可以在声明系统调用的用户接口user.h中看到，而进程和内存的信息却都是内核态下的数据，我们需要利用copyout将数据从内核态中取出并在用户态下展示；</p><p>其余按照trace一样，向内核中引入sys_sysinfo系统调用, 后面只需简单实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64<br><span class="hljs-title function_">sys_sysinfo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysinfo</span> <span class="hljs-title">sysinfo</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span><br>  p = myproc();<br>  uint64 addr;<br><br>  <span class="hljs-comment">// 这里是用addr指向了传递过来的sysinfo参数</span><br>  <span class="hljs-comment">// 函数用一个sysinfo变量接收了kernel的sysinfo</span><br><br>  sysinfo.freemem = freemem();<span class="hljs-comment">// 获取空余内存byte</span><br>  sysinfo.nproc = getnproc();<span class="hljs-comment">// 获取正在运行的进程</span><br><br>  <span class="hljs-comment">// 获取第0个参数，并放到addr</span><br>  <span class="hljs-keyword">if</span>(argaddr(<span class="hljs-number">0</span>, &amp;addr) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-comment">// 通过copyout将sysinfo参数中的值传递出去</span><br>  <span class="hljs-keyword">if</span>(copyout(p-&gt;pagetable, addr, (<span class="hljs-type">char</span>*) &amp;sysinfo, <span class="hljs-keyword">sizeof</span>(sysinfo)) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 获取空闲内存的字节数,</span><br><span class="hljs-comment">// 首先遍历空闲链表，每个空闲块都是一个PGSIZE</span><br><span class="hljs-comment">// 经过一个块，sum加一个pagsize</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">freemem</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span><br>  uint64 sum = <span class="hljs-number">0</span>;<br>  acquire(&amp;kmem.lock);<br>  r = kmem.freelist;<br>  <span class="hljs-keyword">while</span>(r)&#123;<br>    r = r-&gt;next;<br>    sum += PGSIZE;<br>  &#125;<br>  release(&amp;kmem.lock);<br>  <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// state字段不为UNUSED的进程数</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">getnproc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span><br>  <span class="hljs-type">int</span> nums = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;<br>    acquire(&amp;p-&gt;lock);<br>    <span class="hljs-keyword">if</span>(p-&gt;state != UNUSED)<br>      nums++;<br>    release(&amp;p-&gt;lock);<br>  &#125;<br>  <span class="hljs-keyword">return</span> nums;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>xv6_riscv Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab1-util</title>
    <link href="/2022/02/20/Lab1-util/"/>
    <url>/2022/02/20/Lab1-util/</url>
    
    <content type="html"><![CDATA[<h2 id="util-in-xv6"><a href="#util-in-xv6" class="headerlink" title="util in xv6"></a>util in xv6</h2><p><strong>1.用户态调用</strong></p><p>在用户空间，所有system call的函数声明写在<code>user.h</code>中，调用后会进入<code>usys.S</code>执行汇编指令：将对应的系统调用号（system call number）置于寄存器a7中，并执行ecall指令进行系统调用，其中函数参数存在a0~a5这6个寄存器中。ecall指令将触发软中断，cpu会暂停对用户程序的执行，转而执行内核的中断处理逻辑，陷入（trap）内核态。</p><p><strong>2.上下文切换</strong></p><p>中断处理在<code>kernel/trampoline.S</code>中，首先进行上下文的切换，将user进程在寄存器中的数据save到内存中（保护现场），并restore（恢复）kernel的寄存器数据。内核中会维护一个进程数组（最多容纳64个进程），存储每个进程的状态信息，proc结构体定义在proc.h，这也是xv6对PCB（Process Control Block）的实现。用户程序的寄存器数据将被暂时保存到<code>proc-&gt;trapframe</code>结构中。</p><p><strong>3.内核态执行</strong></p><p>完成进程切换后，调用<code>trap.c/usertrap()</code>，接着进入<code>syscall.c/syscall()</code>，在该方法中根据system call number拿到数组中的函数指针，执行系统调用函数。函数参数从用户进程的<code>trapframe</code>结构中获取(a0~a5)，函数执行的结果则存储于trapframe的a0字段中。完成调用后同样需要进程切换，先save内核寄存器到<code>trapframe-&gt;kernel_*</code>，再将trapframe中暂存的user进程数据restore到寄存器，重新回到用户空间，cpu从中断处继续执行，从寄存器a0中拿到函数返回值。</p><table><thead><tr><th>Sys_call</th><th align="center">Funtion</th></tr></thead><tbody><tr><td>fork()</td><td align="center">复制进程的全部状态，包reg以及执行状态,并继续执行；返回子进程pid，子进程返回0；</td></tr><tr><td>wait((int)* status)</td><td align="center">暂停当前进程，直到有信号或子进程结束；若子进程在调用前已经结束，则直接用status返回状态</td></tr><tr><td>write(fd , buf , MSGSIZE)</td><td align="center">从buf中取出MSGSIZE个子节的数据写入fd所指向的文件</td></tr><tr><td>read(fd , buf , MSGSIZE)</td><td align="center">从fd中取出MSGSIZE个子节的数据写入buf</td></tr><tr><td>pipe()</td><td align="center">生成一个管道p[0]用来read,p[1]用来write</td></tr><tr><td>exit()</td><td align="center">退出当前进程执行</td></tr></tbody></table><hr><h2 id="Sleep"><a href="#Sleep" class="headerlink" title="Sleep"></a>Sleep</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span>* argv[])</span>&#123;<br>    <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Sleep needs one argument!\n&quot;</span>); <span class="hljs-comment">//检查参数数量是否正确</span><br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-type">int</span> seconds = atoi(argv[<span class="hljs-number">1</span>]); <span class="hljs-comment">//将字符串参数转为整数</span><br>    sleep(seconds);              <span class="hljs-comment">//使用系统调用sleep</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(nothing happens for a little while)\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">//确保进程退出</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Ping-Pong"><a href="#Ping-Pong" class="headerlink" title="Ping-Pong"></a>Ping-Pong</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSGSIZE 5</span><br><span class="hljs-type">char</span>* msg1 = <span class="hljs-string">&quot;ping&quot;</span>;<br><span class="hljs-type">char</span>* msg2 = <span class="hljs-string">&quot;pong&quot;</span>;<br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">char</span> buf[MSGSIZE];<br>    <span class="hljs-type">int</span> fds[<span class="hljs-number">2</span>];<br>    pipe(fds);<br><br>    <span class="hljs-type">int</span> pid = fork();<br><br>    <span class="hljs-comment">// parents process</span><br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>)&#123;<br>        write(fds[<span class="hljs-number">1</span>], msg1, MSGSIZE);<span class="hljs-comment">// 向fd[1]中写入</span><br>        wait(<span class="hljs-number">0</span>);<span class="hljs-comment">// 最好加上wait</span><br>        read(fds[<span class="hljs-number">0</span>], buf, MSGSIZE);<span class="hljs-comment">// 从fd[0]中读出</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,getpid());<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;: received &quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,buf);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        read(fds[<span class="hljs-number">0</span>], buf, MSGSIZE);<br>        write(fds[<span class="hljs-number">1</span>], msg2, MSGSIZE);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,getpid());<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;: received &quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,buf);<br>    &#125;<br><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Primes"><a href="#Primes" class="headerlink" title="Primes"></a>Primes</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">prime</span><span class="hljs-params">(<span class="hljs-type">int</span> input_fd)</span><br>&#123;<br>    <span class="hljs-type">int</span> base;<br>    <span class="hljs-comment">/* Exit if last child */</span><br>    <span class="hljs-keyword">if</span> (read(input_fd, &amp;base, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)) == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;prime %d\n&quot;</span>, base);<br><br>    <span class="hljs-comment">/* Create new child if not last */</span><br>    <span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<br>    pipe(p);<br>    <span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>)<br>    &#123;<br>        close(p[<span class="hljs-number">1</span>]);<br>        prime(p[<span class="hljs-number">0</span>]);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        close(p[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">int</span> n;<br>        <span class="hljs-type">int</span> eof;<br>        <span class="hljs-keyword">do</span><br>        &#123;<br>            eof = read(input_fd, &amp;n, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>            <span class="hljs-keyword">if</span> (n % base != <span class="hljs-number">0</span>)<br>            &#123;<br>                write(p[<span class="hljs-number">1</span>], &amp;n, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>            &#125;<br>        &#125; <span class="hljs-keyword">while</span> (eof);<br><br>        close(p[<span class="hljs-number">1</span>]);<br>    &#125;<br>    wait(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">int</span> parent_fd[<span class="hljs-number">2</span>];<br>    pipe(parent_fd);<br>    <span class="hljs-keyword">if</span> (fork())<br>    &#123;<br>        close(parent_fd[<span class="hljs-number">0</span>]);    <span class="hljs-comment">// 关闭没用的文件</span><br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">2</span>; i &lt; <span class="hljs-number">36</span>; i++)<br>        &#123;<br>            write(parent_fd[<span class="hljs-number">1</span>], &amp;i, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>        &#125;<br>        close(parent_fd[<span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        close(parent_fd[<span class="hljs-number">1</span>]);<br>        prime(parent_fd[<span class="hljs-number">0</span>]);<br>    &#125;<br>    wait(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>实验中提醒我们要参考ls.c来实现find，第一步我们要明确find中各个函数的功能都是什么</p><p>其中fmtname是负责将文件名标准化，它会保留文件名第一个’&#x2F;‘之前的字符并返回</p><p>find函数负责查询和逻辑上的处理，从path开始查找是否存在和target相同的文件或目录</p><hr><p>ls会首先打开当前目录，并依次读取目录中的文件；那么find只需打开当前目录，按顺序检测其中文件和目录，若为文件则检测文件名是否一致，若为目录，则判断此目录是否可以继续递归查询</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/fs.h&quot;</span></span><br><br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">  第一个参数：./README ./cat 类似的参数</span><br><span class="hljs-comment">  返回结果： README cat</span><br><span class="hljs-comment">*/</span> <br><span class="hljs-type">char</span>*<br><span class="hljs-title function_">fmtname</span><span class="hljs-params">(<span class="hljs-type">char</span> *path)</span><br>&#123;<br>  <span class="hljs-type">static</span> <span class="hljs-type">char</span> buf[DIRSIZ+<span class="hljs-number">1</span>];<br>  <span class="hljs-type">char</span> *p;<br><br>  <span class="hljs-comment">// Find first character after last slash.</span><br>  <span class="hljs-keyword">for</span>(p=path+<span class="hljs-built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="hljs-string">&#x27;/&#x27;</span>; p--)<br>    ;<br>  p++;<br><br>  <span class="hljs-comment">// Return blank-padded name.</span><br>  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strlen</span>(p) &gt;= DIRSIZ)<br>    <span class="hljs-keyword">return</span> p;<br>  memmove(buf, p, <span class="hljs-built_in">strlen</span>(p));<br>  <span class="hljs-built_in">memset</span>(buf+<span class="hljs-built_in">strlen</span>(p), <span class="hljs-number">0</span>, DIRSIZ-<span class="hljs-built_in">strlen</span>(p));<br>  <span class="hljs-keyword">return</span> buf;<br>&#125;<br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">isrecursive</span><span class="hljs-params">(<span class="hljs-type">char</span> *target)</span>&#123;<br>  <span class="hljs-type">char</span>* buf = fmtname(target);<br>  <span class="hljs-keyword">if</span>(buf[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; buf[<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span>(buf[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; buf[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; buf[<span class="hljs-number">2</span>] == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *target)</span><br>&#123;<br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>], *p;<br>  <span class="hljs-type">int</span> fd;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br><br>  <span class="hljs-keyword">if</span>((fd = open(path, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: cannot open %s\n&quot;</span>, path);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: cannot stat %s\n&quot;</span>, path);<br>    close(fd);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(fmtname(path), target) == <span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">// 递归进入文件后，比较文件名与目标名称是否一致</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s  %d\n&quot;</span>, path, st.type);<br>  &#125;<br><br>  <span class="hljs-keyword">switch</span>(st.type)&#123;<br>  <span class="hljs-keyword">case</span> T_DIR:<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strlen</span>(path) + <span class="hljs-number">1</span> + DIRSIZ + <span class="hljs-number">1</span> &gt; <span class="hljs-keyword">sizeof</span> buf)&#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find: path too long\n&quot;</span>);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-built_in">strcpy</span>(buf, path);<br>    p = buf+<span class="hljs-built_in">strlen</span>(buf);<br>    *p++ = <span class="hljs-string">&#x27;/&#x27;</span>;<br>    <span class="hljs-keyword">while</span>(read(fd, &amp;de, <span class="hljs-keyword">sizeof</span>(de)) == <span class="hljs-keyword">sizeof</span>(de))&#123;       <span class="hljs-comment">// 按次序读出目录中所有文件</span><br>      <span class="hljs-keyword">if</span>(de.inum == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">continue</span>;<br>      memmove(p, de.name, DIRSIZ);<br>      p[DIRSIZ] = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">if</span>(stat(buf, &amp;st) &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find: cannot stat %s\n&quot;</span>, buf);<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span>(isrecursive(buf))&#123;<br>        find(buf, target);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">break</span>;<br>  &#125;<br>  close(fd);<br>&#125;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">  第一个参数：find命令</span><br><span class="hljs-comment">  第二个参数：从什么位置开始查找</span><br><span class="hljs-comment">  第三个参数：查找文件或目录的名称</span><br><span class="hljs-comment">*/</span> <br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>  <br>&#123;<br>  <span class="hljs-keyword">if</span>(argc == <span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage : find [path] [target]\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span>(argc == <span class="hljs-number">2</span>)&#123;<br>    find(<span class="hljs-string">&quot;.&quot;</span>,argv[<span class="hljs-number">1</span>]); <br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span>(argc == <span class="hljs-number">3</span>)&#123;<br>    find(argv[<span class="hljs-number">1</span>],argv[<span class="hljs-number">2</span>]); <br>  &#125;<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><ul><li><p>echo “1\n2” | xargs -n 1 line</p></li><li><p>xargs 是给后面指令传递参数的过滤器，负责按行从前一个指令的标准输出中读取作为后一个指令的扩展参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/param.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/fs.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSGSIZE 16</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><span class="hljs-comment">// 这个arg参数存在一些问题，去掉const可以编译</span><br>&#123;<br>    sleep(<span class="hljs-number">10</span>);<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    管道会将前面指令的标准输出重定向到标准输入，</span><br><span class="hljs-comment">    所以只需从fd = 0的标准输入中读出指令即可</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-type">char</span> buf[MSGSIZE]; <br>    read(<span class="hljs-number">0</span>, buf, MSGSIZE);<br><br>    <span class="hljs-comment">// exec 命令和附加参数</span><br>    <span class="hljs-type">char</span> *xargv[MAXARG];       <span class="hljs-comment">// 指令的参数</span><br>    <span class="hljs-type">int</span> xargc = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; argc; i++)&#123;<br>        xargv[xargc++] = argv[i];<br>    &#125;<br><br>    <span class="hljs-type">char</span> *p = buf;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSGSIZE; i++)&#123;<br>        <span class="hljs-keyword">if</span>(buf[i] == <span class="hljs-string">&#x27;\n&#x27;</span>)&#123;<br>            <span class="hljs-type">int</span> pid = fork();<br>            <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>)&#123;<br>                p = &amp;buf[i + <span class="hljs-number">1</span>];<br>                wait(<span class="hljs-number">0</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                buf[i] = <span class="hljs-number">0</span>;<br>                xargv[xargc] = p;<br>                xargc++;<br>                xargv[xargc] = <span class="hljs-number">0</span>;<br>                xargc++;<br>                exec(xargv[<span class="hljs-number">0</span>], xargv);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>xv6_riscv Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Interrupt</title>
    <link href="/2022/02/19/Interrupt/"/>
    <url>/2022/02/19/Interrupt/</url>
    
    <content type="html"><![CDATA[<h2 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a>中断机制</h2><ul><li><p>描述中断处理的流程</p></li><li><p>对于任何中断，是否都需要保存寄存器？</p></li><li><p>触发、捕获、处理异常</p></li></ul><h2 id="RISC-V相关中断"><a href="#RISC-V相关中断" class="headerlink" title="RISC-V相关中断"></a>RISC-V相关中断</h2><ul><li><p>RISCV架构下有三种特权级别，分别是Machine、Supervisor和User，简称M模式、S模式和U模式。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">M模式权限最高，在这个级别下的程序可以访问一切硬件和执行所有特权指令；<br>S模式一般用于运行操作系统，可以设置MMU使用虚拟地址；<br>U模式一般是普通应用程序使用，权限最低。<br></code></pre></td></tr></table></figure></li><li><p><code>sstatus</code>寄存器(Supervisor Status Register)里面有一个二进制位<code>SIE</code>(supervisor interrupt enable，在RISCV标准里是2^1 对应的二进制位)，数值为0的时候，如果当程序在S态运行，将禁用全部中断。（对于在U态运行的程序，SIE这个二进制位的数值没有任何意义），<code>sstatus</code>还有一个二进制位<code>UIE</code>(user interrupt enable)可以在置零的时候禁止用户态程序产生中断。</p></li><li><p>RISC-V用一个<strong>stvec (Supervisor Trap Vector Base Address Reg )</strong> 寄存器来存储中断向量表的位置。中断向量表能将不同种类的中断映射到各自的中断处理程序上，如果只有一个中断处理程序，那么stvec直接指向中断处理程序的地址</p></li><li><p><strong>sepc</strong>(supervisor exception program counter)，它会记录触发中断的那条指令的地址；</p></li><li><p><strong>scause</strong>，它会记录中断发生的原因，还会记录该中断是不是一个外部中断；</p></li><li><p><strong>stval</strong>，它会记录一些中断处理所需要的辅助信息，比如指令获取(instruction fetch)、访存、缺页异常，它会把发生问题的目标地址或者出错的指令记录下来，这样我们在中断处理程序中就知道处理目标了。</p></li></ul><hr><ul><li><strong>ra</strong> return address</li></ul><ol><li><p>The return address is specified in the stack when a program contains a function call or subroutine.</p></li><li><p>When the function is called then, after its complete execution it has to return back to the original program i.e., the next instruction after the function call in the program. </p></li><li><p>When the function call is to be executed then, the program counter PC holds the address of the next instruction after the function call in the program.</p></li><li><p>For executing the function, the control has to go to the function definition and after executing the function it has to return to the next instruction after the function call in the program.</p></li><li><p>So, when the function is to be executed then, the PC value i.e., the next instruction address is stored onto the stack (SP incremented) and the PC is updated by the address where the function is stored.</p></li><li><p>After the complete execution of the function, the PC gets updated by the return address present in the stack (value at the top of the stack).</p></li></ol><hr><h2 id="Trap-流程"><a href="#Trap-流程" class="headerlink" title="Trap 流程"></a>Trap 流程</h2><ol><li>首先，我们需要保存32个用户寄存器。因为很显然我们需要恢复用户应用程序的执行，尤其是当用户程序随机的被设备中断所打断时。我们希望内核能够响应中断，之后在用户程序完全无感知的情况下再恢复用户代码的执行。所以这意味着32个用户寄存器不能被内核弄乱。但是这些寄存器又要被内核代码所使用，所以在trap之前，你必须先在某处保存这32个用户寄存器。</li><li>程序计数器也需要在某个地方保存，它几乎跟一个用户寄存器的地位是一样的，我们需要能够在用户程序运行中断的位置继续执行用户程序</li><li>我们需要将mode改成supervisor mode，因为我们想要使用内核中的各种各样的特权指令。</li><li>SATP寄存器现在正指向user page table，而user page table只包含了用户程序所需要的内存映射和一两个其他的映射，它并没有包含整个内核数据的内存映射。所以在运行内核代码之前，我们需要将SATP指向kernel page table。</li><li>我们需要将堆栈寄存器指向位于内核的一个地址，因为我们需要一个堆栈来调用内核的C函数。</li><li>一旦我们设置好了，并且所有的硬件状态都适合在内核中使用， 我们需要跳入内核的C代码。</li></ol><p>supervisor mode时，你可以：读写SATP寄存器，也就是page table的指针；STVEC，也就是处理trap的内核指令地址；SEPC，保存当发生trap时的程序计数器；SSCRATCH等等。在supervisor mode你可以读写这些寄存器，而用户代码不能做这样的操作。</p><p>另一件事情supervisor mode可以做的是，它可以使用PTE_U标志位为0的PTE。当PTE_U标志位为1的时候，表明用户代码可以使用这个页表；如果这个标志位为0，则只有supervisor mode可以使用这个页表。我们接下来会看一下为什么这很重要</p><p>需要特别指出的是，supervisor mode中的代码并不能读写任意物理地址。在supervisor mode中，就像普通的用户代码一样，也需要通过page table来访问内存。如果一个虚拟地址并不在当前由SATP指向的page table中，又或者SATP指向的page table中PTE_U&#x3D;1，那么supervisor mode不能使用那个地址。所以，即使我们在supervisor mode，我们还是受限于当前page table设置的虚拟地址。</p><p>Trap执行流程;</p><p><strong>ecall  &#x3D;&#x3D;&gt;  uservec()  (trampoline.S)  &#x3D;&#x3D;&gt;  usertrap()  (trap.c)   &#x3D;&#x3D;&gt;   syscall()</strong></p><p>ecall并不会切换page table，这是ecall指令的一个非常重要的特点</p><h2 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h2><p>中断的处理需要“放下当前的事情但之后还能回来接着之前往下做”，对于CPU来说，实际上只需要把原先的寄存器保存下来，做完其他事情把寄存器恢复回来就可以了。这些**寄存器也被叫做CPU的context(上下文，情境)**。</p><p>我们要用汇编实现上下文切换(context switch)机制，这包含两步：</p><ul><li>保存CPU的寄存器（上下文）到内存中（栈上）</li><li>从内存中（栈上）恢复CPU的寄存器</li></ul><p>上下文切换的过程</p><p>上下文切换需要利用到一个csr寄存器，sscratch, 它存储了当前执行进程的上下文状态；那么上下文切换实质上就是保存当前寄存器的所有状态，将sscratch指向下一个进程的context并将信息恢复至寄存器中</p><ol><li>Task A按照顺序执行，执行到 call switch时，保存当前context</li><li>操作系统会在内存中分配一段内存用于保存寄存器现场，并将下次执行开始的地址作为ra的值存入contextA</li><li>操作系统会管理一个Context的链表，将contextA存入，并将sscratch执行contexB</li><li>将contextB的寄存器现场恢复至CPU中，执行Task B</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Operating System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Chapter1</title>
    <link href="/2022/02/19/Chapter1-1/"/>
    <url>/2022/02/19/Chapter1-1/</url>
    
    <content type="html"><![CDATA[<h2 id="Operating-System-Three-Easy-Pieces"><a href="#Operating-System-Three-Easy-Pieces" class="headerlink" title="Operating System: Three Easy Pieces"></a>Operating System: Three Easy Pieces</h2><h3 id="Concurrent-并发"><a href="#Concurrent-并发" class="headerlink" title="Concurrent 并发"></a>Concurrent 并发</h3><ul><li><p><strong>Def</strong> : different parts of units in program to be executed out-of-order or in partial order</p></li><li><p>程序中不同的部分，能够在同一时间段乱序的或部分有序的执行，这就叫做并发</p><p>首先，我们的os可以在同时加载多个程序到内存中执行，这些程序可以运行并相互隔离互不干扰，这是操作系统一定需要实现的isolation<br>其次，操作系统内核中的对象在某些时刻需要被共享<br>最后，如果一个错误的程序一直占用cpu，我们需要想办法将程序暂停并将cpu从中取出，让cpu执行正确的程序，这种取出cpu的方式便是中断<br>如此多的程序要在os中运行，我们首先要学会如何理解多个程序运行的状态，为此我们也需要放弃一些传统的观点</p></li></ul><h3 id="并发编程（多线程编程）从入门到放弃"><a href="#并发编程（多线程编程）从入门到放弃" class="headerlink" title="并发编程（多线程编程）从入门到放弃"></a>并发编程（多线程编程）从入门到放弃</h3><ul><li>一个Thread 就是一个执行流 , 进程中的线程共享内存、代码和全局变量，独享一些寄存器和堆栈</li><li>但线程之间指令的顺序是non-deterministic的，这就带来了许多有趣的现象</li></ul><h4 id="放弃"><a href="#放弃" class="headerlink" title="放弃"></a>放弃</h4><ul><li>原子性（高级语言的原子性）</li></ul><p>首先我们要解释何为代码的原子性，我们大体可以理解为一段代码的执行不会被干扰</p><p>中断与并行会让我们失去原子性</p><ul><li>顺序性（CPU执行的顺序性）</li></ul><p>当我们的程序被转化为汇编指令的过程中，我们的CPU会对其执行流进行优化，也就是我们常说的编译优化；</p><p>例如一个经典的例子，两个进程同时对 i 执行i &#x3D; i + 1 ，并重复执行n次，此时不同的gcc优化条件会导致不同的结果，答案将会是n-2n中的某个数字</p><p>编译器的优化会让我们失去顺序性</p><ul><li>可见性（内存的可见性）</li></ul><p>CPU执行时，会尽可能的让程序快速的执行，所以一些看似无关的代码可能会被提前执行，进而导致我们很难预测程序的执行，也就是开篇提到过的out-of-order</p><p>处理器的乱序执行会会让我们失去可见性，结果也不能立刻告诉其他处理器</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">三种属性其实都是来帮助我们理解并发程序的，大家可以根据各自的理解赋予这些属性含义<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><hr><h3 id="如何保证顺序性"><a href="#如何保证顺序性" class="headerlink" title="如何保证顺序性"></a>如何保证顺序性</h3><ul><li><p>阻止编译器优化变量读写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">delay</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; DELAY_COUNT; i++) ;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在局部制止编译器调整指令顺序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> barrier() asm volatile (<span class="hljs-string">&quot;&quot;</span>:::<span class="hljs-string">&quot;memory&quot;</span>)</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> x, y;<br>  x++;<br>  barrier(); <span class="hljs-comment">// ============================</span><br>  x++;       <span class="hljs-comment">// 阻止 x 的访问被合并</span><br>  y++;       <span class="hljs-comment">// y 的访问不能被移到 barrier 之前</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Operating System:JYY</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
